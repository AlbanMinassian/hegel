{"version":3,"sources":["webpack://lib/webpack/bootstrap","webpack://lib//home/runner/work/hegel/hegel/node_modules/@babel/parser/lib/index.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_a-function.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_add-to-unscopables.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_an-object.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_array-includes.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_cof.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_core.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_ctx.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_defined.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_descriptors.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_dom-create.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_enum-bug-keys.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_export.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_fails.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_function-to-string.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_global.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_has.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_hide.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_html.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_ie8-dom-define.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_iobject.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_is-object.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_iter-create.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_iter-define.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_iter-step.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_iterators.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_library.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_object-create.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_object-dp.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_object-dps.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_object-gpo.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_object-keys-internal.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_object-keys.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_property-desc.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_redefine.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_set-to-string-tag.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_shared-key.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_shared.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_to-absolute-index.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_to-integer.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_to-iobject.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_to-length.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_to-object.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_to-primitive.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_uid.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/_wks.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/es6.array.iterator.js","webpack://lib//home/runner/work/hegel/hegel/node_modules/core-js/modules/web.dom.iterable.js","webpack://lib/../src/docs/try/components/hegel.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/checking/index.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/index.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/inference/equals-refinement.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/inference/error-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/inference/function-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/inference/in-operator.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/inference/index.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/inference/instanceof.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/inference/refinement.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/inference/switch-refinement.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/inference/tuple-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/inference/typeof.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/inference/variable-refinement.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/call.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/constants.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/meta/call-meta.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/meta/meta.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/module-scope.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/scope.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/type-graph.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/type-scope.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/bottom-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/class-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/collection-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/entries-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/exclude-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/function-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/generic-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/immutable-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/instance-of-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/intersection-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/keys-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/object-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/omit-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/partial-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/pick-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/property-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/refinemented-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/return-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/soft-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/strict-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/throws-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/tuple-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/type-of-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/type-var.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/union-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/types/values-type.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/variable-info.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/type-graph/variable-scope.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/class-utils.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/common.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/errors.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/function-utils.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/globals.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/hierarchy.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/ignore.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/imports.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/inference-utils.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/nodes.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/operators.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/scope-utils.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/throwable.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/traverse.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/type-utils.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/utility-types.js","webpack://lib//home/runner/work/hegel/hegel/packages/core/build/utils/variable-utils.js"],"names":["Object","value","_errors","require","_errors2","_interopRequireDefault","_type","_typeVar","_callMeta","_typeScope","_tupleType","_unionType","_objectType","_genericType","_moduleScope","_variableInfo","_variableScope","_functionType","_typeUtils","_immutableType","_functionType2","obj","default","actual","Array","items","a","getActualType","call","declaratedRootType","declaratedType","actualRootType","isValidTypes","t","targetName","result","givenArgumentsTypes","targetFunctionType","targetArguments","requiredTargetArguments","errors","length","firstArgumentType","isAssign","i","arg1","arg2","actualType","actualTypeName","String","returnWasCalled","finalWasCalled","scope","checkSingleCall","declaration","isAsync","isFunctionShouldNotCallReturn","returnType","exports","_typeGraph","_typeGraph2","TypeScope","VariableScope","ModuleScope","PositionedModuleScope","Type","VariableInfo","HegelError","createGlobalScope","createModuleScope","_nodes","_nodes2","_collectionType","_common","_inferenceUtils","node","refinementNode","right","left","target","isIdentifierOrProperty","isSimpleLiteral","UNION","strict","isStrict","isSubtypeOf","Number","BigInt","refinementType","refinementedVariants","variant","alternateVariants","variableName","getRefinmentType","variableInfo","currentScope","refinementVariants","refinementedType","alternateType","typeName","chaining","propertyType","newPropertyOwner","destructUnion","currentPropertyName","chainingProperties","isLast","currentPropertyNameIndex","variableType","refinePropertyWithConstraint","property","propertyWith","pickedVariants","nextIndex","nestedRefinement","refinementProperty","isNotAlternateVariant","refinementedTypeAndAlternateType","targetObject","propertiesChaining","targetVariableInfo","refinmentedAndAlternate","refinemented","alternate","isSwitch","currentRefinementNode","args","getEqualsArguments","equalsIdentifier","equalsProperty","tryScope","moduleScope","variants","_meta","_constants","_bottomType","_propertyType","_throwsType","_variableUtils","_call","_scopeUtils","typeVarNames","isValidRestArgumentType","type","localTypeScope","functionScope","isTypeDefinitions","typeGraph","genericArguments","currentNode","typeAnnotation","nameIndex","parent","self","parentScope","argumentsTypes","param","name","typeNode","NULLABLE_TYPE_ANNOTATION","paramType","isWithoutAnnotation","callResultType","newType","typeVar","throwableType","unknownPromise","genericArgumentsTypes","withClean","callTargetType","getRawFunctionType","isArgumentVariable","x","callTarget","getCallTarget","level","oldGenericArguments","roots","callArgument","difference","j","variable","root","arg","shouldSetNewRoot","dropUnknown","appliedArgumentsTypes","unreachableTypes","declaratedArgumentsTypes","fn","maybeBottom","givenArgument","givenArgumentType","declaratedArgument","existed","principal","rootFinder","mainRoot","appliedParameters","resultType","invocationTypeNames","iterator","initializing","argTypes","returnTypeName","newFunctionTypeName","implicitApplyGeneric","genericArgument","clearRoot","calls","subordinateType","throwable","finalReturnWasCalled","nestedScopes","resolveOuterTypeVarsFromCall","arguments","inferenced","newReturnType","returnArgument","newOneRoot","oldRoot","created","genericArg","alreadyCreated","newRoot","isUserDefined","vars","v","newGenericArguments","newArgumentsTypes","shouldBeCleaned","targetType","argument","argumentType","copy","isTypeVarStillExisted","newGenericArgumentsTypes","newFunctionType","targetNode","isSoft","propertyName","refinement","propertyNameNode","inIdentifier","inProperty","isImmutable","objectScope","query","THIS_TYPE","constructor","refinmentedProperty","constructorNode","instanceType","instanceofIdentifier","instanceofProperty","_refinementedType","_inOperator","_equalsRefinement","_typeof","_variableRefinement","_instanceof","primaryScopeName","loc","start","condition","end","primaryScope","alternateScopeName","alternateScope","currentCaseIndex","alternateScopes","$case","getScopesForLogicalExpression","getScopesForConditionalExpression","getScopesForSwitchCase","type1","type2","intersectedVariants","isTypeExisting","unionType","unionVariants","newVariants","binaryExpression","caseRefinement","indexOfCurrentCase","previousCase","previousCaseScope","previousPrimaryRefinement","refinements","refinementByCondition","typeofResult","getRefinementByBinaryExpression","leftSideRefinement","additionalPrimaryScope","additionalAlternateScope","rightSideRefinement","b","sameRefinement","sameRefinementVariants","unionOfTypes","intersectionOfTypes","getPrimaryAndAlternativeScopes","getCondition","currentRefinements","e","varName","cases","hasDefaultCase","switchCase","switchedValue","discriminant","switchedValueType","unmatchedVariants","test","matcherValue","matcherValueType","notMatchedCases","typeofNode","isTypeofOperator","stringNode","isReturnTypeOfTypeof","typeofOperator","isEqualOperator","getTypeofAndLiteral","typeofIdentifier","typeofProperty","falsy","getTruthyVariants","getFalsyVariants","forVariable","forProperty","_keysType","_valuesType","_functionUtils","_inference","_throwable","meta","isFinal","argsLocations","typeScope","withPositions","operator","expression","addCallToTypeGraph","nodeName","varInfo","selfObject","_propertyName","init","$AppliedImmutable","error","nearestFn","nearestThrowableScope","throwableDeclaration","currentTargetType","declarationType","leftArg","isForAssign","argType","fType","isArray","isNotComputed","lts","argsTypes","potentialArgument","isConstructor","defaultObject","callee","elements","raw","fnType","n","defaultArg","expectedType","existedGenericArguments","declaratedThrowable","selfVar","nearestFunctionScope","isLiteral","options","getResult","localInferenced","invoke","invocationType","callMeta","addPropertyToThis","func","isInferencedTypeVar","withoutRoot","isPrivate","currentClassScope","selfType","currentTypeScope","classScope","classVar","classType","methodScope","existedProperty","fnScope","fnName","constructorType","additionalArray","CALLABLE","CONSTRUCTABLE","INDEXABLE","key","enumerable","configurable","writable","argumentsLocations","_defineProperty","ZeroLocation","column","line","_scope","body","addPosition","getVarAtPosition","startEnd","_traverse","_traverse2","rest","definedType","scopeName","parentNode","findVariable","Scope","findRecord","recordInfo","isParentFor","getParentsUntil","parents","getAllChildScopes","children","module","_checking","_checking2","_globals","_globals2","_utilityTypes","_utilityTypes2","_operators","_operators2","_imports","_imports2","_refinement","_ignore","_switchRefinement","_errorType","_hierarchy","_classUtils","hasTypeParams","getAliasBody","addTypeAlias","typeAlias","fillModuleScope","block","existedRecord","functionVariable","tryBlock","handlerScopeKey","middlefillModuleScope","afterFillierActions","classConstructor","isTypeExport","specifiersSource","specifiersTarget","exported","existedVariableOrType","local","newTypeOrVar","errorVariable","resultOfCall","isForInit","invocationResultType","functionName","exportVar","whatWillBeExported","exportedType","file","ast","globalModule","globalErrors","mixTypeDefinitions","createDependencyModuleScope","getModuleFromString","getModuleTypeGraph","modules","Promise","files","priority","makeCustom","findTypeWithName","existedType","newMeta","parameters","res","$BottomType","subordinateMagicType","changeAll","sourceTypes","currentSelf","includedUndefined","includedBottom","includedTypeVar","includedSelfIndex","targetTypes","mapper","argumentIndex","unpack","isPrincipalTypeFor","applyGeneric","p","getDifference","withReverseUnion","subordinate","diff","index","getRootedSubordinateType","unrootSubordinateType","equalsTo","contains","weakContains","makeNominal","getNextParent","sortedParents","isSuperTypeFor","realTarget","keyType","valueType","getPropertyType","anotherType","selfNameWithoutApplying","otherfNameWithoutApplying","CollectionType","newValueType","keyDiff","valueDiff","shouldBeMemoize","isCalledAsBottom","values","picks","whichShouldBeExclude","pick","RestArgument","isType","innerType","otherType","selfValueType","otherValueType","searchingItems","item","genericParams","asyncPart","genericPart","argsPart","params","throwsPart","returnPart","isMultyLine","isRest","throws","typeMeta","FunctionType","Function","isArgumentsChanged","newArguments","newT","newReturn","anotherTypeRequiredArguments","anotherArgument","argumentsDiff","returnDiff","generalize","maybeGenericTypes","types","newFnType","declaratedParent","subordinateParent","match","matchedName","isSplitterPresented","assertParameters","ignoreLength","requiredParams","wrongArgumentIndex","parameter","sourceType","newSubordinateType","newName","GenericType","theMostCloseParent","bottomizeWith","isBottomPresented","appliedType","appliedTypeName","oldAppliedSelf","theMostPriorityParent","appliedSelf","Self","containsAsGeneric","canContain","asUserDefined","asNotUserDefined","readonly","changed","objects","containsVariable","objectTypes","isVar","wrongIndex","newProperties","firstObject","currentTarget","ObjectType","properties","filteredProperties","Boolean","_","fieldOwner","field","isAllProperties","existedAnotherProperty","maybeUnion","anotherProperty","Undefined","isAnyPropertyChanged","vInfo","isInHierarchyOf","requiredProperties","hasTheSameKeysAs","differences","other","callable","pickedProperties","oldProperties","findRealTarget","realProperty","isTargetVariable","isPropertyVariable","props","size","constraint","fieldType","$ThrowsResult","errorType","TupleType","arrayValue","isItemsChanged","newItems","anotherVariants","propertyIndex","unpacked","TypeVar","isDifferenceInDefinition","indexOfNewRootType","defaultType","suptypeParent","stepBeforeNonVariableRoot","potentialRoot","shouldBeUsedAsGeneric","getChangedName","pattern","map","bracket","template","indexOfNewType","save","referenceEqualsTo","isPrincipal","typeWrapper","t2","t1","wrapper","d","getOponentType","withUnpack","withReadonly","setInitialized","promisify","isPromise","endChanges","last","findPrincipal","isPrincipalFound","getWrapperType","isSimpleType","UnionType","isBooleanExist","isFunction","unique","set","currentType","isVariantsChanged","reducer","aggregatedDiff","isConstant","isInferenced","skipCalls","parentTypeScope","isGenericType","isNominal","CLASS_DECLARATION","superClass","superType","superFunctionType","$super","typeInTypeScope","staticName","getClassName","staticSelfObject","staticSelfVar","isConstructorPresented","m","parentConstructor","addition","typeForImplementation","id","addThisToObjectScope","definition","classNode","existedConstructor","constructorScope","superCallIndex","thisCallIndex","getAnonymousKey","getDeclarationName","getKey","filterObject","arr","isEquals","intersectionResult","exclusiveOr","arr1","arr2","unionResult","source","addFunctionScopeToTypeGraph","expected","functionType","inferencedArgumentsTypes","expectedArgumentsTypes","Math","wereArgumentsChanged","expectedArgumentType","inferencedArgumentType","functionTypeName","invocationResult","oldFunctionType","newFunctionArguments","newFunctionGenericArguments","mixBaseGlobals","globalTypes","globals","globalTypeScope","readonlyArrayLocal","arrayLocal","IGNORE_COMMENT","ignored","comments","comment","push","element","specifier","exportsTypes","importSource","importNode","importTarget","importEntries","currentModuleTypeGraph","shouldBeVariable","importName","getImportName","importElement","currentModuleTypeScope","finalImportVariable","importRequests","importCount","currentModuleScope","importedTypeGraphs","importDependencies","_refinementedVariants","_alternateVariants","memberPointer","nestedRefinementedType","originalProperty","nestedAlternateType","DECLARATION_TYPES","VARIABLE_DECLARATOR","VARIABLE_DECLARATION","FUNCTION_DECLARATION","TS_FUNCTION_DECLARATION","TS_CALL_SIGNATURE_DECLARATION","TS_TYPE_QUERY","TYPE_ALIAS","TS_TYPE_ALIAS","TS_DECLARE_METHOD","TS_INTERFACE_DECLARATION","INTERFACE_DECLARATION","TYPE_PARAMETER","TYPE_PARAMETER_DECLARATION","TS_TYPE_PARAMETER_DECLARATION","TS_TYPE_PARAMETER","EXPORT_LIST","EXPORT_SPECIFIER","EXPORT_NAMED_DECLARATION","EXPORT_DEFAULT_DECLARATION","IMPORT_DECLARATION","STATEMENTS_TYPES","PURE_KEY","PURE_VALUE","VALUE","BLOCK_STATEMENT","IF_STATEMENT","WHILE_STATEMENT","DO_WHILE_STATEMENT","FOR_STATEMENT","FOR_IN_STATEMENT","FOR_OF_STATEMENT","EXPRESSION_STATEMENT","RETURN_STATEMENT","EMPTY_STATEMENT","TRY_STATEMENT","THROW_STATEMENT","BREAK_STATEMENT","CONTINUE_STATEMENT","CATCH_CLAUSE","SWITCH_STATEMENT","SWITCH_CASE","INTERPRETER_DIRECTIVE","EXPRESSIONS_TYPES","SUPER","ARRAY_EXPRESSION","TAGGED_TEMPLATE_EXPRESSION","SEQUENCE_EXPRESSION","FUNCTION_EXPRESSION","ARROW_FUNCTION_EXPRESSION","OBJECT_EXPRESSION","CLASS_EXPRESSION","ASSIGNMENT_EXPRESSION","TS_EXPORT_ASSIGNMENT","ASSIGNMENT_PATTERN","BINARY_EXPRESSION","UNARY_EXPRESSION","CONDITIONAL_EXPRESSION","AWAIT_EXPRESSION","LOGICAL_EXPRESSION","CALL_EXPRESSION","MEMBER_EXPRESSION","UPDATE_EXPRESSION","NEW_EXPRESSION","THIS_EXPRESSION","TS_EXPRESSION_WITH_TYPE_ARGUMENTS","REST_ELEMENT","OBJECT_PROPERTIES","OBJECT_METHOD","TS_OBJECT_METHOD","OBJECT_PROPERTY","TS_OBJECT_PROPERTY","TS_INDEX_PROPERTY","TS_CONSTRUCT_SIGNATURE_DECLARATION","CLASS_PROPERTIES","CLASS_METHOD","CLASS_PRIVATE_METHOD","CLASS_PROPERTY","CLASS_PRIVATE_PROPERTY","PRIVATE_NAME","LITERAL_TYPES","NUMERIC_LITERAL","BIGINT_LITERAL","STRING_LITERAL","BOOLEAN_LITERAL","NULL_LITERAL","REG_EXP_LITERAL","TS_LITERAL_TYPE","TEMPLATE_LITERAL","ANNOTATION_TYPES","FUNCTION_TYPE_ANNOTATION","CLASS_IMPLEMENTS","ANY_TYPE_ANNOTATION","VOID_TYPE_ANNOTATION","BOOLEAN_TYPE_ANNOTATION","MIXED_TYPE_ANNOTATION","EMPTY_TYPE_ANNOTATION","NUMBER_TYPE_ANNOTATION","STRING_TYPE_ANNOTATION","NULL_LITERAL_TYPE_ANNOTATION","GENERIC_TYPE_ANNOTATION","NUMBER_LITERAL_TYPE_ANNOTATION","BOOLEAN_LITERAL_TYPE_ANNOTATION","STRING_LITERAL_TYPE_ANNOTATION","OBJECT_TYPE_ANNOTATION","OBJECT_TYPE_PROPERTY","OBJECT_TYPE_SPREAD_PROPERTY","UNION_TYPE_ANNOTATION","TUPLE_TYPE_ANNOTATION","BIGINT_LITERAL_TYPE_ANNOTATION","TS_PARENTHESIZED_TYPE","TS_FUNCTION_TYPE_ANNOTATION","TS_ANY_TYPE_ANNOTATION","SYMBOL_TYPE_ANNOTATION","TS_SYMBOL_TYPE_ANNOTATION","TS_VOID_TYPE_ANNOTATION","TS_BOOLEAN_TYPE_ANNOTATION","TS_UNKNOWN_TYPE_ANNOTATION","TS_NEVER_TYPE_ANNOTATION","TS_NUMBER_TYPE_ANNOTATION","TS_BIGINT_TYPE_ANNOTATION","TS_STRING_TYPE_ANNOTATION","TS_NULL_LITERAL_TYPE_ANNOTATION","TS_OBJECT_KEYWORD","TS_TYPE_OPERATOR","TS_GENERIC_TYPE_ANNOTATION","TS_OBJECT_TYPE_ANNOTATION","TS_UNION_TYPE_ANNOTATION","TS_TUPLE_TYPE_ANNOTATION","TS_TYPE_ANNOTATION","TS_TYPE_REFERENCE_ANNOTATION","THIS_TYPE_ANNOTATION","TS_THIS_TYPE_ANNOTATION","TS_UNDEFINED_TYPE_ANNOTATION","TS_ARRAY_TYPE_ANNOTATION","ARRAY_TYPE_ANNOTATION","TS_INTERSECTION_TYPE","TYPEOF_TYPE_ANNOTATION","TYPE_CAST","TYPE_GUARD","INITIALIZATION_TYPES","IDENTIFIER","PROGRAM","DECLARATION_KINDS","VAR","CONST","LET","SPECIFIERS_TYPES","IMPORT_DEFAULT_SPECIFIER","IMPORT_NAMESPACE_SPECIFIER","IMPORT_SPECIFIER","SPECIAL_TYPES","THIS_TYPE_DEFINITION","isUnscopableDeclaration","kind","isObject","isScopeCreator","isImport","zeroMetaLocation","genericFunction","getGenericArguments","parametersTypes","getTypeParameters","getReturnType","mixBaseOperators","operators","l","findNearestScopeByType","getScopeType","getParentForNode","getScopeFromNode","getScopeCreator","creator","throwableScope","findThrowableBlock","compose","additionalArgs","fns","of","getInitFor","isCustom","exportKind","specifiers","exportAs","declarations","catchBlock","handler","inferencedBody","alternateBody","previousBodyState","indexOfSlice","inferencedAlternate","removeNodesWhichConteindInElse","getBody","getCurrentNode","shouldContinueTraversing","pre","nextParent","middle","traverseTree","post","_intersectionType","reachableType","annotation","rewritable","elementType","getTypeFromTypeAnnotation","literal","nullable","tupleVariants","addTypeVar","objectBody","superTypes","isNotTypeDefinition","spreadType","getPropertyName","customName","resultObj","getPropertiesForType","getResultObjectType","typeParameters","exprName","genericId","genericName","typeInScope","existedGenericType","applicationResultType","argNodes","paramsNode","returnTypeNode","obj1","obj2","indexable","object","isFalsy","getFalsy","_pickType","_omitType","_softType","_classType","_strictType","_typeOfType","_entriesType","_excludeType","_partialType","_returnType","_instanceOfType","mixUtilityTypes","utilityTypes","annotatedType","withUnion","getSuperTypeOf","propertyTypes","freezed","getVariableInfoFromDelcaration"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;;AAEb,8CAA8C,cAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,GAAG;AACH,6BAA6B;AAC7B;AACA;AACA,GAAG;AACH,+BAA+B;AAC/B;AACA;AACA,GAAG;AACH,0BAA0B;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,wBAAwB;AACxB;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,iCAAiC;AACjC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,uCAAuC;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,uCAAuC;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kLAAkL;AAClL,gGAAgG,MAAM;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF,mFAAmF;AACnF,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,SAAS,QAAQ,EAAE;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,4DAA4D,2EAA2E,yDAAyD,uEAAuE;AACvQ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iFAAiF,SAAS,GAAG,WAAW;AACxG;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC,oCAAoC;AACpC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iEAAiE;AACjE;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,sBAAsB,gCAAgC;AACtD;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,+EAA+E,oCAAoC;AACnH;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,WAAW;AACX,gFAAgF,qCAAqC;AACrH;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,EAAE;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qIAAqI,EAAE;AACvI;;AAEA;AACA,gJAAgJ,EAAE;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,0BAA0B;AACxF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,YAAY;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,OAAO;AAC5D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,oBAAoB;AACzE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,oEAAoE,KAAK;AAChF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,wFAAwF,iBAAiB;AAChH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,YAAY;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2EAA2E,YAAY;AACvF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,UAAU;;AAEpC;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6DAA6D,+BAA+B;AAC5F;AACA,gEAAgE;AAChE;AACA;;AAEA;;AAEA;AACA,yDAAyD,6BAA6B;AACtF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iFAAiF,cAAc;AAC/F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6EAA6E,yBAAyB;AACtG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,8BAA8B;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,iCAAiC;AAC9F;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C,QAAQ;AACtD;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,6DAA6D,+BAA+B;AAC5F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,kFAAkF,oCAAoC;AACtH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,2DAA2D,+BAA+B;AAC1F;AACA;AACA;AACA,KAAK;AACL,uDAAuD,6BAA6B;AACpF;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mFAAmF,yBAAyB;AAC5G;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,0BAA0B;AACzE;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA,wEAAwE;AACxE,+DAA+D;AAC/D;;AAEA;AACA;;AAEA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACj+YA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA,kBAAkB,mBAAO,CAAC,6DAAQ;AAClC;AACA,0CAA0C,mBAAO,CAAC,+DAAS,6BAA6B;AACxF;AACA;AACA;;;;;;;;;;;;ACNA,eAAe,mBAAO,CAAC,yEAAc;AACrC;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA,gBAAgB,mBAAO,CAAC,2EAAe;AACvC,eAAe,mBAAO,C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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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","file":"544be7e25348e34fe5d1.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"../../../node_modules/workerize-loader/dist/rpc-worker-loader.js!../../../node_modules/gatsby/dist/utils/babel-loader.js?!../../../node_modules/gatsby/dist/utils/babel-loader.js?!../src/docs/try/components/hegel.js\");\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass TokenType {\n  constructor(label, conf = {}) {\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    this.updateContext = null;\n  }\n\n}\nconst keywords = new Map();\n\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = new TokenType(name, options);\n  keywords.set(name, token);\n  return token;\n}\n\nfunction createBinop(name, binop) {\n  return new TokenType(name, {\n    beforeExpr,\n    binop\n  });\n}\n\nconst types = {\n  num: new TokenType(\"num\", {\n    startsExpr\n  }),\n  bigint: new TokenType(\"bigint\", {\n    startsExpr\n  }),\n  regexp: new TokenType(\"regexp\", {\n    startsExpr\n  }),\n  string: new TokenType(\"string\", {\n    startsExpr\n  }),\n  name: new TokenType(\"name\", {\n    startsExpr\n  }),\n  eof: new TokenType(\"eof\"),\n  bracketL: new TokenType(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: new TokenType(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: new TokenType(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: new TokenType(\"]\"),\n  bracketBarR: new TokenType(\"|]\"),\n  braceL: new TokenType(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: new TokenType(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: new TokenType(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", {\n    beforeExpr\n  }),\n  semi: new TokenType(\";\", {\n    beforeExpr\n  }),\n  colon: new TokenType(\":\", {\n    beforeExpr\n  }),\n  doubleColon: new TokenType(\"::\", {\n    beforeExpr\n  }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", {\n    beforeExpr\n  }),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", {\n    beforeExpr\n  }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", {\n    beforeExpr\n  }),\n  backQuote: new TokenType(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: new TokenType(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: new TokenType(\"@\"),\n  hash: new TokenType(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: new TokenType(\"#!...\"),\n  eq: new TokenType(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: new TokenType(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: new TokenType(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: new TokenType(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: new TokenType(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: new TokenType(\"%\", {\n    beforeExpr,\n    binop: 10,\n    startsExpr\n  }),\n  star: createBinop(\"*\", 10),\n  slash: createBinop(\"/\", 10),\n  exponent: new TokenType(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  })\n};\n\nconst SCOPE_OTHER = 0b00000000,\n      SCOPE_PROGRAM = 0b00000001,\n      SCOPE_FUNCTION = 0b00000010,\n      SCOPE_ARROW = 0b00000100,\n      SCOPE_SIMPLE_CATCH = 0b00001000,\n      SCOPE_SUPER = 0b00010000,\n      SCOPE_DIRECT_SUPER = 0b00100000,\n      SCOPE_CLASS = 0b01000000,\n      SCOPE_TS_MODULE = 0b10000000,\n      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\nconst BIND_KIND_VALUE = 0b00000000001,\n      BIND_KIND_TYPE = 0b00000000010,\n      BIND_SCOPE_VAR = 0b00000000100,\n      BIND_SCOPE_LEXICAL = 0b00000001000,\n      BIND_SCOPE_FUNCTION = 0b00000010000,\n      BIND_FLAGS_NONE = 0b00001000000,\n      BIND_FLAGS_CLASS = 0b00010000000,\n      BIND_FLAGS_TS_ENUM = 0b00100000000,\n      BIND_FLAGS_TS_CONST_ENUM = 0b01000000000,\n      BIND_FLAGS_TS_EXPORT_ONLY = 0b10000000000;\nconst BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,\n      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,\n      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,\n      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,\n      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,\n      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,\n      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,\n      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;\nconst CLASS_ELEMENT_FLAG_STATIC = 0b100,\n      CLASS_ELEMENT_KIND_GETTER = 0b010,\n      CLASS_ELEMENT_KIND_SETTER = 0b001,\n      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\nconst CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n      CLASS_ELEMENT_OTHER = 0;\n\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass Position {\n  constructor(line, col) {\n    this.line = line;\n    this.column = col;\n  }\n\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n}\nfunction getLineInfo(input, offset) {\n  let line = 1;\n  let lineStart = 0;\n  let match;\n  lineBreakG.lastIndex = 0;\n\n  while ((match = lineBreakG.exec(input)) && match.index < offset) {\n    line++;\n    lineStart = lineBreakG.lastIndex;\n  }\n\n  return new Position(line, offset - lineStart);\n}\n\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n\n  hasPlugin(name) {\n    return this.plugins.has(name);\n  }\n\n  getPluginOption(plugin, name) {\n    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];\n  }\n\n}\n\nfunction last(stack) {\n  return stack[stack.length - 1];\n}\n\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.trailingComments.push(comment);\n    this.state.leadingComments.push(comment);\n  }\n\n  adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {\n    if (this.state.leadingComments.length === 0) {\n      return;\n    }\n\n    let lastElement = null;\n    let i = elements.length;\n\n    while (lastElement === null && i > 0) {\n      lastElement = elements[--i];\n    }\n\n    if (lastElement === null) {\n      return;\n    }\n\n    for (let j = 0; j < this.state.leadingComments.length; j++) {\n      if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n        this.state.leadingComments.splice(j, 1);\n        j--;\n      }\n    }\n\n    const newTrailingComments = [];\n\n    for (let i = 0; i < this.state.leadingComments.length; i++) {\n      const leadingComment = this.state.leadingComments[i];\n\n      if (leadingComment.end < node.end) {\n        newTrailingComments.push(leadingComment);\n\n        if (!takeAllComments) {\n          this.state.leadingComments.splice(i, 1);\n          i--;\n        }\n      } else {\n        if (node.trailingComments === undefined) {\n          node.trailingComments = [];\n        }\n\n        node.trailingComments.push(leadingComment);\n      }\n    }\n\n    if (takeAllComments) this.state.leadingComments = [];\n\n    if (newTrailingComments.length > 0) {\n      lastElement.trailingComments = newTrailingComments;\n    } else if (lastElement.trailingComments !== undefined) {\n      lastElement.trailingComments = [];\n    }\n  }\n\n  processComment(node) {\n    if (node.type === \"Program\" && node.body.length > 0) return;\n    const stack = this.state.commentStack;\n    let firstChild, lastChild, trailingComments, i, j;\n\n    if (this.state.trailingComments.length > 0) {\n      if (this.state.trailingComments[0].start >= node.end) {\n        trailingComments = this.state.trailingComments;\n        this.state.trailingComments = [];\n      } else {\n        this.state.trailingComments.length = 0;\n      }\n    } else if (stack.length > 0) {\n      const lastInStack = last(stack);\n\n      if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {\n        trailingComments = lastInStack.trailingComments;\n        delete lastInStack.trailingComments;\n      }\n    }\n\n    if (stack.length > 0 && last(stack).start >= node.start) {\n      firstChild = stack.pop();\n    }\n\n    while (stack.length > 0 && last(stack).start >= node.start) {\n      lastChild = stack.pop();\n    }\n\n    if (!lastChild && firstChild) lastChild = firstChild;\n\n    if (firstChild) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties);\n          break;\n\n        case \"ObjectPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties, true);\n          break;\n\n        case \"CallExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.arguments);\n          break;\n\n        case \"ArrayExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements);\n          break;\n\n        case \"ArrayPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements, true);\n          break;\n      }\n    } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === \"ImportSpecifier\" && node.type !== \"ImportSpecifier\" || this.state.commentPreviousNode.type === \"ExportSpecifier\" && node.type !== \"ExportSpecifier\")) {\n      this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);\n    }\n\n    if (lastChild) {\n      if (lastChild.leadingComments) {\n        if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {\n          node.leadingComments = lastChild.leadingComments;\n          delete lastChild.leadingComments;\n        } else {\n          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\n            if (lastChild.leadingComments[i].end <= node.start) {\n              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\n              break;\n            }\n          }\n        }\n      }\n    } else if (this.state.leadingComments.length > 0) {\n      if (last(this.state.leadingComments).end <= node.start) {\n        if (this.state.commentPreviousNode) {\n          for (j = 0; j < this.state.leadingComments.length; j++) {\n            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n              this.state.leadingComments.splice(j, 1);\n              j--;\n            }\n          }\n        }\n\n        if (this.state.leadingComments.length > 0) {\n          node.leadingComments = this.state.leadingComments;\n          this.state.leadingComments = [];\n        }\n      } else {\n        for (i = 0; i < this.state.leadingComments.length; i++) {\n          if (this.state.leadingComments[i].end > node.start) {\n            break;\n          }\n        }\n\n        const leadingComments = this.state.leadingComments.slice(0, i);\n\n        if (leadingComments.length) {\n          node.leadingComments = leadingComments;\n        }\n\n        trailingComments = this.state.leadingComments.slice(i);\n\n        if (trailingComments.length === 0) {\n          trailingComments = null;\n        }\n      }\n    }\n\n    this.state.commentPreviousNode = node;\n\n    if (trailingComments) {\n      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {\n        node.innerComments = trailingComments;\n      } else {\n        node.trailingComments = trailingComments;\n      }\n    }\n\n    stack.push(node);\n  }\n\n}\n\nconst Errors = Object.freeze({\n  ArgumentsDisallowedInInitializer: \"'arguments' is not allowed in class field initializer\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function\",\n  AwaitExpressionFormalParameter: \"await is not allowed in async function parameters\",\n  AwaitNotInAsyncFunction: \"Can not use keyword 'await' outside an async function\",\n  BadGetterArity: \"getter must not have any formal parameters\",\n  BadSetterArity: \"setter must have exactly one formal parameter\",\n  BadSetterRestParameter: \"setter function argument must not be a rest parameter\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor\",\n  ConstructorIsAsync: \"Constructor can't be an async function\",\n  ConstructorIsGenerator: \"Constructor can't be a generator\",\n  DeclarationMissingInitializer: \"%0 require an initialization value\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon\",\n  DeletePrivateField: \"Deleting a private field is not allowed\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: \"`%0` has already been exported. Exported identifiers must be unique.\",\n  DuplicateProto: \"Redefinition of __proto__ property\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag\",\n  ElementAfterRest: \"Rest element must be last element\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape\",\n  ForInOfLoopInitializer: \"%0 loop variable declaration may not have an initializer\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block\",\n  IllegalBreakContinue: \"Unsyntactic %0\",\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list\",\n  IllegalReturn: \"'return' outside of function\",\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments\",\n  ImportCallArity: \"import() requires exactly one argument\",\n  ImportCallArityLtOne: \"Dynamic imports require a parameter: import('a.js')\",\n  ImportCallNotNewExpression: \"Cannot use new with import(...)\",\n  ImportCallSpreadArgument: \"... is not allowed in import()\",\n  ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: \"module\"'`,\n  ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n  InvalidCodePoint: \"Code point out of bounds\",\n  InvalidDigit: \"Expected number in radix %0\",\n  InvalidEscapeSequence: \"Bad character escape sequence\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template\",\n  InvalidEscapedReservedWord: \"Escape sequence in keyword %0\",\n  InvalidIdentifier: \"Invalid identifier %0\",\n  InvalidLhs: \"Invalid left-hand side in %0\",\n  InvalidLhsBinding: \"Binding invalid left-hand side in %0\",\n  InvalidNumber: \"Invalid number\",\n  InvalidOrUnexpectedToken: \"Unexpected character '%0'\",\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern\",\n  InvalidPrivateFieldResolution: \"Private name #%0 is not defined\",\n  InvalidPropertyBindingPattern: \"Binding member expression\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument\",\n  LabelRedeclaration: \"Label '%0' is already declared\",\n  LetInLexicalBinding: \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag\",\n  MissingClassName: \"A class name is required\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators\",\n  ModuleExportUndefined: \"Export '%0' is not defined\",\n  MultipleDefaultsInSwitch: \"Multiple default clauses\",\n  NewlineAfterThrow: \"Illegal newline after throw\",\n  NoCatchOrFinally: \"Missing catch or finally clause\",\n  NumberIdentifier: \"Identifier directly after number\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences\",\n  ObsoleteAwaitStar: \"await* has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"constructors in/after an Optional Chain are not allowed\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain\",\n  ParamDupe: \"Argument name clash\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter\",\n  PatternHasMethod: \"Object pattern can't contain methods\",\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding\",\n  PrimaryTopicRequiresSmartPipeline: \"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\",\n  PrivateNameRedeclaration: \"Duplicate private name #%0\",\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement\",\n  StaticPrototype: \"Classes may not have static property named prototype\",\n  StrictDelete: \"Deleting local variable in strict mode\",\n  StrictEvalArguments: \"Assigning to '%0' in strict mode\",\n  StrictEvalArgumentsBinding: \"Binding '%0' in strict mode\",\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode\",\n  StrictWith: \"'with' in strict mode\",\n  SuperNotAllowed: \"super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super\",\n  TrailingDecorator: \"Decorators must be attached to a class element\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level\",\n  UnexpectedKeyword: \"Unexpected keyword '%0'\",\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context\",\n  UnexpectedNewTarget: \"new.target can only be used in functions\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits\",\n  UnexpectedPrivateField: \"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\\n or a property of member expression (i.e. this.#p).\",\n  UnexpectedReservedWord: \"Unexpected reserved word '%0'\",\n  UnexpectedSuper: \"super is only allowed in object methods and classes\",\n  UnexpectedToken: \"Unexpected token '%'\",\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"import can only be used in import() or import.meta\",\n  UnsupportedMetaProperty: \"The only valid meta property for %0 is %0.%1\",\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties\",\n  UnsupportedSuper: \"super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])\",\n  UnterminatedComment: \"Unterminated comment\",\n  UnterminatedRegExp: \"Unterminated regular expression\",\n  UnterminatedString: \"Unterminated string constant\",\n  UnterminatedTemplate: \"Unterminated template\",\n  VarRedeclaration: \"Identifier '%0' has already been declared\",\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator\",\n  YieldInParameter: \"yield is not allowed in generator parameters\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0\"\n});\nclass LocationParser extends CommentsParser {\n  getLocationForPosition(pos) {\n    let loc;\n    if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);\n    return loc;\n  }\n\n  raise(pos, errorTemplate, ...params) {\n    return this.raiseWithData(pos, undefined, errorTemplate, ...params);\n  }\n\n  raiseWithData(pos, data, errorTemplate, ...params) {\n    const loc = this.getLocationForPosition(pos);\n    const message = errorTemplate.replace(/%(\\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;\n    return this._raise(Object.assign({\n      loc,\n      pos\n    }, data), message);\n  }\n\n  _raise(errorContext, message) {\n    const err = new SyntaxError(message);\n    Object.assign(err, errorContext);\n\n    if (this.options.errorRecovery) {\n      if (!this.isLookahead) this.state.errors.push(err);\n      return err;\n    } else {\n      throw err;\n    }\n  }\n\n}\n\nfunction isSimpleProperty(node) {\n  return node != null && node.type === \"Property\" && node.kind === \"init\" && node.method === false;\n}\n\nvar estree = (superClass => class extends superClass {\n  estreeParseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {}\n\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n\n  estreeParseBigIntLiteral(value) {\n    const bigInt = typeof BigInt !== \"undefined\" ? BigInt(value) : null;\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n\n  directiveToStmt(directive) {\n    const directiveLiteral = directive.value;\n    const stmt = this.startNodeAt(directive.start, directive.loc.start);\n    const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n    expression.value = directiveLiteral.value;\n    expression.raw = directiveLiteral.extra.raw;\n    stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.end, directiveLiteral.loc.end);\n    stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n    return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.end, directive.loc.end);\n  }\n\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n\n  checkDeclaration(node) {\n    if (isSimpleProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n\n  checkGetterSetterParams(method) {\n    const prop = method;\n    const paramCount = prop.kind === \"get\" ? 0 : 1;\n    const start = prop.start;\n\n    if (prop.value.params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, Errors.BadGetterArity);\n      } else {\n        this.raise(start, Errors.BadSetterArity);\n      }\n    } else if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n      this.raise(start, Errors.BadSetterRestParameter);\n    }\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription, disallowLetBinding) {\n    switch (expr.type) {\n      case \"ObjectPattern\":\n        expr.properties.forEach(prop => {\n          this.checkLVal(prop.type === \"Property\" ? prop.value : prop, bindingType, checkClashes, \"object destructuring pattern\", disallowLetBinding);\n        });\n        break;\n\n      default:\n        super.checkLVal(expr, bindingType, checkClashes, contextDescription, disallowLetBinding);\n    }\n  }\n\n  checkDuplicatedProto(prop, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || prop.computed || prop.method || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n    if (name === \"__proto__\" && prop.kind === \"init\") {\n      if (protoRef.used) {\n        if (refExpressionErrors && refExpressionErrors.doubleProto === -1) {\n          refExpressionErrors.doubleProto = key.start;\n        } else {\n          this.raise(key.start, Errors.DuplicateProto);\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);\n  }\n\n  stmtToDirective(stmt) {\n    const directive = super.stmtToDirective(stmt);\n    const value = stmt.expression.value;\n    directive.value.value = value;\n    return directive;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n\n    classBody.body.push(method);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    switch (this.state.type) {\n      case types.num:\n      case types.string:\n        return this.estreeParseLiteral(this.state.value);\n\n      case types.regexp:\n        return this.estreeParseRegExpLiteral(this.state.value);\n\n      case types.bigint:\n        return this.estreeParseBigIntLiteral(this.state.value);\n\n      case types._null:\n        return this.estreeParseLiteral(null);\n\n      case types._true:\n        return this.estreeParseLiteral(true);\n\n      case types._false:\n        return this.estreeParseLiteral(false);\n\n      default:\n        return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    const node = super.parseLiteral(value, type, startPos, startLoc);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    type = type === \"ClassMethod\" ? \"MethodDefinition\" : type;\n    return this.finishNode(node, type);\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc);\n\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") node.kind = \"init\";\n      node.shorthand = false;\n    }\n\n    return node;\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n\n    return node;\n  }\n\n  toAssignable(node) {\n    if (isSimpleProperty(node)) {\n      this.toAssignable(node.value);\n      return node;\n    }\n\n    return super.toAssignable(node);\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      throw this.raise(prop.key.start, Errors.PatternHasAccessor);\n    } else if (prop.method) {\n      throw this.raise(prop.key.start, Errors.PatternHasMethod);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast);\n    }\n  }\n\n  finishCallExpression(node, optional) {\n    super.finishCallExpression(node, optional);\n\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      delete node.arguments;\n      delete node.callee;\n    }\n\n    return node;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    if (!exprList) {\n      return;\n    }\n\n    super.toReferencedListDeep(exprList, isParenthesizedExpr);\n  }\n\n  parseExport(node) {\n    super.parseExport(node);\n\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n\n        break;\n    }\n\n    return node;\n  }\n\n});\n\nclass TokContext {\n  constructor(token, isExpr, preserveSpace, override) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n  }\n\n}\nconst types$1 = {\n  braceStatement: new TokContext(\"{\", false),\n  braceExpression: new TokContext(\"{\", true),\n  templateQuasi: new TokContext(\"${\", false),\n  parenStatement: new TokContext(\"(\", false),\n  parenExpression: new TokContext(\"(\", true),\n  template: new TokContext(\"`\", true, true, p => p.readTmplToken()),\n  functionExpression: new TokContext(\"function\", true),\n  functionStatement: new TokContext(\"function\", false)\n};\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.state.context.length === 1) {\n    this.state.exprAllowed = true;\n    return;\n  }\n\n  let out = this.state.context.pop();\n\n  if (out === types$1.braceStatement && this.curContext().token === \"function\") {\n    out = this.state.context.pop();\n  }\n\n  this.state.exprAllowed = !out.isExpr;\n};\n\ntypes.name.updateContext = function (prevType) {\n  let allowed = false;\n\n  if (prevType !== types.dot) {\n    if (this.state.value === \"of\" && !this.state.exprAllowed && prevType !== types._function && prevType !== types._class || this.state.value === \"yield\" && this.prodParam.hasYield) {\n      allowed = true;\n    }\n  }\n\n  this.state.exprAllowed = allowed;\n\n  if (this.state.isIterator) {\n    this.state.isIterator = false;\n  }\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.state.context.push(types$1.templateQuasi);\n  this.state.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  const statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {};\n\ntypes._function.updateContext = types._class.updateContext = function (prevType) {\n  if (prevType === types.dot || prevType === types.questionDot) ; else if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {\n    this.state.context.push(types$1.functionExpression);\n  } else {\n    this.state.context.push(types$1.functionStatement);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.template) {\n    this.state.context.pop();\n  } else {\n    this.state.context.push(types$1.template);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.star.updateContext = function () {\n  this.state.exprAllowed = false;\n};\n\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords$1 = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords$1.has(word);\n}\n\nconst keywordRelationalOperator = /^in(stanceof)?$/;\nfunction isIteratorStart(current, next) {\n  return current === 64 && next === 64;\n}\n\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = Object.freeze({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\",\n  AssignReservedType: \"Cannot overwrite reserved type %0\",\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement\",\n  EnumBooleanMemberNotInitialized: \"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.\",\n  EnumDuplicateMemberName: \"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.\",\n  EnumInconsistentMemberValues: \"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.\",\n  EnumInvalidExplicitType: \"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidExplicitTypeUnknownSupplied: \"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidMemberInitializerPrimaryType: \"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.\",\n  EnumInvalidMemberInitializerSymbolType: \"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.\",\n  EnumInvalidMemberInitializerUnknownType: \"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.\",\n  EnumInvalidMemberName: \"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.\",\n  EnumNumberMemberNotInitialized: \"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.\",\n  EnumStringMemberInconsistentlyInitailized: \"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment\",\n  OptionalBindingPattern: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  SpreadVariance: \"Spread properties cannot have variance\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object\",\n  UnexpectedReservedType: \"Unexpected reserved type %0\",\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\"',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration\",\n  UnsupportedDeclareExportKind: \"`declare export %0` is not supported. Use `%1` instead\",\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module\",\n  UnterminatedFlowComment: \"Unterminated flow-comment\"\n});\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\n\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(state) {\n  return (state.type === types.name || !!state.type.keyword) && state.value !== \"from\";\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\n\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = (superClass => class extends superClass {\n  constructor(options, input) {\n    super(options, input);\n    this.flowPragma = undefined;\n  }\n\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n\n  shouldParseEnums() {\n    return !!this.getPluginOption(\"flow\", \"enums\");\n  }\n\n  finishToken(type, val) {\n    if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n\n    return super.finishToken(type, val);\n  }\n\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n\n      if (!matches) ; else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n\n    return super.addComment(comment);\n  }\n\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || types.colon);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    const moduloPos = this.state.start;\n    this.expect(types.modulo);\n    const checksLoc = this.state.startLoc;\n    this.expectContextual(\"checks\");\n\n    if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {\n      this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);\n    }\n\n    if (this.eat(types.parenL)) {\n      node.value = this.parseExpression();\n      this.expect(types.parenR);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(types.colon);\n    let type = null;\n    let predicate = null;\n\n    if (this.match(types.modulo)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n\n      if (this.match(types.modulo)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n\n    return [type, predicate];\n  }\n\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n\n    if (this.isRelational(\"<\")) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n\n    this.expect(types.parenL);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    this.expect(types.parenR);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n\n  flowParseDeclare(node, insideModule) {\n    if (this.match(types._class)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(types._function)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(types._var)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(\"module\")) {\n      if (this.match(types.dot)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);\n        }\n\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(\"type\")) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(\"opaque\")) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(\"interface\")) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(types._export)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      throw this.unexpected();\n    }\n  }\n\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, BIND_VAR, node.id.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n\n  flowParseDeclareModule(node) {\n    this.scope.enter(SCOPE_OTHER);\n\n    if (this.match(types.string)) {\n      node.id = this.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(types.braceL);\n\n    while (!this.match(types.braceR)) {\n      let bodyNode = this.startNode();\n\n      if (this.match(types._import)) {\n        this.next();\n\n        if (!this.isContextual(\"type\") && !this.match(types._typeof)) {\n          this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);\n        }\n\n        this.parseImport(bodyNode);\n      } else {\n        this.expectContextual(\"declare\", FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n\n      body.push(bodyNode);\n    }\n\n    this.scope.exit();\n    this.expect(types.braceR);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n        }\n\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);\n        }\n\n        if (kind === \"ES\") {\n          this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n        }\n\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(types._export);\n\n    if (this.eat(types._default)) {\n      if (this.match(types._function) || this.match(types._class)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(types._const) || this.isLet() || (this.isContextual(\"type\") || this.isContextual(\"interface\")) && !insideModule) {\n        const label = this.state.value;\n        const suggestion = exportSuggestions[label];\n        throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);\n      }\n\n      if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual(\"opaque\")) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n          node.default = false;\n          return this.finishNode(node, \"DeclareExportDeclaration\");\n        } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual(\"interface\") || this.isContextual(\"type\") || this.isContextual(\"opaque\")) {\n          node = this.parseExport(node);\n\n          if (node.type === \"ExportNamedDeclaration\") {\n            node.type = \"ExportDeclaration\";\n            node.default = false;\n            delete node.exportKind;\n          }\n\n          node.type = \"Declare\" + node.type;\n          return node;\n        }\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(\"exports\");\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    this.flowParseTypeAlias(node);\n    node.type = \"DeclareTypeAlias\";\n    return node;\n  }\n\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    this.flowParseOpaqueType(node, true);\n    node.type = \"DeclareOpaqueType\";\n    return node;\n  }\n\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n\n  flowParseInterfaceish(node, isClass = false) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.extends = [];\n    node.implements = [];\n    node.mixins = [];\n\n    if (this.eat(types._extends)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(types.comma));\n    }\n\n    if (this.isContextual(\"mixins\")) {\n      this.next();\n\n      do {\n        node.mixins.push(this.flowParseInterfaceExtends());\n      } while (this.eat(types.comma));\n    }\n\n    if (this.isContextual(\"implements\")) {\n      this.next();\n\n      do {\n        node.implements.push(this.flowParseInterfaceExtends());\n      } while (this.eat(types.comma));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);\n    }\n  }\n\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);\n  }\n\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.start, declaration);\n    return this.parseIdentifier(liberal);\n  }\n\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.right = this.flowParseTypeInitialiser(types.eq);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(\"type\");\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.supertype = null;\n\n    if (this.match(types.colon)) {\n      node.supertype = this.flowParseTypeInitialiser(types.colon);\n    }\n\n    node.impltype = null;\n\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(types.eq);\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStart = this.state.start;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n\n    if (this.match(types.eq)) {\n      this.eat(types.eq);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);\n      }\n    }\n\n    return this.finishNode(node, \"TypeParameter\");\n  }\n\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n\n    if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    let defaultRequired = false;\n\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n\n      if (!this.isRelational(\">\")) {\n        this.expect(types.comma);\n      }\n    } while (!this.isRelational(\">\"));\n\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expectRelational(\"<\");\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n\n    while (!this.isRelational(\">\")) {\n      node.params.push(this.flowParseType());\n\n      if (!this.isRelational(\">\")) {\n        this.expect(types.comma);\n      }\n    }\n\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expectRelational(\"<\");\n\n    while (!this.isRelational(\">\")) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n\n      if (!this.isRelational(\">\")) {\n        this.expect(types.comma);\n      }\n    }\n\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(\"interface\");\n    node.extends = [];\n\n    if (this.eat(types._extends)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(types.comma));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n\n  flowParseObjectPropertyKey() {\n    return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n  }\n\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n\n    if (this.lookahead().type === types.colon) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n\n    this.expect(types.bracketR);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(types.bracketR);\n    this.expect(types.bracketR);\n\n    if (this.isRelational(\"<\") || this.match(types.parenL)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n    } else {\n      node.method = false;\n\n      if (this.eat(types.question)) {\n        node.optional = true;\n      }\n\n      node.value = this.flowParseTypeInitialiser();\n    }\n\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    this.expect(types.parenL);\n\n    while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n      node.params.push(this.flowParseFunctionTypeParam());\n\n      if (!this.match(types.parenR)) {\n        this.expect(types.comma);\n      }\n    }\n\n    if (this.eat(types.ellipsis)) {\n      node.rest = this.flowParseFunctionTypeParam();\n    }\n\n    this.expect(types.parenR);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n\n    if (allowExact && this.match(types.braceBarL)) {\n      this.expect(types.braceBarL);\n      endDelim = types.braceBarR;\n      exact = true;\n    } else {\n      this.expect(types.braceL);\n      endDelim = types.braceR;\n      exact = false;\n    }\n\n    nodeStart.exact = exact;\n\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStart = null;\n      let inexactStart = null;\n      const node = this.startNode();\n\n      if (allowProto && this.isContextual(\"proto\")) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n          this.next();\n          protoStart = this.state.start;\n          allowStatic = false;\n        }\n      }\n\n      if (allowStatic && this.isContextual(\"static\")) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n          this.next();\n          isStatic = true;\n        }\n      }\n\n      const variance = this.flowParseVariance();\n\n      if (this.eat(types.bracketL)) {\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (this.eat(types.bracketL)) {\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(types.parenL) || this.isRelational(\"<\")) {\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (variance) {\n          this.unexpected(variance.start);\n        }\n\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n\n        if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type === types.name || lookahead.type === types.string || lookahead.type === types.num) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStart = this.state.lastTokStart;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n\n      this.flowObjectTypeSemicolon();\n\n      if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n        this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);\n      }\n    }\n\n    this.expect(endDelim);\n\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n\n  flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(types.ellipsis)) {\n      const isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);\n\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);\n        } else if (!allowInexact) {\n          this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);\n        }\n\n        if (variance) {\n          this.raise(variance.start, FlowErrors.InexactVariance);\n        }\n\n        return null;\n      }\n\n      if (!allowSpread) {\n        this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);\n      }\n\n      if (protoStart != null) {\n        this.unexpected(protoStart);\n      }\n\n      if (variance) {\n        this.raise(variance.start, FlowErrors.SpreadVariance);\n      }\n\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStart != null;\n      node.kind = kind;\n      let optional = false;\n\n      if (this.isRelational(\"<\") || this.match(types.parenL)) {\n        node.method = true;\n\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (variance) {\n          this.unexpected(variance.start);\n        }\n\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n\n        if (this.eat(types.question)) {\n          optional = true;\n        }\n\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const start = property.start;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n\n    if (length !== paramCount) {\n      if (property.kind === \"get\") {\n        this.raise(start, Errors.BadGetterArity);\n      } else {\n        this.raise(start, Errors.BadSetterArity);\n      }\n    }\n\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(start, Errors.BadSetterRestParameter);\n    }\n  }\n\n  flowObjectTypeSemicolon() {\n    if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n      this.unexpected();\n    }\n  }\n\n  flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n\n    while (this.eat(types.dot)) {\n      const node2 = this.startNodeAt(startPos, startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n\n    return node;\n  }\n\n  flowParseGenericType(startPos, startLoc, id) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(types._typeof);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(types.bracketL);\n\n    while (this.state.pos < this.length && !this.match(types.bracketR)) {\n      node.types.push(this.flowParseType());\n      if (this.match(types.bracketR)) break;\n      this.expect(types.comma);\n    }\n\n    this.expect(types.bracketR);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n\n  flowParseFunctionTypeParam() {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n\n    if (lh.type === types.colon || lh.type === types.question) {\n      name = this.parseIdentifier();\n\n      if (this.eat(types.question)) {\n        optional = true;\n      }\n\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.start, type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n\n    while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n      params.push(this.flowParseFunctionTypeParam());\n\n      if (!this.match(types.parenR)) {\n        this.expect(types.comma);\n      }\n    }\n\n    if (this.eat(types.ellipsis)) {\n      rest = this.flowParseFunctionTypeParam();\n    }\n\n    return {\n      params,\n      rest\n    };\n  }\n\n  flowIdentToTypeAnnotation(startPos, startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startPos, startLoc, id);\n    }\n  }\n\n  flowParsePrimaryType() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n    switch (this.state.type) {\n      case types.name:\n        if (this.isContextual(\"interface\")) {\n          return this.flowParseInterfaceType();\n        }\n\n        return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n\n      case types.braceL:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n\n      case types.braceBarL:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n\n      case types.bracketL:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n\n      case types.relational:\n        if (this.state.value === \"<\") {\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(types.parenL);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          this.expect(types.parenR);\n          this.expect(types.arrow);\n          node.returnType = this.flowParseType();\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n\n        break;\n\n      case types.parenL:\n        this.next();\n\n        if (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n          if (this.match(types.name)) {\n            const token = this.lookahead().type;\n            isGroupedType = token !== types.question && token !== types.colon;\n          } else {\n            isGroupedType = true;\n          }\n        }\n\n        if (isGroupedType) {\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {\n            this.expect(types.parenR);\n            return type;\n          } else {\n            this.eat(types.comma);\n          }\n        }\n\n        if (type) {\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n        } else {\n          tmp = this.flowParseFunctionTypeParams();\n        }\n\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        this.expect(types.parenR);\n        this.expect(types.arrow);\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n      case types.string:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n      case types._true:\n      case types._false:\n        node.value = this.match(types._true);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n      case types.plusMin:\n        if (this.state.value === \"-\") {\n          this.next();\n\n          if (this.match(types.num)) {\n            return this.parseLiteral(-this.state.value, \"NumberLiteralTypeAnnotation\", node.start, node.loc.start);\n          }\n\n          if (this.match(types.bigint)) {\n            return this.parseLiteral(-this.state.value, \"BigIntLiteralTypeAnnotation\", node.start, node.loc.start);\n          }\n\n          throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);\n        }\n\n        throw this.unexpected();\n\n      case types.num:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n      case types.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n\n      case types._void:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n\n      case types._null:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n      case types._this:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n\n      case types.star:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n      default:\n        if (this.state.type.keyword === \"typeof\") {\n          return this.flowParseTypeofType();\n        } else if (this.state.type.keyword) {\n          const label = this.state.type.label;\n          this.next();\n          return super.createIdentifier(node, label);\n        }\n\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParsePostfixType() {\n    const startPos = this.state.start,\n          startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n\n    while (this.match(types.bracketL) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.elementType = type;\n      this.expect(types.bracketL);\n      this.expect(types.bracketR);\n      type = this.finishNode(node, \"ArrayTypeAnnotation\");\n    }\n\n    return type;\n  }\n\n  flowParsePrefixType() {\n    const node = this.startNode();\n\n    if (this.eat(types.question)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n\n    if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {\n      const node = this.startNodeAt(param.start, param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    return param;\n  }\n\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(types.bitwiseAND);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n\n    while (this.eat(types.bitwiseAND)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(types.bitwiseOR);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n\n    while (this.eat(types.bitwiseOR)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;\n    return type;\n  }\n\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === types.name && this.state.value === \"_\") {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startPos, startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n\n    if (this.match(types.colon)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n\n    return ident;\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  flowParseVariance() {\n    let variance = null;\n\n    if (this.match(types.plusMin)) {\n      variance = this.startNode();\n\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n\n      this.next();\n      this.finishNode(variance, \"Variance\");\n    }\n\n    return variance;\n  }\n\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n    }\n\n    return super.parseFunctionBody(node, false, isMethod);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(types.colon)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.state.strict && this.match(types.name) && this.state.value === \"interface\") {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseInterface(node);\n    } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    } else {\n      const stmt = super.parseStatement(context, topLevel);\n\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n\n      return stmt;\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (this.match(types.name)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n\n    return super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || this.shouldParseEnums() && this.isContextual(\"enum\") || super.shouldParseExportDeclaration();\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types.name) && (this.state.value === \"type\" || this.state.value === \"interface\" || this.state.value === \"opaque\" || this.shouldParseEnums() && this.state.value === \"enum\")) {\n      return false;\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseExportDefaultExpression() {\n    if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n    if (!this.match(types.question)) return expr;\n\n    if (refNeedsArrowPos) {\n      const result = this.tryParse(() => super.parseConditional(expr, noIn, startPos, startLoc));\n\n      if (!result.node) {\n        refNeedsArrowPos.start = result.error.pos || this.state.start;\n        return expr;\n      }\n\n      if (result.error) this.state = result.failState;\n      return result.node;\n    }\n\n    this.expect(types.question);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startPos, startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n\n      if (failed && valid.length > 1) {\n        this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);\n      }\n\n      if (failed && valid.length === 1) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt.concat(valid[0].start);\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(types.colon);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(noIn, undefined, undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssign();\n    const failed = !this.match(types.colon);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n\n    while (stack.length !== 0) {\n      const node = stack.pop();\n\n      if (node.type === \"ArrowFunctionExpression\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n\n  finishArrowValidation(node) {\n    var _node$extra;\n\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma);\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n\n    return result;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(types.question)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(types.colon)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n\n    super.assertModuleNodeAllowed(node);\n  }\n\n  parseExport(node) {\n    const decl = super.parseExport(node);\n\n    if (decl.type === \"ExportNamedDeclaration\" || decl.type === \"ExportAllDeclaration\") {\n      decl.exportKind = decl.exportKind || \"value\";\n    }\n\n    return decl;\n  }\n\n  parseExportDeclaration(node) {\n    if (this.isContextual(\"type\")) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n\n      if (this.match(types.braceL)) {\n        node.specifiers = this.parseExportSpecifiers();\n        this.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(\"opaque\")) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(\"interface\")) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n\n  eatExportStar(node) {\n    if (super.eatExportStar(...arguments)) return true;\n\n    if (this.isContextual(\"type\") && this.lookahead().type === types.star) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    const pos = this.state.start;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(pos);\n    }\n\n    return hasNamespace;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n\n  parseClassMember(classBody, member, state, constructorAllowsSuper) {\n    const pos = this.state.start;\n\n    if (this.isContextual(\"declare\")) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n\n      member.declare = true;\n    }\n\n    super.parseClassMember(classBody, member, state, constructorAllowsSuper);\n\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\") {\n        this.raise(pos, FlowErrors.DeclareClassElement);\n      } else if (member.value) {\n        this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);\n      }\n    }\n  }\n\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 123 && next === 124) {\n      return this.finishOp(types.braceBarL, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(types.relational, 1);\n    } else if (isIteratorStart(code, next)) {\n      this.state.isIterator = true;\n      return super.readWord();\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        return true;\n\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type === \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n\n      case \"ArrayExpression\":\n        return node.elements.every(element => this.isAssignable(element));\n\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n\n      case \"ParenthesizedExpression\":\n      case \"TypeCastExpression\":\n        return this.isAssignable(node.expression);\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n\n      default:\n        return false;\n    }\n  }\n\n  toAssignable(node) {\n    if (node.type === \"TypeCastExpression\") {\n      return super.toAssignable(this.typeCastToParameter(node));\n    } else {\n      return super.toAssignable(node);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaPos) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if (expr && expr.type === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n\n    return super.toAssignableList(exprList, trailingCommaPos);\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if (expr && expr.type === \"TypeCastExpression\" && (!expr.extra || !expr.extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);\n      }\n    }\n\n    return exprList;\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription) {\n    if (expr.type !== \"TypeCastExpression\") {\n      return super.checkLVal(expr, bindingType, checkClashes, contextDescription);\n    }\n  }\n\n  parseClassProperty(node) {\n    if (this.match(types.colon)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (this.match(types.colon)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassPrivateProperty(node);\n  }\n\n  isClassMethod() {\n    return this.isRelational(\"<\") || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(types.colon) || super.isClassProperty();\n  }\n\n  isNonstaticConstructor(method) {\n    return !this.match(types.colon) && super.isNonstaticConstructor(method);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.start);\n    }\n\n    delete method.variance;\n\n    if (this.isRelational(\"<\")) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.start);\n    }\n\n    delete method.variance;\n\n    if (this.isRelational(\"<\")) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.isRelational(\"<\")) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    if (this.isContextual(\"implements\")) {\n      this.next();\n      const implemented = node.implements = [];\n\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(types.comma));\n    }\n  }\n\n  parsePropertyName(node, isPrivateNameAllowed) {\n    const variance = this.flowParseVariance();\n    const key = super.parsePropertyName(node, isPrivateNameAllowed);\n    node.variance = variance;\n    return key;\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.start);\n    }\n\n    delete prop.variance;\n    let typeParameters;\n\n    if (this.isRelational(\"<\")) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(types.parenL)) this.unexpected();\n    }\n\n    super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc);\n\n    if (typeParameters) {\n      (prop.value || prop).typeParameters = typeParameters;\n    }\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(types.question)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(param.start, FlowErrors.OptionalBindingPattern);\n      }\n\n      param.optional = true;\n    }\n\n    if (this.match(types.colon)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);\n    }\n\n    return node;\n  }\n\n  shouldParseDefaultImport(node) {\n    if (!hasTypeImportKind(node)) {\n      return super.shouldParseDefaultImport(node);\n    }\n\n    return isMaybeDefaultImport(this.state);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    node.importKind = \"value\";\n    let kind = null;\n\n    if (this.match(types._typeof)) {\n      kind = \"typeof\";\n    } else if (this.isContextual(\"type\")) {\n      kind = \"type\";\n    }\n\n    if (kind) {\n      const lh = this.lookahead();\n\n      if (kind === \"type\" && lh.type === types.star) {\n        this.unexpected(lh.start);\n      }\n\n      if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {\n        this.next();\n        node.importKind = kind;\n      }\n    }\n\n    return super.maybeParseDefaultImportSpecifier(node);\n  }\n\n  parseImportSpecifier(node) {\n    const specifier = this.startNode();\n    const firstIdentLoc = this.state.start;\n    const firstIdent = this.parseIdentifier(true);\n    let specifierTypeKind = null;\n\n    if (firstIdent.name === \"type\") {\n      specifierTypeKind = \"type\";\n    } else if (firstIdent.name === \"typeof\") {\n      specifierTypeKind = \"typeof\";\n    }\n\n    let isBinding = false;\n\n    if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n\n      if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = as_ident.__clone();\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {\n      specifier.imported = this.parseIdentifier(true);\n      specifier.importKind = specifierTypeKind;\n\n      if (this.eatContextual(\"as\")) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = specifier.imported.__clone();\n      }\n    } else {\n      isBinding = true;\n      specifier.imported = firstIdent;\n      specifier.importKind = null;\n      specifier.local = specifier.imported.__clone();\n    }\n\n    const nodeIsTypeImport = hasTypeImportKind(node);\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n    if (nodeIsTypeImport && specifierIsTypeImport) {\n      this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);\n    }\n\n    if (nodeIsTypeImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.start, true);\n    }\n\n    if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.start, true, true);\n    }\n\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, \"import specifier\");\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const kind = node.kind;\n\n    if (kind !== \"get\" && kind !== \"set\" && this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (this.match(types.colon)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(types.colon)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.colon) || super.shouldParseAsyncArrow();\n  }\n\n  parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    let state = null;\n    let jsx;\n\n    if (this.hasPlugin(\"jsx\") && (this.match(types.jsxTagStart) || this.isRelational(\"<\"))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n\n      if (context[context.length - 1] === types$1.j_oTag) {\n        context.length -= 2;\n      } else if (context[context.length - 1] === types$1.j_expr) {\n        context.length -= 1;\n      }\n    }\n\n    if (jsx && jsx.error || this.isRelational(\"<\")) {\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(() => {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos));\n        arrowExpression.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(arrowExpression, typeParameters);\n        return arrowExpression;\n      }, state);\n      const arrowExpression = arrow.node && arrow.node.type === \"ArrowFunctionExpression\" ? arrow.node : null;\n      if (!arrow.error && arrowExpression) return arrowExpression;\n\n      if (jsx && jsx.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n\n      if (jsx && jsx.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);\n    }\n\n    return super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos);\n  }\n\n  parseArrow(node) {\n    if (this.match(types.colon)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(types.arrow)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n\n    return super.parseArrow(node);\n  }\n\n  shouldParseArrow() {\n    return this.match(types.colon) || super.shouldParseArrow();\n  }\n\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      return;\n    }\n\n    return super.checkParams(...arguments);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startPos) !== -1) {\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.isRelational(\"<\")) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n\n      throw arrow.error || result.error;\n    }\n\n    return super.parseSubscripts(base, startPos, startLoc, noCalls);\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {\n    if (this.match(types.questionDot) && this.isLookaheadRelational(\"<\")) {\n      subscriptState.optionalChainMember = true;\n\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(types.parenL);\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.isRelational(\"<\")) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(types.parenL);\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        if (subscriptState.optionalChainMember) node.optional = false;\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);\n  }\n\n  parseNewArguments(node) {\n    let targs = null;\n\n    if (this.shouldParseTypes() && this.isRelational(\"<\")) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n\n    node.typeArguments = targs;\n    super.parseNewArguments(node);\n  }\n\n  parseAsyncArrowWithTypeParameters(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    this.parseFunctionParams(node);\n    if (!this.parseArrow(node)) return;\n    return this.parseArrowExpression(node, undefined, true);\n  }\n\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n\n    super.readToken_mult_modulo(code);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 124 && next === 125) {\n      this.finishOp(types.braceBarR, 2);\n      return;\n    }\n\n    super.readToken_pipe_amp(code);\n  }\n\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n\n    if (this.state.hasFlowComment) {\n      this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);\n    }\n\n    return fileNode;\n  }\n\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        this.unexpected(null, FlowErrors.NestedFlowComment);\n      }\n\n      this.hasFlowCommentCompletion();\n      this.state.pos += this.skipFlowComment();\n      this.state.hasFlowComment = true;\n      return;\n    }\n\n    if (this.state.hasFlowComment) {\n      const end = this.input.indexOf(\"*-/\", this.state.pos += 2);\n\n      if (end === -1) {\n        throw this.raise(this.state.pos - 2, Errors.UnterminatedComment);\n      }\n\n      this.state.pos = end + 3;\n      return;\n    }\n\n    super.skipBlockComment();\n  }\n\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n\n    return false;\n  }\n\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n\n    if (end === -1) {\n      throw this.raise(this.state.pos, Errors.UnterminatedComment);\n    }\n  }\n\n  flowEnumErrorBooleanMemberNotInitialized(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);\n  }\n\n  flowEnumErrorInvalidMemberName(pos, {\n    enumName,\n    memberName\n  }) {\n    const suggestion = memberName[0].toUpperCase() + memberName.slice(1);\n    this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);\n  }\n\n  flowEnumErrorDuplicateMemberName(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);\n  }\n\n  flowEnumErrorInconsistentMemberValues(pos, {\n    enumName\n  }) {\n    this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);\n  }\n\n  flowEnumErrorInvalidExplicitType(pos, {\n    enumName,\n    suppliedType\n  }) {\n    return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);\n  }\n\n  flowEnumErrorInvalidMemberInitializer(pos, {\n    enumName,\n    explicitType,\n    memberName\n  }) {\n    let message = null;\n\n    switch (explicitType) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;\n        break;\n\n      case \"symbol\":\n        message = FlowErrors.EnumInvalidMemberInitializerSymbolType;\n        break;\n\n      default:\n        message = FlowErrors.EnumInvalidMemberInitializerUnknownType;\n    }\n\n    return this.raise(pos, message, enumName, memberName, explicitType);\n  }\n\n  flowEnumErrorNumberMemberNotInitialized(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);\n  }\n\n  flowEnumErrorStringMemberInconsistentlyInitailized(pos, {\n    enumName\n  }) {\n    this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);\n  }\n\n  flowEnumMemberInit() {\n    const startPos = this.state.start;\n\n    const endOfInit = () => this.match(types.comma) || this.match(types.braceR);\n\n    switch (this.state.type) {\n      case types.num:\n        {\n          const literal = this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      case types.string:\n        {\n          const literal = this.parseLiteral(this.state.value, \"StringLiteral\");\n\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      case types._true:\n      case types._false:\n        {\n          const literal = this.parseBooleanLiteral();\n\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      default:\n        return {\n          type: \"invalid\",\n          pos: startPos\n        };\n    }\n  }\n\n  flowEnumMemberRaw() {\n    const pos = this.state.start;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(types.eq) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      pos\n    };\n    return {\n      id,\n      init\n    };\n  }\n\n  flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n\n    if (explicitType === null) {\n      return;\n    }\n\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(pos, context);\n    }\n  }\n\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n\n    while (!this.match(types.braceR)) {\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n\n      if (memberName === \"\") {\n        continue;\n      }\n\n      if (/^[a-z]/.test(memberName)) {\n        this.flowEnumErrorInvalidMemberName(id.start, {\n          enumName,\n          memberName\n        });\n      }\n\n      if (seenNames.has(memberName)) {\n        this.flowEnumErrorDuplicateMemberName(id.start, {\n          enumName,\n          memberName\n        });\n      }\n\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);\n          }\n\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);\n                break;\n\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);\n                break;\n\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n\n      if (!this.match(types.braceR)) {\n        this.expect(types.comma);\n      }\n    }\n\n    return members;\n  }\n\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (let _i = 0; _i < initializedMembers.length; _i++) {\n        const member = initializedMembers[_i];\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n          enumName\n        });\n      }\n\n      return defaultedMembers;\n    } else {\n      for (let _i2 = 0; _i2 < defaultedMembers.length; _i2++) {\n        const member = defaultedMembers[_i2];\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n          enumName\n        });\n      }\n\n      return initializedMembers;\n    }\n  }\n\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (this.eatContextual(\"of\")) {\n      if (!this.match(types.name)) {\n        throw this.flowEnumErrorInvalidExplicitType(this.state.start, {\n          enumName,\n          suppliedType: null\n        });\n      }\n\n      const {\n        value\n      } = this.state;\n      this.next();\n\n      if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n        this.flowEnumErrorInvalidExplicitType(this.state.start, {\n          enumName,\n          suppliedType: value\n        });\n      }\n\n      return value;\n    }\n\n    return null;\n  }\n\n  flowEnumBody(node, {\n    enumName,\n    nameLoc\n  }) {\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(types.braceL);\n    const members = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumBooleanBody\");\n\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumNumberBody\");\n\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumStringBody\");\n\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumSymbolBody\");\n\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (let _i3 = 0, _members$defaultedMem = members.defaultedMembers; _i3 < _members$defaultedMem.length; _i3++) {\n              const member = _members$defaultedMem[_i3];\n              this.flowEnumErrorBooleanMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.booleanMembers;\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (let _i4 = 0, _members$defaultedMem2 = members.defaultedMembers; _i4 < _members$defaultedMem2.length; _i4++) {\n              const member = _members$defaultedMem2[_i4];\n              this.flowEnumErrorNumberMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.numberMembers;\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.flowEnumErrorInconsistentMemberValues(nameLoc, {\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), {\n      enumName: id.name,\n      nameLoc: id.start\n    });\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n\n  updateContext(prevType) {\n    if (this.match(types.name) && this.state.value === \"of\" && prevType === types.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === \"interface\") {\n      this.state.exprAllowed = false;\n    } else {\n      super.updateContext(prevType);\n    }\n  }\n\n});\n\nconst entities = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\nconst DECIMAL_NUMBER = /^\\d+$/;\nconst JsxErrors = Object.freeze({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression\",\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>\",\n  MissingClosingTagElement: \"Expected corresponding JSX closing tag for <%0>\",\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text\",\n  UnterminatedJsxContent: \"Unterminated JSX contents\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\ntypes$1.j_oTag = new TokContext(\"<tag\", false);\ntypes$1.j_cTag = new TokContext(\"</tag\", false);\ntypes$1.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\ntypes.jsxName = new TokenType(\"jsxName\");\ntypes.jsxText = new TokenType(\"jsxText\", {\n  beforeExpr: true\n});\ntypes.jsxTagStart = new TokenType(\"jsxTagStart\", {\n  startsExpr: true\n});\ntypes.jsxTagEnd = new TokenType(\"jsxTagEnd\");\n\ntypes.jsxTagStart.updateContext = function () {\n  this.state.context.push(types$1.j_expr);\n  this.state.context.push(types$1.j_oTag);\n  this.state.exprAllowed = false;\n};\n\ntypes.jsxTagEnd.updateContext = function (prevType) {\n  const out = this.state.context.pop();\n\n  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {\n    this.state.context.pop();\n    this.state.exprAllowed = this.curContext() === types$1.j_expr;\n  } else {\n    this.state.exprAllowed = true;\n  }\n};\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nvar jsx = (superClass => class extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.exprAllowed) {\n              ++this.state.pos;\n              return this.finishToken(types.jsxTagStart);\n            }\n\n            return super.getTokenFromCode(ch);\n          }\n\n          out += this.input.slice(chunkStart, this.state.pos);\n          return this.finishToken(types.jsxText, out);\n\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n\n      }\n    }\n  }\n\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, Errors.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(types.string, out);\n  }\n\n  jsxReadEntity() {\n    let str = \"\";\n    let count = 0;\n    let entity;\n    let ch = this.input[this.state.pos];\n    const startPos = ++this.state.pos;\n\n    while (this.state.pos < this.length && count++ < 10) {\n      ch = this.input[this.state.pos++];\n\n      if (ch === \";\") {\n        if (str[0] === \"#\") {\n          if (str[1] === \"x\") {\n            str = str.substr(2);\n\n            if (HEX_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 16));\n            }\n          } else {\n            str = str.substr(1);\n\n            if (DECIMAL_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 10));\n            }\n          }\n        } else {\n          entity = entities[str];\n        }\n\n        break;\n      }\n\n      str += ch;\n    }\n\n    if (!entity) {\n      this.state.pos = startPos;\n      return \"&\";\n    }\n\n    return entity;\n  }\n\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n\n    return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));\n  }\n\n  jsxParseIdentifier() {\n    const node = this.startNode();\n\n    if (this.match(types.jsxName)) {\n      node.name = this.state.value;\n    } else if (this.state.type.keyword) {\n      node.name = this.state.type.keyword;\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n\n  jsxParseNamespacedName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(types.colon)) return name;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n\n  jsxParseElementName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n\n    while (this.eat(types.dot)) {\n      const newNode = this.startNodeAt(startPos, startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n\n    return node;\n  }\n\n  jsxParseAttributeValue() {\n    let node;\n\n    switch (this.state.type) {\n      case types.braceL:\n        node = this.startNode();\n        this.next();\n        node = this.jsxParseExpressionContainer(node);\n\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(node.start, JsxErrors.AttributeIsEmpty);\n        }\n\n        return node;\n\n      case types.jsxTagStart:\n      case types.string:\n        return this.parseExprAtom();\n\n      default:\n        throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);\n    }\n  }\n\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n  }\n\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n\n  jsxParseExpressionContainer(node) {\n    if (this.match(types.braceR)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      node.expression = this.parseExpression();\n    }\n\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n\n  jsxParseAttribute() {\n    const node = this.startNode();\n\n    if (this.eat(types.braceL)) {\n      this.expect(types.ellipsis);\n      node.argument = this.parseMaybeAssign();\n      this.expect(types.braceR);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n\n  jsxParseOpeningElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n\n    while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n\n    node.attributes = attributes;\n    node.selfClosing = this.eat(types.slash);\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n\n  jsxParseClosingElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n\n  jsxParseElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n    let closingElement = null;\n\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case types.jsxTagStart:\n            startPos = this.state.start;\n            startLoc = this.state.startLoc;\n            this.next();\n\n            if (this.eat(types.slash)) {\n              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n\n            children.push(this.jsxParseElementAt(startPos, startLoc));\n            break;\n\n          case types.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case types.braceL:\n            {\n              const node = this.startNode();\n              this.next();\n\n              if (this.match(types.ellipsis)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node));\n              }\n\n              break;\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      if (isFragment(openingElement) && !isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n        }\n      }\n    }\n\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n\n    node.children = children;\n\n    if (this.isRelational(\"<\")) {\n      throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);\n    }\n\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n\n  jsxParseElement() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startPos, startLoc);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(types.jsxText)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(types.jsxTagStart)) {\n      return this.jsxParseElement();\n    } else if (this.isRelational(\"<\") && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.finishToken(types.jsxTagStart);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inPropertyName) return super.getTokenFromCode(code);\n    const context = this.curContext();\n\n    if (context === types$1.j_expr) {\n      return this.jsxReadToken();\n    }\n\n    if (context === types$1.j_oTag || context === types$1.j_cTag) {\n      if (isIdentifierStart(code)) {\n        return this.jsxReadWord();\n      }\n\n      if (code === 62) {\n        ++this.state.pos;\n        return this.finishToken(types.jsxTagEnd);\n      }\n\n      if ((code === 34 || code === 39) && context === types$1.j_oTag) {\n        return this.jsxReadString(code);\n      }\n    }\n\n    if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      return this.finishToken(types.jsxTagStart);\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  updateContext(prevType) {\n    if (this.match(types.braceL)) {\n      const curContext = this.curContext();\n\n      if (curContext === types$1.j_oTag) {\n        this.state.context.push(types$1.braceExpression);\n      } else if (curContext === types$1.j_expr) {\n        this.state.context.push(types$1.templateQuasi);\n      } else {\n        super.updateContext(prevType);\n      }\n\n      this.state.exprAllowed = true;\n    } else if (this.match(types.slash) && prevType === types.jsxTagStart) {\n      this.state.context.length -= 2;\n      this.state.context.push(types$1.j_cTag);\n      this.state.exprAllowed = false;\n    } else {\n      return super.updateContext(prevType);\n    }\n  }\n\n});\n\nclass Scope {\n  constructor(flags) {\n    this.var = [];\n    this.lexical = [];\n    this.functions = [];\n    this.flags = flags;\n  }\n\n}\nclass ScopeHandler {\n  constructor(raise, inModule) {\n    this.scopeStack = [];\n    this.undefinedExports = new Map();\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n    this.inModule = inModule;\n  }\n\n  get inFunction() {\n    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get allowSuper() {\n    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;\n  }\n\n  get allowDirectSuper() {\n    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n  }\n\n  get inClass() {\n    return (this.currentThisScope().flags & SCOPE_CLASS) > 0;\n  }\n\n  get inNonArrowFunction() {\n    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags) {\n    return new Scope(flags);\n  }\n\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit() {\n    this.scopeStack.pop();\n  }\n\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);\n  }\n\n  declareName(name, bindingType, pos) {\n    let scope = this.currentScope();\n\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.push(name);\n      } else {\n        scope.lexical.push(name);\n      }\n\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        scope.var.push(name);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope, name) {\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(scope, name, bindingType, pos) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.raise(pos, Errors.VarRedeclaration, name);\n    }\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    }\n\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope.var.indexOf(name) > -1;\n    }\n\n    return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {\n      this.undefinedExports.set(id.name, id.start);\n    }\n  }\n\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if (scope.flags & SCOPE_VAR) {\n        return scope;\n      }\n    }\n  }\n\n  currentThisScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {\n        return scope;\n      }\n    }\n  }\n\n}\n\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.types = [];\n    this.enums = [];\n    this.constEnums = [];\n    this.classes = [];\n    this.exportOnlyBindings = [];\n  }\n\n}\n\nclass TypeScriptScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new TypeScriptScope(flags);\n  }\n\n  declareName(name, bindingType, pos) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.push(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        this.maybeExportDefined(scope, name);\n      }\n\n      scope.types.push(name);\n    }\n\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (scope.enums.indexOf(name) > -1) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.indexOf(name) > -1;\n        return isConst !== wasConst;\n      }\n\n      return true;\n    }\n\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {\n      if (scope.lexical.indexOf(name) > -1) {\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(...arguments);\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nconst PARAM = 0b000,\n      PARAM_YIELD = 0b001,\n      PARAM_AWAIT = 0b010,\n      PARAM_RETURN = 0b100;\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait() {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n\n  get hasYield() {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n\n  get hasReturn() {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\n\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n\n  return x;\n}\n\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\nconst TSErrors = Object.freeze({\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier\",\n  DeclareClassFieldHasInitializer: \"'declare' class fields cannot have an initializer\",\n  DuplicateModifier: \"Duplicate modifier: '%0'\",\n  EmptyHeritageClauseType: \"'%0' list cannot be empty.\",\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier\",\n  IndexSignatureHasAccessibility: \"Index signatures cannot have an accessibility modifier ('%0')\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: \"Private elements cannot have an accessibility modifier ('%0')\",\n  TemplateTypeHasSubstitution: \"Template literal types cannot have any substitution\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: \"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0\"\n});\n\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n\n    case \"never\":\n      return \"TSNeverKeyword\";\n\n    case \"number\":\n      return \"TSNumberKeyword\";\n\n    case \"object\":\n      return \"TSObjectKeyword\";\n\n    case \"string\":\n      return \"TSStringKeyword\";\n\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n\n    default:\n      return undefined;\n  }\n}\n\nvar typescript = (superClass => class extends superClass {\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n\n  tsIsIdentifier() {\n    return this.match(types.name);\n  }\n\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.parenR) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question) && !this.match(types.bang);\n  }\n\n  tsParseModifier(allowedModifiers) {\n    if (!this.match(types.name)) {\n      return undefined;\n    }\n\n    const modifier = this.state.value;\n\n    if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n      return modifier;\n    }\n\n    return undefined;\n  }\n\n  tsParseModifiers(modified, allowedModifiers) {\n    for (;;) {\n      const startPos = this.state.start;\n      const modifier = this.tsParseModifier(allowedModifiers);\n      if (!modifier) break;\n\n      if (Object.hasOwnProperty.call(modified, modifier)) {\n        this.raise(startPos, TSErrors.DuplicateModifier, modifier);\n      }\n\n      modified[modifier] = true;\n    }\n  }\n\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(types.braceR);\n\n      case \"HeritageClauseElement\":\n        return this.match(types.braceL);\n\n      case \"TupleElementTypes\":\n        return this.match(types.bracketR);\n\n      case \"TypeParametersOrArguments\":\n        return this.isRelational(\">\");\n    }\n\n    throw new Error(\"Unreachable\");\n  }\n\n  tsParseList(kind, parseElement) {\n    const result = [];\n\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n\n    return result;\n  }\n\n  tsParseDelimitedList(kind, parseElement) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));\n  }\n\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {\n    const result = [];\n\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      const element = parseElement();\n\n      if (element == null) {\n        return undefined;\n      }\n\n      result.push(element);\n\n      if (this.eat(types.comma)) {\n        continue;\n      }\n\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      if (expectSuccess) {\n        this.expect(types.comma);\n      }\n\n      return undefined;\n    }\n\n    return result;\n  }\n\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(types.bracketL);\n      } else {\n        this.expectRelational(\"<\");\n      }\n    }\n\n    const result = this.tsParseDelimitedList(kind, parseElement);\n\n    if (bracket) {\n      this.expect(types.bracketR);\n    } else {\n      this.expectRelational(\">\");\n    }\n\n    return result;\n  }\n\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(types._import);\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);\n    }\n\n    node.argument = this.parseExprAtom();\n    this.expect(types.parenR);\n\n    if (this.eat(types.dot)) {\n      node.qualifier = this.tsParseEntityName(true);\n    }\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSImportType\");\n  }\n\n  tsParseEntityName(allowReservedWords) {\n    let entity = this.parseIdentifier();\n\n    while (this.eat(types.dot)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n\n    return entity;\n  }\n\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName(false);\n\n    if (!this.hasPrecedingLineBreak() && this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(types._typeof);\n\n    if (this.match(types._import)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName(true);\n    }\n\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n\n  tsParseTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsEatThenParseType(types._extends);\n    node.default = this.tsEatThenParseType(types.eq);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsTryParseTypeParameters() {\n    if (this.isRelational(\"<\")) {\n      return this.tsParseTypeParameters();\n    }\n  }\n\n  tsParseTypeParameters() {\n    const node = this.startNode();\n\n    if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this), false, true);\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n\n  tsTryNextParseConstantContext() {\n    if (this.lookahead().type === types._const) {\n      this.next();\n      return this.tsParseTypeReference();\n    }\n\n    return null;\n  }\n\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === types.arrow;\n    signature.typeParameters = this.tsTryParseTypeParameters();\n    this.expect(types.parenL);\n    signature.parameters = this.tsParseBindingListForSignature();\n\n    if (returnTokenRequired) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n\n  tsParseBindingListForSignature() {\n    return this.parseBindingList(types.parenR, 41).map(pattern => {\n      if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n        this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);\n      }\n\n      return pattern;\n    });\n  }\n\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(types.comma)) {\n      this.semicolon();\n    }\n  }\n\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(types.colon, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    return this.eat(types.name) && this.match(types.colon);\n  }\n\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return undefined;\n    }\n\n    this.expect(types.bracketL);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(types.bracketR);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(types.question)) node.optional = true;\n    const nodeAny = node;\n\n    if (!readonly && (this.match(types.parenL) || this.isRelational(\"<\"))) {\n      const method = nodeAny;\n      this.tsFillSignature(types.colon, method);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n\n  tsParseTypeMember() {\n    const node = this.startNode();\n\n    if (this.match(types.parenL) || this.isRelational(\"<\")) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n\n    if (this.match(types._new)) {\n      const id = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL) || this.isRelational(\"<\")) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n\n    const readonly = !!this.tsParseModifier([\"readonly\"]);\n    const idx = this.tsTryParseIndexSignature(node);\n\n    if (idx) {\n      if (readonly) node.readonly = true;\n      return idx;\n    }\n\n    this.parsePropertyName(node, false);\n    return this.tsParsePropertyOrMethodSignature(node, readonly);\n  }\n\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n\n  tsParseObjectTypeMembers() {\n    this.expect(types.braceL);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(types.braceR);\n    return members;\n  }\n\n  tsIsStartOfMappedType() {\n    this.next();\n\n    if (this.eat(types.plusMin)) {\n      return this.isContextual(\"readonly\");\n    }\n\n    if (this.isContextual(\"readonly\")) {\n      this.next();\n    }\n\n    if (!this.match(types.bracketL)) {\n      return false;\n    }\n\n    this.next();\n\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n\n    this.next();\n    return this.match(types._in);\n  }\n\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsExpectThenParseType(types._in);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(types.braceL);\n\n    if (this.match(types.plusMin)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(\"readonly\");\n    } else if (this.eatContextual(\"readonly\")) {\n      node.readonly = true;\n    }\n\n    this.expect(types.bracketL);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    this.expect(types.bracketR);\n\n    if (this.match(types.plusMin)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(types.question);\n    } else if (this.eat(types.question)) {\n      node.optional = true;\n    }\n\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    node.elementTypes.forEach(elementNode => {\n      if (elementNode.type === \"TSOptionalType\") {\n        seenOptionalElement = true;\n      } else if (seenOptionalElement && elementNode.type !== \"TSRestType\") {\n        this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);\n      }\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n\n  tsParseTupleElementType() {\n    if (this.match(types.ellipsis)) {\n      const restNode = this.startNode();\n      this.next();\n      restNode.typeAnnotation = this.tsParseType();\n\n      if (this.match(types.comma) && this.lookaheadCharCode() !== 93) {\n        this.raiseRestNotLast(this.state.start);\n      }\n\n      return this.finishNode(restNode, \"TSRestType\");\n    }\n\n    const type = this.tsParseType();\n\n    if (this.eat(types.question)) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      return this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n\n    return type;\n  }\n\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(types.parenL);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n\n  tsParseFunctionOrConstructorType(type) {\n    const node = this.startNode();\n\n    if (type === \"TSConstructorType\") {\n      this.expect(types._new);\n    }\n\n    this.tsFillSignature(types.arrow, node);\n    return this.finishNode(node, type);\n  }\n\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n\n    node.literal = (() => {\n      switch (this.state.type) {\n        case types.num:\n        case types.string:\n        case types._true:\n        case types._false:\n          return this.parseExprAtom();\n\n        default:\n          throw this.unexpected();\n      }\n    })();\n\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    const templateNode = this.parseTemplate(false);\n\n    if (templateNode.expressions.length > 0) {\n      this.raise(templateNode.expressions[0].start, TSErrors.TemplateTypeHasSubstitution);\n    }\n\n    node.literal = templateNode;\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case types.name:\n      case types._void:\n      case types._null:\n        {\n          const type = this.match(types._void) ? \"TSVoidKeyword\" : this.match(types._null) ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n\n          if (type !== undefined && this.lookaheadCharCode() !== 46) {\n            const node = this.startNode();\n            this.next();\n            return this.finishNode(node, type);\n          }\n\n          return this.tsParseTypeReference();\n        }\n\n      case types.string:\n      case types.num:\n      case types._true:\n      case types._false:\n        return this.tsParseLiteralTypeNode();\n\n      case types.plusMin:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n\n          if (this.lookahead().type !== types.num) {\n            throw this.unexpected();\n          }\n\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n\n        break;\n\n      case types._this:\n        return this.tsParseThisTypeOrThisTypePredicate();\n\n      case types._typeof:\n        return this.tsParseTypeQuery();\n\n      case types._import:\n        return this.tsParseImportType();\n\n      case types.braceL:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n      case types.bracketL:\n        return this.tsParseTupleType();\n\n      case types.parenL:\n        return this.tsParseParenthesizedType();\n\n      case types.backQuote:\n        return this.tsParseTemplateLiteralType();\n    }\n\n    throw this.unexpected();\n  }\n\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n\n    while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {\n      if (this.match(types.bracketR)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n\n    return type;\n  }\n\n  tsParseTypeOperator(operator) {\n    const node = this.startNode();\n    this.expectContextual(operator);\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n\n      default:\n        this.raise(node.start, TSErrors.UnexpectedReadonly);\n    }\n  }\n\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(\"infer\");\n    const typeParameter = this.startNode();\n    typeParameter.name = this.parseIdentifierName(typeParameter.start);\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n\n  tsParseTypeOperatorOrHigher() {\n    const operator = [\"keyof\", \"unique\", \"readonly\"].find(kw => this.isContextual(kw));\n    return operator ? this.tsParseTypeOperator(operator) : this.isContextual(\"infer\") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();\n  }\n\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    this.eat(operator);\n    let type = parseConstituentType();\n\n    if (this.match(operator)) {\n      const types = [type];\n\n      while (this.eat(operator)) {\n        types.push(parseConstituentType());\n      }\n\n      const node = this.startNodeAtNode(type);\n      node.types = types;\n      type = this.finishNode(node, kind);\n    }\n\n    return type;\n  }\n\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);\n  }\n\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);\n  }\n\n  tsIsStartOfFunctionType() {\n    if (this.isRelational(\"<\")) {\n      return true;\n    }\n\n    return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n\n  tsSkipParameterStart() {\n    if (this.match(types.name) || this.match(types._this)) {\n      this.next();\n      return true;\n    }\n\n    if (this.match(types.braceL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.braceL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.braceR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    if (this.match(types.bracketL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.bracketL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.bracketR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n\n    if (this.match(types.parenR) || this.match(types.ellipsis)) {\n      return true;\n    }\n\n    if (this.tsSkipParameterStart()) {\n      if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {\n        return true;\n      }\n\n      if (this.match(types.parenR)) {\n        this.next();\n\n        if (this.match(types.arrow)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const asserts = this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n\n      if (asserts && this.match(types._this)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n\n        if (thisTypePredicate.type === \"TSThisType\") {\n          const node = this.startNodeAtNode(t);\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          thisTypePredicate.asserts = true;\n        }\n\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n\n        const node = this.startNodeAtNode(t);\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const type = this.tsParseTypeAnnotation(false);\n      const node = this.startNodeAtNode(t);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;\n  }\n\n  tsTryParseTypeAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;\n  }\n\n  tsTryParseType() {\n    return this.tsEatThenParseType(types.colon);\n  }\n\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n\n  tsParseTypePredicateAsserts() {\n    if (!this.match(types.name) || this.state.value !== \"asserts\" || this.hasPrecedingLineBreak()) {\n      return false;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.next();\n\n    if (!this.match(types.name) && !this.match(types._this)) {\n      return false;\n    }\n\n    if (containsEsc) {\n      this.raise(this.state.lastTokStart, Errors.InvalidEscapedReservedWord, \"asserts\");\n    }\n\n    return true;\n  }\n\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(types.colon);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n\n    if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {\n      return type;\n    }\n\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsParseNonConditionalType();\n    this.expect(types.question);\n    node.trueType = this.tsParseType();\n    this.expect(types.colon);\n    node.falseType = this.tsParseType();\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n\n    if (this.match(types._new)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    }\n\n    return this.tsParseUnionTypeOrHigher();\n  }\n\n  tsParseTypeAssertion() {\n    const node = this.startNode();\n\n    const _const = this.tsTryNextParseConstantContext();\n\n    node.typeAnnotation = _const || this.tsNextThenParseType();\n    this.expectRelational(\">\");\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n\n  tsParseHeritageClause(descriptor) {\n    const originalStart = this.state.start;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", this.tsParseExpressionWithTypeArguments.bind(this));\n\n    if (!delimitedList.length) {\n      this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);\n    }\n\n    return delimitedList;\n  }\n\n  tsParseExpressionWithTypeArguments() {\n    const node = this.startNode();\n    node.expression = this.tsParseEntityName(false);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n  }\n\n  tsParseInterfaceDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, BIND_TS_INTERFACE, undefined, \"typescript interface declaration\");\n    node.typeParameters = this.tsTryParseTypeParameters();\n\n    if (this.eat(types._extends)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, BIND_TS_TYPE, undefined, \"typescript type alias\");\n    node.typeParameters = this.tsTryParseTypeParameters();\n    node.typeAnnotation = this.tsExpectThenParseType(types.eq);\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n\n  tsEatThenParseType(token) {\n    return !this.match(token) ? undefined : this.tsNextThenParseType();\n  }\n\n  tsExpectThenParseType(token) {\n    return this.tsDoThenParseType(() => this.expect(token));\n  }\n\n  tsNextThenParseType() {\n    return this.tsDoThenParseType(() => this.next());\n  }\n\n  tsDoThenParseType(cb) {\n    return this.tsInType(() => {\n      cb();\n      return this.tsParseType();\n    });\n  }\n\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n\n    if (this.eat(types.eq)) {\n      node.initializer = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n\n  tsParseEnumDeclaration(node, isConst) {\n    if (isConst) node.const = true;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM, undefined, \"typescript enum declaration\");\n    this.expect(types.braceL);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.braceL);\n    this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n\n    if (!nested) {\n      this.checkLVal(node.id, BIND_TS_NAMESPACE, null, \"module or namespace declaration\");\n    }\n\n    if (this.eat(types.dot)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(\"global\")) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(types.string)) {\n      node.id = this.parseExprAtom();\n    } else {\n      this.unexpected();\n    }\n\n    if (this.match(types.braceL)) {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseImportEqualsDeclaration(node, isExport) {\n    node.isExport = isExport || false;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, BIND_LEXICAL, undefined, \"import equals declaration\");\n    this.expect(types.eq);\n    node.moduleReference = this.tsParseModuleReference();\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n\n  tsIsExternalModuleReference() {\n    return this.isContextual(\"require\") && this.lookaheadCharCode() === 40;\n  }\n\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(\"require\");\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      throw this.unexpected();\n    }\n\n    node.expression = this.parseExprAtom();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return undefined;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n\n    if (result !== undefined && result !== false) {\n      return result;\n    } else {\n      this.state = state;\n      return undefined;\n    }\n  }\n\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n\n    let starttype = this.state.type;\n    let kind;\n\n    if (this.isContextual(\"let\")) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case types._function:\n        return this.parseFunctionStatement(nany, false, true);\n\n      case types._class:\n        nany.declare = true;\n        return this.parseClass(nany, true, false);\n\n      case types._const:\n        if (this.match(types._const) && this.isLookaheadContextual(\"enum\")) {\n          this.expect(types._const);\n          this.expectContextual(\"enum\");\n          return this.tsParseEnumDeclaration(nany, true);\n        }\n\n      case types._var:\n        kind = kind || this.state.value;\n        return this.parseVarStatement(nany, kind);\n\n      case types.name:\n        {\n          const value = this.state.value;\n\n          if (value === \"global\") {\n            return this.tsParseAmbientExternalModuleDeclaration(nany);\n          } else {\n            return this.tsParseDeclaration(nany, value, true);\n          }\n        }\n    }\n  }\n\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true);\n  }\n\n  tsParseExpressionStatement(node, expr) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n\n          break;\n        }\n\n      case \"global\":\n        if (this.match(types.braceL)) {\n          this.scope.enter(SCOPE_TS_MODULE);\n          this.prodParam.enter(PARAM);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n\n        break;\n\n      default:\n        return this.tsParseDeclaration(node, expr.name, false);\n    }\n  }\n\n  tsParseDeclaration(node, value, next) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {\n          const cls = node;\n          cls.abstract = true;\n\n          if (next) {\n            this.next();\n\n            if (!this.match(types._class)) {\n              this.unexpected(null, types._class);\n            }\n          }\n\n          return this.parseClass(cls, true, false);\n        }\n\n        break;\n\n      case \"enum\":\n        if (next || this.match(types.name)) {\n          if (next) this.next();\n          return this.tsParseEnumDeclaration(node, false);\n        }\n\n        break;\n\n      case \"interface\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseInterfaceDeclaration(node);\n        }\n\n        break;\n\n      case \"module\":\n        if (next) this.next();\n\n        if (this.match(types.string)) {\n          return this.tsParseAmbientExternalModuleDeclaration(node);\n        } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"namespace\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"type\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n\n        break;\n    }\n  }\n\n  tsCheckLineTerminatorAndMatch(tokenType, next) {\n    return (next || this.match(tokenType)) && !this.isLineTerminator();\n  }\n\n  tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {\n    if (!this.isRelational(\"<\")) {\n      return undefined;\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    this.state.maybeInArrowParameters = true;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = this.tsParseTypeParameters();\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(types.arrow);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.yieldPos = oldYieldPos;\n    this.state.awaitPos = oldAwaitPos;\n\n    if (!res) {\n      return undefined;\n    }\n\n    return this.parseArrowExpression(res, null, true);\n  }\n\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expectRelational(\"<\");\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    this.state.exprAllowed = false;\n    this.expectRelational(\">\");\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n\n  tsIsDeclarationStart() {\n    if (this.match(types.name)) {\n      switch (this.state.value) {\n        case \"abstract\":\n        case \"declare\":\n        case \"enum\":\n        case \"interface\":\n        case \"module\":\n        case \"namespace\":\n        case \"type\":\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let accessibility;\n    let readonly = false;\n\n    if (allowModifiers) {\n      accessibility = this.parseAccessModifier();\n      readonly = !!this.tsParseModifier([\"readonly\"]);\n    }\n\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (accessibility || readonly) {\n      const pp = this.startNodeAt(startPos, startLoc);\n\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);\n      }\n\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n    }\n\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" ? \"TSDeclareMethod\" : undefined;\n\n    if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {\n      this.finishNode(node, bodilessType);\n      return;\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkLVal(node.id, BIND_TS_AMBIENT, null, \"function name\");\n    } else {\n      super.registerFunctionStatementId(...arguments);\n    }\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {\n      this.state.exprAllowed = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startPos, startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n\n    if (this.isRelational(\"<\")) {\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);\n\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        const typeArguments = this.tsParseTypeArguments();\n\n        if (typeArguments) {\n          if (!noCalls && this.eat(types.parenL)) {\n            node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n            node.typeParameters = typeArguments;\n            return this.finishCallExpression(node, state.optionalChainMember);\n          } else if (this.match(types.backQuote)) {\n            return this.parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments);\n          }\n        }\n\n        this.unexpected();\n      });\n      if (result) return result;\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n  }\n\n  parseNewArguments(node) {\n    if (this.isRelational(\"<\")) {\n      const typeParameters = this.tsTryParseAndCatch(() => {\n        const args = this.tsParseTypeArguments();\n        if (!this.match(types.parenL)) this.unexpected();\n        return args;\n      });\n\n      if (typeParameters) {\n        node.typeParameters = typeParameters;\n      }\n    }\n\n    super.parseNewArguments(node);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(\"as\")) {\n      const node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.expression = left;\n\n      const _const = this.tsTryNextParseConstantContext();\n\n      if (_const) {\n        node.typeAnnotation = _const;\n      } else {\n        node.typeAnnotation = this.tsNextThenParseType();\n      }\n\n      this.finishNode(node, \"TSAsExpression\");\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n    }\n\n    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn);\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {}\n\n  checkDuplicateExports() {}\n\n  parseImport(node) {\n    if (this.match(types.name) || this.match(types.star) || this.match(types.braceL)) {\n      const ahead = this.lookahead();\n\n      if (this.match(types.name) && ahead.type === types.eq) {\n        return this.tsParseImportEqualsDeclaration(node);\n      }\n\n      if (this.isContextual(\"type\") && ahead.type !== types.comma && !(ahead.type === types.name && ahead.value === \"from\")) {\n        node.importKind = \"type\";\n        this.next();\n      } else {\n        node.importKind = \"value\";\n      }\n    }\n\n    const importNode = super.parseImport(node);\n\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(importNode.start, \"A type-only import can specify a default import or named bindings, but not both.\");\n    }\n\n    return importNode;\n  }\n\n  parseExport(node) {\n    if (this.match(types._import)) {\n      this.expect(types._import);\n      return this.tsParseImportEqualsDeclaration(node, true);\n    } else if (this.eat(types.eq)) {\n      const assign = node;\n      assign.expression = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(\"as\")) {\n      const decl = node;\n      this.expectContextual(\"namespace\");\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      if (this.isContextual(\"type\") && this.lookahead().type === types.braceL) {\n        this.next();\n        node.exportKind = \"type\";\n      } else {\n        node.exportKind = \"value\";\n      }\n\n      return super.parseExport(node);\n    }\n  }\n\n  isAbstractClass() {\n    return this.isContextual(\"abstract\") && this.lookahead().type === types._class;\n  }\n\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      this.parseClass(cls, true, true);\n      cls.abstract = true;\n      return cls;\n    }\n\n    if (this.state.value === \"interface\") {\n      const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);\n      if (result) return result;\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseStatementContent(context, topLevel) {\n    if (this.state.type === types._const) {\n      const ahead = this.lookahead();\n\n      if (ahead.type === types.name && ahead.value === \"enum\") {\n        const node = this.startNode();\n        this.expect(types._const);\n        this.expectContextual(\"enum\");\n        return this.tsParseEnumDeclaration(node, true);\n      }\n    }\n\n    return super.parseStatementContent(context, topLevel);\n  }\n\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n\n  parseClassMember(classBody, member, state, constructorAllowsSuper) {\n    this.tsParseModifiers(member, [\"declare\"]);\n    const accessibility = this.parseAccessModifier();\n    if (accessibility) member.accessibility = accessibility;\n    this.tsParseModifiers(member, [\"declare\"]);\n    super.parseClassMember(classBody, member, state, constructorAllowsSuper);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {\n    this.tsParseModifiers(member, [\"abstract\", \"readonly\", \"declare\"]);\n    const idx = this.tsTryParseIndexSignature(member);\n\n    if (idx) {\n      classBody.body.push(idx);\n\n      if (member.abstract) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAbstract);\n      }\n\n      if (isStatic) {\n        this.raise(member.start, TSErrors.IndexSignatureHasStatic);\n      }\n\n      if (member.accessibility) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);\n      }\n\n      return;\n    }\n\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(types.question);\n    if (optional) methodOrProp.optional = true;\n\n    if (methodOrProp.readonly && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);\n    }\n\n    if (methodOrProp.declare && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : undefined;\n    return decl || super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n\n  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n    if (!refNeedsArrowPos || !this.match(types.question)) {\n      return super.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);\n    }\n\n    const result = this.tryParse(() => super.parseConditional(expr, noIn, startPos, startLoc));\n\n    if (!result.node) {\n      refNeedsArrowPos.start = result.error.pos || this.state.start;\n      return expr;\n    }\n\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(types.question)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(types.colon)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  parseExportDeclaration(node) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(\"declare\");\n    let declaration;\n\n    if (this.match(types.name)) {\n      declaration = this.tsTryParseExportDeclaration();\n    }\n\n    if (!declaration) {\n      declaration = super.parseExportDeclaration(node);\n    }\n\n    if (declaration && (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare)) {\n      node.exportKind = \"type\";\n    }\n\n    if (declaration && isDeclare) {\n      this.resetStartLocation(declaration, startPos, startLoc);\n      declaration.declare = true;\n    }\n\n    return declaration;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    if ((!isStatement || optionalId) && this.isContextual(\"implements\")) {\n      return;\n    }\n\n    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional && this.eat(types.bang)) {\n      node.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n\n    if (node.declare && this.match(types.equal)) {\n      this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(node.start, TSErrors.PrivateElementHasAbstract);\n    }\n\n    if (node.accessibility) {\n      this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);\n    }\n\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.isRelational(\"<\")) {\n      node.superTypeParameters = this.tsParseTypeArguments();\n    }\n\n    if (this.eatContextual(\"implements\")) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n\n  parseObjPropValue(prop, ...args) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) prop.typeParameters = typeParameters;\n    super.parseObjPropValue(prop, ...args);\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (decl.id.type === \"Identifier\" && this.eat(types.bang)) {\n      decl.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  parseMaybeAssign(...args) {\n    let state;\n    let jsx;\n    let typeCast;\n\n    if (this.match(types.jsxTagStart)) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n\n      if (context[context.length - 1] === types$1.j_oTag) {\n        context.length -= 2;\n      } else if (context[context.length - 1] === types$1.j_expr) {\n        context.length -= 1;\n      }\n    }\n\n    if (!(jsx && jsx.error) && !this.isRelational(\"<\")) {\n      return super.parseMaybeAssign(...args);\n    }\n\n    let typeParameters;\n    state = state || this.state.clone();\n    const arrow = this.tryParse(abort => {\n      typeParameters = this.tsParseTypeParameters();\n      const expr = super.parseMaybeAssign(...args);\n\n      if (expr.type !== \"ArrowFunctionExpression\" || expr.extra && expr.extra.parenthesized) {\n        abort();\n      }\n\n      if (typeParameters && typeParameters.params.length !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) return arrow.node;\n\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n\n    if (jsx && jsx.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n\n    if (arrow.node) {\n      this.state = arrow.failState;\n      return arrow.node;\n    }\n\n    if (typeCast && typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n\n    if (jsx && jsx.thrown) throw jsx.error;\n    if (arrow.thrown) throw arrow.error;\n    if (typeCast && typeCast.thrown) throw typeCast.error;\n    throw jsx && jsx.error || arrow.error || typeCast && typeCast.error;\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    if (!this.hasPlugin(\"jsx\") && this.isRelational(\"<\")) {\n      return this.tsParseTypeAssertion();\n    } else {\n      return super.parseMaybeUnary(refExpressionErrors);\n    }\n  }\n\n  parseArrow(node) {\n    if (this.match(types.colon)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n        if (this.canInsertSemicolon() || !this.match(types.arrow)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n\n    return super.parseArrow(node);\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(types.question)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(param.start, TSErrors.PatternIsOptional);\n      }\n\n      param.optional = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  toAssignable(node) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return super.toAssignable(this.typeCastToParameter(node));\n\n      case \"TSParameterProperty\":\n        return super.toAssignable(node);\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        node.expression = this.toAssignable(node.expression);\n        return node;\n\n      default:\n        return super.toAssignable(node);\n    }\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription) {\n    switch (expr.type) {\n      case \"TSTypeCastExpression\":\n        return;\n\n      case \"TSParameterProperty\":\n        this.checkLVal(expr.parameter, bindingType, checkClashes, \"parameter property\");\n        return;\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        this.checkLVal(expr.expression, bindingType, checkClashes, contextDescription);\n        return;\n\n      default:\n        super.checkLVal(expr, bindingType, checkClashes, contextDescription);\n        return;\n    }\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types._this:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsParseTypeArguments();\n\n      if (this.match(types.parenL)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n\n      this.unexpected(this.state.start, types.parenL);\n    }\n\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n\n  isClassMethod() {\n    return this.isRelational(\"<\") || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(types.bang) || this.match(types.colon) || super.isClassProperty();\n  }\n\n  parseMaybeDefault(...args) {\n    const node = super.parseMaybeDefault(...args);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);\n    }\n\n    return node;\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(types.relational, 1);\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  toAssignableList(exprList) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if (!expr) continue;\n\n      switch (expr.type) {\n        case \"TSTypeCastExpression\":\n          exprList[i] = this.typeCastToParameter(expr);\n          break;\n\n        case \"TSAsExpression\":\n        case \"TSTypeAssertion\":\n          if (!this.state.maybeInArrowParameters) {\n            exprList[i] = this.typeCastToParameter(expr);\n          } else {\n            this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);\n          }\n\n          break;\n      }\n    }\n\n    return super.toAssignableList(...arguments);\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  toReferencedList(exprList, isInParens) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if (expr && expr.type === \"TSTypeCastExpression\") {\n        this.raise(expr.start, TSErrors.UnexpectedTypeAnnotation);\n      }\n    }\n\n    return exprList;\n  }\n\n  shouldParseArrow() {\n    return this.match(types.colon) || super.shouldParseArrow();\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.colon) || super.shouldParseAsyncArrow();\n  }\n\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const firstParam = method.params[0];\n    const hasContextParam = firstParam && firstParam.type === \"Identifier\" && firstParam.name === \"this\";\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n\n});\n\ntypes.placeholder = new TokenType(\"%%\", {\n  startsExpr: true\n});\nvar placeholders = (superClass => class extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(types.placeholder)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      this.expect(types.placeholder);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      return this.finishOp(types.placeholder, 2);\n    }\n\n    return super.getTokenFromCode(...arguments);\n  }\n\n  parseExprAtom() {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments);\n  }\n\n  parseIdentifier() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(...arguments);\n  }\n\n  checkReservedWord(word) {\n    if (word !== undefined) super.checkReservedWord(...arguments);\n  }\n\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments);\n  }\n\n  checkLVal(expr) {\n    if (expr.type !== \"Placeholder\") super.checkLVal(...arguments);\n  }\n\n  toAssignable(node) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n      return node;\n    }\n\n    return super.toAssignable(...arguments);\n  }\n\n  verifyBreakContinue(node) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(...arguments);\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type !== \"Placeholder\" || expr.extra && expr.extra.parenthesized) {\n      return super.parseExpressionStatement(...arguments);\n    }\n\n    if (this.match(types.colon)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = this.parseStatement(\"label\");\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n\n  parseBlock() {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(...arguments);\n  }\n\n  parseFunctionId() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(...arguments);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    this.takeDecorators(node);\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n\n    if (placeholder) {\n      if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        this.unexpected(null, \"A class name is required\");\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n\n    this.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || this.parseClassBody(!!node.superClass);\n    return this.finishNode(node, type);\n  }\n\n  parseExport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(...arguments);\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n      return true;\n    }\n\n    return super.maybeParseExportDefaultSpecifier(...arguments);\n  }\n\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n\n    if (specifiers && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(...arguments);\n    node.specifiers = [];\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    this.finishNode(specifier, \"ImportDefaultSpecifier\");\n    node.specifiers.push(specifier);\n\n    if (this.eat(types.comma)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n\n    this.expectContextual(\"from\");\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource(...arguments);\n  }\n\n});\n\nvar v8intrinsic = (superClass => class extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(types.modulo)) {\n      const v8IntrinsicStart = this.state.start;\n      const node = this.startNode();\n      this.eat(types.modulo);\n\n      if (this.match(types.name)) {\n        const name = this.parseIdentifierName(this.state.start);\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n\n        if (this.match(types.parenL)) {\n          return identifier;\n        }\n      }\n\n      this.unexpected(v8IntrinsicStart);\n    }\n  }\n\n  parseExprAtom() {\n    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);\n  }\n\n});\n\nfunction hasPlugin(plugins, name) {\n  return plugins.some(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin)) {\n    return plugin[1][option];\n  }\n\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"smart\", \"fsharp\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n\n    if (decoratorsBeforeExport == null) {\n      throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" + \" whose value must be a boolean. If you are migrating from\" + \" Babylon/Babel 6 or want to use the old decorators proposal, you\" + \" should use the 'decorators-legacy' plugin instead of 'decorators'.\");\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, \"pipelineOperator\", \"proposal\"))) {\n    throw new Error(\"'pipelineOperator' requires 'proposal' option whose value should be one of: \" + PIPELINE_PROPOSALS.map(p => `'${p}'`).join(\", \"));\n  }\n\n  if (hasPlugin(plugins, \"recordAndTuple\") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\n\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false\n};\nfunction getOptions(opts) {\n  const options = {};\n\n  for (let _i = 0, _Object$keys = Object.keys(defaultOptions); _i < _Object$keys.length; _i++) {\n    const key = _Object$keys[_i];\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n\n  return options;\n}\n\nclass State {\n  constructor() {\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.inParameters = false;\n    this.maybeInArrowParameters = false;\n    this.maybeInAsyncArrowHead = false;\n    this.inPipeline = false;\n    this.inType = false;\n    this.noAnonFunctionType = false;\n    this.inPropertyName = false;\n    this.hasFlowComment = false;\n    this.isIterator = false;\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.soloAwait = false;\n    this.inFSharpPipelineDirectBody = false;\n    this.labels = [];\n    this.decoratorStack = [[]];\n    this.yieldPos = -1;\n    this.awaitPos = -1;\n    this.comments = [];\n    this.trailingComments = [];\n    this.leadingComments = [];\n    this.commentStack = [];\n    this.commentPreviousNode = null;\n    this.pos = 0;\n    this.lineStart = 0;\n    this.type = types.eof;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.lastTokStart = 0;\n    this.lastTokEnd = 0;\n    this.context = [types$1.braceStatement];\n    this.exprAllowed = true;\n    this.containsEsc = false;\n    this.octalPositions = [];\n    this.exportedIdentifiers = [];\n    this.tokensLength = 0;\n  }\n\n  init(options) {\n    this.strict = options.strictMode === false ? false : options.sourceType === \"module\";\n    this.curLine = options.startLine;\n    this.startLoc = this.endLoc = this.curPosition();\n  }\n\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n\n  clone(skipArrays) {\n    const state = new State();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n\n    return state;\n  }\n\n}\n\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst VALID_REGEX_FLAGS = new Set([\"g\", \"m\", \"s\", \"i\", \"y\", \"u\"]);\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],\n  hex: [46, 88, 95, 120]\n};\nconst allowedNumericSeparatorSiblings = {};\nallowedNumericSeparatorSiblings.bin = [48, 49];\nallowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];\nallowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];\nallowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n}\nclass Tokenizer extends LocationParser {\n  constructor(options, input) {\n    super();\n    this.tokens = [];\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  next() {\n    if (!this.isLookahead) {\n      this.checkKeywordEscapes();\n\n      if (this.options.tokens) {\n        this.pushToken(new Token(this.state));\n      }\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  match(type) {\n    return this.state.type === type;\n  }\n\n  lookahead() {\n    const old = this.state;\n    this.state = old.clone(true);\n    this.isLookahead = true;\n    this.next();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart() {\n    const thisTokEnd = this.state.pos;\n    skipWhiteSpace.lastIndex = thisTokEnd;\n    const skip = skipWhiteSpace.exec(this.input);\n    return thisTokEnd + skip[0].length;\n  }\n\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (!this.match(types.num) && !this.match(types.string)) return;\n    this.state.pos = this.state.start;\n\n    while (this.state.pos < this.state.lineStart) {\n      this.state.lineStart = this.input.lastIndexOf(\"\\n\", this.state.lineStart - 2) + 1;\n      --this.state.curLine;\n    }\n\n    this.nextToken();\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  nextToken() {\n    const curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) this.skipSpace();\n    this.state.octalPositions = [];\n    this.state.start = this.state.pos;\n    this.state.startLoc = this.state.curPosition();\n\n    if (this.state.pos >= this.length) {\n      this.finishToken(types.eof);\n      return;\n    }\n\n    const override = curContext == null ? void 0 : curContext.override;\n\n    if (override) {\n      override(this);\n    } else {\n      this.getTokenFromCode(this.input.codePointAt(this.state.pos));\n    }\n  }\n\n  pushComment(block, text, start, end, startLoc, endLoc) {\n    const comment = {\n      type: block ? \"CommentBlock\" : \"CommentLine\",\n      value: text,\n      start: start,\n      end: end,\n      loc: new SourceLocation(startLoc, endLoc)\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    this.state.comments.push(comment);\n    this.addComment(comment);\n  }\n\n  skipBlockComment() {\n    const startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", this.state.pos + 2);\n    if (end === -1) throw this.raise(start, Errors.UnterminatedComment);\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start;\n    let match;\n\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {\n      ++this.state.curLine;\n      this.state.lineStart = match.index + match[0].length;\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipSpace() {\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              this.skipBlockComment();\n              break;\n\n            case 47:\n              this.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else {\n            break loop;\n          }\n\n      }\n    }\n  }\n\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) this.updateContext(prevType);\n  }\n\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.input.charCodeAt(nextPos);\n\n    if (next >= 48 && next <= 57) {\n      throw this.raise(this.state.pos, Errors.UnexpectedDigitAfterHash);\n    }\n\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"hash\") {\n        throw this.raise(this.state.pos, next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType);\n      }\n\n      if (next === 123) {\n        this.finishToken(types.braceHashL);\n      } else {\n        this.finishToken(types.bracketHashL);\n      }\n\n      this.state.pos += 2;\n    } else {\n      this.finishOp(types.hash, 1);\n    }\n  }\n\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(types.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.dot);\n    }\n  }\n\n  readToken_slash() {\n    if (this.state.exprAllowed && !this.state.inType) {\n      ++this.state.pos;\n      this.readRegexp();\n      return;\n    }\n\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.slash, 1);\n    }\n  }\n\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(types.interpreterDirective, value);\n    return true;\n  }\n\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? types.star : types.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    const exprAllowed = this.state.exprAllowed;\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = types.exponent;\n    }\n\n    if (next === 61 && !exprAllowed) {\n      width++;\n      type = types.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n      }\n\n      return;\n    }\n\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(types.pipeline, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, Errors.RecordExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.finishOp(types.braceBarR, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, Errors.TupleExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.finishOp(types.bracketBarR, 2);\n        return;\n      }\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n      return;\n    }\n\n    this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n  }\n\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos)))) {\n        this.skipLineComment(3);\n        this.skipSpace();\n        this.nextToken();\n        return;\n      }\n\n      this.finishOp(types.incDec, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.plusMin, 1);\n    }\n  }\n\n  readToken_lt_gt(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    let size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(this.state.pos + size) === 61) {\n        this.finishOp(types.assign, size + 1);\n        return;\n      }\n\n      this.finishOp(types.bitShift, size);\n      return;\n    }\n\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {\n      this.skipLineComment(4);\n      this.skipSpace();\n      this.nextToken();\n      return;\n    }\n\n    if (next === 61) {\n      size = 2;\n    }\n\n    this.finishOp(types.relational, size);\n  }\n\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(types.arrow);\n      return;\n    }\n\n    this.finishOp(code === 61 ? types.eq : types.bang, 1);\n  }\n\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 63 && !this.state.inType) {\n      if (next2 === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(types.nullishCoalescing, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(types.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.question);\n    }\n  }\n\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(types.parenL);\n        return;\n\n      case 41:\n        ++this.state.pos;\n        this.finishToken(types.parenR);\n        return;\n\n      case 59:\n        ++this.state.pos;\n        this.finishToken(types.semi);\n        return;\n\n      case 44:\n        ++this.state.pos;\n        this.finishToken(types.comma);\n        return;\n\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, Errors.TupleExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.finishToken(types.bracketBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.bracketL);\n        }\n\n        return;\n\n      case 93:\n        ++this.state.pos;\n        this.finishToken(types.bracketR);\n        return;\n\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, Errors.RecordExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.finishToken(types.braceBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.braceL);\n        }\n\n        return;\n\n      case 125:\n        ++this.state.pos;\n        this.finishToken(types.braceR);\n        return;\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(types.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.colon);\n        }\n\n        return;\n\n      case 63:\n        this.readToken_question();\n        return;\n\n      case 96:\n        ++this.state.pos;\n        this.finishToken(types.backQuote);\n        return;\n\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n\n      case 47:\n        this.readToken_slash();\n        return;\n\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case 94:\n        this.readToken_caret();\n        return;\n\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n\n      case 60:\n      case 62:\n        this.readToken_lt_gt(code);\n        return;\n\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n\n      case 126:\n        this.finishOp(types.tilde, 1);\n        return;\n\n      case 64:\n        ++this.state.pos;\n        this.finishToken(types.at);\n        return;\n\n      case 35:\n        this.readToken_numberSign();\n        return;\n\n      case 92:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord();\n          return;\n        }\n\n    }\n\n    throw this.raise(this.state.pos, Errors.InvalidOrUnexpectedToken, String.fromCodePoint(code));\n  }\n\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp() {\n    const start = this.state.pos;\n    let escaped, inClass;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(start, Errors.UnterminatedRegExp);\n      }\n\n      const ch = this.input.charAt(this.state.pos);\n\n      if (lineBreak.test(ch)) {\n        throw this.raise(start, Errors.UnterminatedRegExp);\n      }\n\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n\n        escaped = ch === \"\\\\\";\n      }\n\n      ++this.state.pos;\n    }\n\n    const content = this.input.slice(start, this.state.pos);\n    ++this.state.pos;\n    let mods = \"\";\n\n    while (this.state.pos < this.length) {\n      const char = this.input[this.state.pos];\n      const charCode = this.input.codePointAt(this.state.pos);\n\n      if (VALID_REGEX_FLAGS.has(char)) {\n        if (mods.indexOf(char) > -1) {\n          this.raise(this.state.pos + 1, Errors.DuplicateRegExpFlags);\n        }\n      } else if (isIdentifierChar(charCode) || charCode === 92) {\n        this.raise(this.state.pos + 1, Errors.MalformedRegExpFlags);\n      } else {\n        break;\n      }\n\n      ++this.state.pos;\n      mods += char;\n    }\n\n    this.finishToken(types.regexp, {\n      pattern: content,\n      flags: mods\n    });\n  }\n\n  readInt(radix, len, forceLen, allowNumSeparator = true) {\n    const start = this.state.pos;\n    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n    const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;\n    let invalid = false;\n    let total = 0;\n\n    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      const code = this.input.charCodeAt(this.state.pos);\n      let val;\n\n      if (this.hasPlugin(\"numericSeparator\")) {\n        if (code === 95) {\n          const prev = this.input.charCodeAt(this.state.pos - 1);\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (allowedSiblings.indexOf(next) === -1) {\n            this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);\n          } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {\n            this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);\n          }\n\n          if (!allowNumSeparator) {\n            this.raise(this.state.pos, Errors.NumericSeparatorInEscapeSequence);\n          }\n\n          ++this.state.pos;\n          continue;\n        }\n      }\n\n      if (code >= 97) {\n        val = code - 97 + 10;\n      } else if (code >= 65) {\n        val = code - 65 + 10;\n      } else if (_isDigit(code)) {\n        val = code - 48;\n      } else {\n        val = Infinity;\n      }\n\n      if (val >= radix) {\n        if (this.options.errorRecovery && val <= 9) {\n          val = 0;\n          this.raise(this.state.start + i + 2, Errors.InvalidDigit, radix);\n        } else if (forceLen) {\n          val = 0;\n          invalid = true;\n        } else {\n          break;\n        }\n      }\n\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n\n    if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {\n      return null;\n    }\n\n    return total;\n  }\n\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(this.state.start + 2, Errors.InvalidDigit, radix);\n    }\n\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 95) {\n      this.expectPlugin(\"numericSeparator\", this.state.pos);\n    }\n\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, Errors.NumberIdentifier);\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    this.finishToken(types.num, val);\n  }\n\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    let isFloat = false;\n    let isBigInt = false;\n    let isNonOctalDecimalInt = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, Errors.InvalidNumber);\n    }\n\n    let octal = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n    if (octal) {\n      if (this.state.strict) {\n        this.raise(start, Errors.StrictOctalLiteral);\n      }\n\n      if (/[89]/.test(this.input.slice(start, this.state.pos))) {\n        octal = false;\n        isNonOctalDecimalInt = true;\n      }\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 46 && !octal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !octal) {\n      next = this.input.charCodeAt(++this.state.pos);\n\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n\n      if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (this.hasPlugin(\"numericSeparator\") && (octal || isNonOctalDecimalInt)) {\n      const underscorePos = this.input.slice(start, this.state.pos).indexOf(\"_\");\n\n      if (underscorePos > 0) {\n        this.raise(underscorePos + start, Errors.ZeroDigitNumericSeparator);\n      }\n    }\n\n    if (next === 95) {\n      this.expectPlugin(\"numericSeparator\", this.state.pos);\n    }\n\n    if (next === 110) {\n      if (isFloat || octal || isNonOctalDecimalInt) {\n        this.raise(start, \"Invalid BigIntLiteral\");\n      }\n\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, Errors.NumberIdentifier);\n    }\n\n    const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    const val = octal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(types.num, val);\n  }\n\n  readCodePoint(throwOnInvalid) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let code;\n\n    if (ch === 123) {\n      const codePos = ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, true, throwOnInvalid);\n      ++this.state.pos;\n\n      if (code !== null && code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(codePos, Errors.InvalidCodePoint);\n        } else {\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, false, throwOnInvalid);\n    }\n\n    return code;\n  }\n\n  readString(quote) {\n    let out = \"\",\n        chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, Errors.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else if (ch === 8232 || ch === 8233) {\n        ++this.state.pos;\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        throw this.raise(this.state.start, Errors.UnterminatedString);\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(types.string, out);\n  }\n\n  readTmplToken() {\n    let out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, Errors.UnterminatedTemplate);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        if (this.state.pos === this.state.start && this.match(types.template)) {\n          if (ch === 36) {\n            this.state.pos += 2;\n            this.finishToken(types.dollarBraceL);\n            return;\n          } else {\n            ++this.state.pos;\n            this.finishToken(types.backQuote);\n            return;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(types.template, containsInvalid ? null : out);\n        return;\n      }\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        const escaped = this.readEscapedChar(true);\n\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) {\n              ++this.state.pos;\n            }\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  }\n\n  readEscapedChar(inTemplate) {\n    const throwOnInvalid = !inTemplate;\n    const ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n\n      case 114:\n        return \"\\r\";\n\n      case 120:\n        {\n          const code = this.readHexChar(2, false, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n\n      case 117:\n        {\n          const code = this.readCodePoint(throwOnInvalid);\n          return code === null ? null : String.fromCodePoint(code);\n        }\n\n      case 116:\n        return \"\\t\";\n\n      case 98:\n        return \"\\b\";\n\n      case 118:\n        return \"\\u000b\";\n\n      case 102:\n        return \"\\f\";\n\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) {\n          ++this.state.pos;\n        }\n\n      case 10:\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n\n      case 8232:\n      case 8233:\n        return \"\";\n\n      case 56:\n      case 57:\n        if (inTemplate) {\n          return null;\n        }\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          const codePos = this.state.pos - 1;\n          let octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];\n          let octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          this.state.pos += octalStr.length - 1;\n          const next = this.input.charCodeAt(this.state.pos);\n\n          if (octalStr !== \"0\" || next === 56 || next === 57) {\n            if (inTemplate) {\n              return null;\n            } else if (this.state.strict) {\n              this.raise(codePos, Errors.StrictOctalLiteral);\n            } else {\n              this.state.octalPositions.push(codePos);\n            }\n          }\n\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }\n\n  readHexChar(len, forceLen, throwOnInvalid) {\n    const codePos = this.state.pos;\n    const n = this.readInt(16, len, forceLen, false);\n\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, Errors.InvalidEscapeSequence);\n      } else {\n        this.state.pos = codePos - 1;\n      }\n    }\n\n    return n;\n  }\n\n  readWord1() {\n    let word = \"\";\n    this.state.containsEsc = false;\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n\n    while (this.state.pos < this.length) {\n      const ch = this.input.codePointAt(this.state.pos);\n\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (this.state.isIterator && ch === 64) {\n        ++this.state.pos;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.pos;\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(this.state.pos, Errors.MissingUnicodeEscape);\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(escStart, Errors.EscapedCharNotAnIdentifier);\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  isIterator(word) {\n    return word === \"@@iterator\" || word === \"@@asyncIterator\";\n  }\n\n  readWord() {\n    const word = this.readWord1();\n    const type = keywords.get(word) || types.name;\n\n    if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {\n      this.raise(this.state.pos, Errors.InvalidIdentifier, word);\n    }\n\n    this.finishToken(type, word);\n  }\n\n  checkKeywordEscapes() {\n    const kw = this.state.type.keyword;\n\n    if (kw && this.state.containsEsc) {\n      this.raise(this.state.start, Errors.InvalidEscapedReservedWord, kw);\n    }\n  }\n\n  braceIsBlock(prevType) {\n    const parent = this.curContext();\n\n    if (parent === types$1.functionExpression || parent === types$1.functionStatement) {\n      return true;\n    }\n\n    if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {\n      return !parent.isExpr;\n    }\n\n    if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {\n      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n    }\n\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {\n      return true;\n    }\n\n    if (prevType === types.braceL) {\n      return parent === types$1.braceStatement;\n    }\n\n    if (prevType === types._var || prevType === types._const || prevType === types.name) {\n      return false;\n    }\n\n    if (prevType === types.relational) {\n      return true;\n    }\n\n    return !this.state.exprAllowed;\n  }\n\n  updateContext(prevType) {\n    const type = this.state.type;\n    let update;\n\n    if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {\n      this.state.exprAllowed = false;\n    } else if (update = type.updateContext) {\n      update.call(this, prevType);\n    } else {\n      this.state.exprAllowed = type.beforeExpr;\n    }\n  }\n\n}\n\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, val) {\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n    extra[key] = val;\n  }\n\n  isRelational(op) {\n    return this.match(types.relational) && this.state.value === op;\n  }\n\n  isLookaheadRelational(op) {\n    const next = this.nextTokenStart();\n\n    if (this.input.charAt(next) === op) {\n      if (next + 1 === this.input.length) {\n        return true;\n      }\n\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== op.charCodeAt(0) && afterNext !== 61;\n    }\n\n    return false;\n  }\n\n  expectRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n    } else {\n      this.unexpected(null, types.relational);\n    }\n  }\n\n  isContextual(name) {\n    return this.match(types.name) && this.state.value === name && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));\n  }\n\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  eatContextual(name) {\n    return this.isContextual(name) && this.eat(types.name);\n  }\n\n  expectContextual(name, message) {\n    if (!this.eatContextual(name)) this.unexpected(null, message);\n  }\n\n  canInsertSemicolon() {\n    return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();\n  }\n\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n  }\n\n  isLineTerminator() {\n    return this.eat(types.semi) || this.canInsertSemicolon();\n  }\n\n  semicolon() {\n    if (!this.isLineTerminator()) this.unexpected(null, types.semi);\n  }\n\n  expect(type, pos) {\n    this.eat(type) || this.unexpected(pos, type);\n  }\n\n  assertNoSpace(message = \"Unexpected space.\") {\n    if (this.state.start > this.state.lastTokEnd) {\n      this.raise(this.state.lastTokEnd, message);\n    }\n  }\n\n  unexpected(pos, messageOrType = \"Unexpected token\") {\n    if (typeof messageOrType !== \"string\") {\n      messageOrType = `Unexpected token, expected \"${messageOrType.label}\"`;\n    }\n\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\n  }\n\n  expectPlugin(name, pos) {\n    if (!this.hasPlugin(name)) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: [name]\n      }, `This experimental syntax requires enabling the parser plugin: '${name}'`);\n    }\n\n    return true;\n  }\n\n  expectOnePlugin(names, pos) {\n    if (!names.some(n => this.hasPlugin(n))) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: names\n      }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(\", \")}'`);\n    }\n  }\n\n  checkYieldAwaitInDefaultParams() {\n    if (this.state.yieldPos !== -1 && (this.state.awaitPos === -1 || this.state.yieldPos < this.state.awaitPos)) {\n      this.raise(this.state.yieldPos, \"Yield cannot be used as name inside a generator function\");\n    }\n\n    if (this.state.awaitPos !== -1) {\n      this.raise(this.state.awaitPos, \"Await cannot be used as name inside an async function\");\n    }\n  }\n\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssign,\n      doubleProto\n    } = refExpressionErrors;\n    if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;\n\n    if (shorthandAssign >= 0) {\n      this.unexpected(shorthandAssign);\n    }\n\n    if (doubleProto >= 0) {\n      this.raise(doubleProto, Errors.DuplicateProto);\n    }\n  }\n\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssign = -1;\n    this.doubleProto = -1;\n  }\n\n}\n\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser && parser.options.ranges) this.range = [pos, 0];\n    if (parser && parser.filename) this.loc.filename = parser.filename;\n  }\n\n  __clone() {\n    const newNode = new Node();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  }\n\n}\n\nclass NodeUtils extends UtilParser {\n  startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt(pos, loc) {\n    return new Node(this, pos, loc);\n  }\n\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);\n  }\n\n  finishNodeAt(node, type, pos, loc) {\n\n    node.type = type;\n    node.end = pos;\n    node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    this.processComment(node);\n    return node;\n  }\n\n  resetStartLocation(node, start, startLoc) {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {\n    node.end = end;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = end;\n  }\n\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n\n}\n\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\n\nclass LValParser extends NodeUtils {\n  toAssignable(node) {\n    var _node$extra, _node$extra3;\n\n    let parenthesized = undefined;\n\n    if (node.type === \"ParenthesizedExpression\" || ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized)) {\n      parenthesized = unwrapParenthesizedExpression(node);\n\n      if (parenthesized.type !== \"Identifier\" && parenthesized.type !== \"MemberExpression\") {\n        this.raise(node.start, Errors.InvalidParenthesizedAssignment);\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast);\n\n          if (isLast && prop.type === \"RestElement\" && ((_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma)) {\n            this.raiseRestNotLast(node.extra.trailingComma);\n          }\n        }\n\n        break;\n\n      case \"ObjectProperty\":\n        this.toAssignable(node.value);\n        break;\n\n      case \"SpreadElement\":\n        {\n          this.checkToRestConversion(node);\n          node.type = \"RestElement\";\n          const arg = node.argument;\n          this.toAssignable(arg);\n          break;\n        }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(node.left.end, Errors.MissingEqInAssignment);\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized);\n        break;\n    }\n\n    return node;\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast) {\n    if (prop.type === \"ObjectMethod\") {\n      const error = prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod;\n      this.raise(prop.key.start, error);\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\n      this.raiseRestNotLast(prop.start);\n    } else {\n      this.toAssignable(prop);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaPos) {\n    let end = exprList.length;\n\n    if (end) {\n      const last = exprList[end - 1];\n\n      if (last && last.type === \"RestElement\") {\n        --end;\n      } else if (last && last.type === \"SpreadElement\") {\n        last.type = \"RestElement\";\n        const arg = last.argument;\n        this.toAssignable(arg);\n\n        if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\" && arg.type !== \"ObjectPattern\") {\n          this.unexpected(arg.start);\n        }\n\n        if (trailingCommaPos) {\n          this.raiseTrailingCommaAfterRest(trailingCommaPos);\n        }\n\n        --end;\n      }\n    }\n\n    for (let i = 0; i < end; i++) {\n      const elt = exprList[i];\n\n      if (elt) {\n        this.toAssignable(elt);\n\n        if (elt.type === \"RestElement\") {\n          this.raiseRestNotLast(elt.start);\n        }\n      }\n    }\n\n    return exprList;\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (let _i = 0; _i < exprList.length; _i++) {\n      const expr = exprList[_i];\n\n      if (expr && expr.type === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  parseSpread(refExpressionErrors, refNeedsArrowPos) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refExpressionErrors, undefined, refNeedsArrowPos);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types.bracketL:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(types.bracketR, 93, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n\n      case types.braceL:\n        return this.parseObj(types.braceR, true);\n    }\n\n    return this.parseIdentifier();\n  }\n\n  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n      }\n\n      if (allowEmpty && this.match(types.comma)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(types.ellipsis)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        this.checkCommaAfterRest(closeCharCode);\n        this.expect(close);\n        break;\n      } else {\n        const decorators = [];\n\n        if (this.match(types.at) && this.hasPlugin(\"decorators\")) {\n          this.raise(this.state.start, Errors.UnsupportedParameterDecorator);\n        }\n\n        while (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n        }\n\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n\n    return elts;\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseAssignableListItemTypes(param) {\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    startLoc = startLoc || this.state.startLoc;\n    startPos = startPos || this.state.start;\n    left = left || this.parseBindingAtom();\n    if (!this.eat(types.eq)) return left;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription, disallowLetBinding, strictModeChanged = false) {\n    switch (expr.type) {\n      case \"Identifier\":\n        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(expr.name, this.inModule) : isStrictBindOnlyReservedWord(expr.name))) {\n          this.raise(expr.start, bindingType === BIND_NONE ? Errors.StrictEvalArguments : Errors.StrictEvalArgumentsBinding, expr.name);\n        }\n\n        if (checkClashes) {\n          const key = `_${expr.name}`;\n\n          if (checkClashes[key]) {\n            this.raise(expr.start, Errors.ParamDupe);\n          } else {\n            checkClashes[key] = true;\n          }\n        }\n\n        if (disallowLetBinding && expr.name === \"let\") {\n          this.raise(expr.start, Errors.LetInLexicalBinding);\n        }\n\n        if (!(bindingType & BIND_NONE)) {\n          this.scope.declareName(expr.name, bindingType, expr.start);\n        }\n\n        break;\n\n      case \"MemberExpression\":\n        if (bindingType !== BIND_NONE) {\n          this.raise(expr.start, Errors.InvalidPropertyBindingPattern);\n        }\n\n        break;\n\n      case \"ObjectPattern\":\n        for (let _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {\n          let prop = _expr$properties[_i2];\n          if (prop.type === \"ObjectProperty\") prop = prop.value;else if (prop.type === \"ObjectMethod\") continue;\n          this.checkLVal(prop, bindingType, checkClashes, \"object destructuring pattern\", disallowLetBinding);\n        }\n\n        break;\n\n      case \"ArrayPattern\":\n        for (let _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {\n          const elem = _expr$elements[_i3];\n\n          if (elem) {\n            this.checkLVal(elem, bindingType, checkClashes, \"array destructuring pattern\", disallowLetBinding);\n          }\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, bindingType, checkClashes, \"assignment pattern\");\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, bindingType, checkClashes, \"rest element\");\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(expr.expression, bindingType, checkClashes, \"parenthesized expression\");\n        break;\n\n      default:\n        {\n          this.raise(expr.start, bindingType === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding, contextDescription);\n        }\n    }\n  }\n\n  checkToRestConversion(node) {\n    if (node.argument.type !== \"Identifier\" && node.argument.type !== \"MemberExpression\") {\n      this.raise(node.argument.start, Errors.InvalidRestAssignmentPattern);\n    }\n  }\n\n  checkCommaAfterRest(close) {\n    if (this.match(types.comma)) {\n      if (this.lookaheadCharCode() === close) {\n        this.raiseTrailingCommaAfterRest(this.state.start);\n      } else {\n        this.raiseRestNotLast(this.state.start);\n      }\n    }\n  }\n\n  raiseRestNotLast(pos) {\n    throw this.raise(pos, Errors.ElementAfterRest);\n  }\n\n  raiseTrailingCommaAfterRest(pos) {\n    this.raise(pos, Errors.RestTrailingComma);\n  }\n\n}\n\nclass ExpressionParser extends LValParser {\n  checkDuplicatedProto(prop, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || prop.computed || prop.kind || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n    if (name === \"__proto__\") {\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProto === -1) {\n            refExpressionErrors.doubleProto = key.start;\n          }\n        } else {\n          this.raise(key.start, Errors.DuplicateProto);\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  getExpression() {\n    let paramFlags = PARAM;\n\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n    this.nextToken();\n    const expr = this.parseExpression();\n\n    if (!this.match(types.eof)) {\n      this.unexpected();\n    }\n\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    return expr;\n  }\n\n  parseExpression(noIn, refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(noIn, refExpressionErrors);\n\n    if (this.match(types.comma)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(types.comma)) {\n        node.expressions.push(this.parseMaybeAssign(noIn, refExpressionErrors));\n      }\n\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    if (this.isContextual(\"yield\")) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield(noIn);\n\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n\n        return left;\n      } else {\n        this.state.exprAllowed = false;\n      }\n    }\n\n    let ownExpressionErrors;\n\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n\n    if (this.match(types.parenL) || this.match(types.name)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (this.state.type.isAssign) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (operator === \"??=\") {\n        this.expectPlugin(\"logicalAssignment\");\n      }\n\n      if (operator === \"||=\" || operator === \"&&=\") {\n        this.expectPlugin(\"logicalAssignment\");\n      }\n\n      if (this.match(types.eq)) {\n        node.left = this.toAssignable(left);\n        refExpressionErrors.doubleProto = -1;\n      } else {\n        node.left = left;\n      }\n\n      if (refExpressionErrors.shorthandAssign >= node.left.start) {\n        refExpressionErrors.shorthandAssign = -1;\n      }\n\n      this.checkLVal(left, undefined, undefined, \"assignment expression\");\n      this.next();\n      node.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(noIn, refExpressionErrors);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);\n  }\n\n  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n    if (this.eat(types.question)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprOps(noIn, refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnary(refExpressionErrors);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (this.checkExpressionErrors(refExpressionErrors, false)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    let prec = this.state.type.binop;\n\n    if (prec != null && (!noIn || !this.match(types._in))) {\n      if (prec > minPrec) {\n        const operator = this.state.value;\n\n        if (operator === \"|>\" && this.state.inFSharpPipelineDirectBody) {\n          return left;\n        }\n\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.left = left;\n        node.operator = operator;\n\n        if (operator === \"**\" && left.type === \"UnaryExpression\" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {\n          this.raise(left.argument.start, Errors.UnexpectedTokenUnaryExponentiation);\n        }\n\n        const op = this.state.type;\n        const logical = op === types.logicalOR || op === types.logicalAND;\n        const coalesce = op === types.nullishCoalescing;\n\n        if (op === types.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n          this.state.inPipeline = true;\n          this.checkPipelineAtInfixOperator(left, leftStartPos);\n        } else if (coalesce) {\n          prec = types.logicalAND.binop;\n        }\n\n        this.next();\n\n        if (op === types.pipeline && this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"minimal\") {\n          if (this.match(types.name) && this.state.value === \"await\" && this.prodParam.hasAwait) {\n            throw this.raise(this.state.start, Errors.UnexpectedAwaitAfterPipelineBody);\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec, noIn);\n        this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n\n        if (coalesce && (nextOp === types.logicalOR || nextOp === types.logicalAND) || logical && nextOp === types.nullishCoalescing) {\n          throw this.raise(this.state.start, Errors.MixingCoalesceWithLogical);\n        }\n\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n      }\n    }\n\n    return left;\n  }\n\n  parseExprOpRightExpr(op, prec, noIn) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    switch (op) {\n      case types.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"smart\":\n            return this.withTopicPermittingContext(() => {\n              return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec, noIn), startPos, startLoc);\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec, noIn);\n            });\n        }\n\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec, noIn);\n    }\n  }\n\n  parseExprOpBaseRightExpr(op, prec, noIn) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    if (this.isContextual(\"await\") && this.isAwaitAllowed()) {\n      return this.parseAwait();\n    } else if (this.state.type.prefix) {\n      const node = this.startNode();\n      const update = this.match(types.incDec);\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (node.operator === \"throw\") {\n        this.expectPlugin(\"throwExpressions\");\n      }\n\n      this.next();\n      node.argument = this.parseMaybeUnary();\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (update) {\n        this.checkLVal(node.argument, undefined, undefined, \"prefix operation\");\n      } else if (this.state.strict && node.operator === \"delete\") {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(node.start, Errors.StrictDelete);\n        } else if (arg.type === \"MemberExpression\" && arg.property.type === \"PrivateName\") {\n          this.raise(node.start, Errors.DeletePrivateField);\n        }\n      }\n\n      return this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n\n    while (this.state.type.postfix && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.checkLVal(expr, undefined, undefined, \"postfix operation\");\n      this.next();\n      expr = this.finishNode(node, \"UpdateExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprSubscripts(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n\n    do {\n      const oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;\n\n      if (state.maybeAsyncArrow) {\n        this.state.maybeInAsyncArrowHead = true;\n      }\n\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n      this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;\n    } while (!state.stop);\n\n    return base;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!noCalls && this.eat(types.doubleColon)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.callee = this.parseNoCallExpr();\n      state.stop = true;\n      return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startPos, startLoc, noCalls);\n    }\n\n    let optional = false;\n\n    if (this.match(types.questionDot)) {\n      state.optionalChainMember = optional = true;\n\n      if (noCalls && this.lookaheadCharCode() === 40) {\n        state.stop = true;\n        return base;\n      }\n\n      this.next();\n    }\n\n    const computed = this.eat(types.bracketL);\n\n    if (optional && !this.match(types.parenL) && !this.match(types.backQuote) || computed || this.eat(types.dot)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this.parseExpression() : optional ? this.parseIdentifier(true) : this.parseMaybePrivateName(true);\n      node.computed = computed;\n\n      if (node.property.type === \"PrivateName\") {\n        if (node.object.type === \"Super\") {\n          this.raise(startPos, Errors.SuperPrivateField);\n        }\n\n        this.classScope.usePrivateName(node.property.id.name, node.property.start);\n      }\n\n      if (computed) {\n        this.expect(types.bracketR);\n      }\n\n      if (state.optionalChainMember) {\n        node.optional = optional;\n        return this.finishNode(node, \"OptionalMemberExpression\");\n      } else {\n        return this.finishNode(node, \"MemberExpression\");\n      }\n    } else if (!noCalls && this.match(types.parenL)) {\n      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n      const oldYieldPos = this.state.yieldPos;\n      const oldAwaitPos = this.state.awaitPos;\n      this.state.maybeInArrowParameters = true;\n      this.state.yieldPos = -1;\n      this.state.awaitPos = -1;\n      this.next();\n      let node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n\n      if (optional) {\n        node.optional = true;\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      } else {\n        node.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === \"Import\", base.type !== \"Super\", node);\n      }\n\n      this.finishCallExpression(node, state.optionalChainMember);\n\n      if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n        state.stop = true;\n        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);\n        this.checkYieldAwaitInDefaultParams();\n        this.state.yieldPos = oldYieldPos;\n        this.state.awaitPos = oldAwaitPos;\n      } else {\n        this.toReferencedListDeep(node.arguments);\n        if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;\n\n        if (!this.isAwaitAllowed() && !oldMaybeInArrowParameters || oldAwaitPos !== -1) {\n          this.state.awaitPos = oldAwaitPos;\n        }\n      }\n\n      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n      return node;\n    } else if (this.match(types.backQuote)) {\n      return this.parseTaggedTemplateExpression(startPos, startLoc, base, state);\n    } else {\n      state.stop = true;\n      return base;\n    }\n  }\n\n  parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (typeArguments) node.typeParameters = typeArguments;\n\n    if (state.optionalChainMember) {\n      this.raise(startPos, Errors.OptionalChainingNoTemplate);\n    }\n\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length !== 1) {\n        this.raise(node.start, Errors.ImportCallArity);\n      } else {\n        const importArg = node.arguments[0];\n\n        if (importArg && importArg.type === \"SpreadElement\") {\n          this.raise(importArg.start, Errors.ImportCallSpreadArgument);\n        }\n      }\n    }\n\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n\n  parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {\n    const elts = [];\n    let innerParenStart;\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (dynamicImport) {\n            this.raise(this.state.lastTokStart, Errors.ImportCallArgumentTrailingComma);\n          }\n\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      if (this.match(types.parenL) && !innerParenStart) {\n        innerParenStart = this.state.start;\n      }\n\n      elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : undefined, possibleAsyncArrow ? {\n        start: 0\n      } : undefined, allowPlaceholder));\n    }\n\n    if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {\n      this.unexpected();\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n\n    this.expect(types.arrow);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);\n    return node;\n  }\n\n  parseNoCallExpr() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.state.type === types.slash) this.readRegexp();\n    const canBeArrow = this.state.potentialArrowAt === this.state.start;\n    let node;\n\n    switch (this.state.type) {\n      case types._super:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n          this.raise(node.start, Errors.SuperNotAllowed);\n        } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n          this.raise(node.start, Errors.UnexpectedSuper);\n        }\n\n        if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {\n          this.raise(node.start, Errors.UnsupportedSuper);\n        }\n\n        return this.finishNode(node, \"Super\");\n\n      case types._import:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(types.dot)) {\n          return this.parseImportMetaProperty(node);\n        }\n\n        if (!this.match(types.parenL)) {\n          this.raise(this.state.lastTokStart, Errors.UnsupportedImport);\n        }\n\n        return this.finishNode(node, \"Import\");\n\n      case types._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case types.name:\n        {\n          node = this.startNode();\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (!containsEsc && id.name === \"async\" && this.match(types._function) && !this.canInsertSemicolon()) {\n            const last = this.state.context.length - 1;\n\n            if (this.state.context[last] !== types$1.functionStatement) {\n              throw new Error(\"Internal error\");\n            }\n\n            this.state.context[last] = types$1.functionExpression;\n            this.next();\n            return this.parseFunction(node, undefined, true);\n          } else if (canBeArrow && !containsEsc && id.name === \"async\" && this.match(types.name) && !this.canInsertSemicolon()) {\n            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n            const oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;\n            const oldYieldPos = this.state.yieldPos;\n            const oldAwaitPos = this.state.awaitPos;\n            this.state.maybeInArrowParameters = true;\n            this.state.maybeInAsyncArrowHead = true;\n            this.state.yieldPos = -1;\n            this.state.awaitPos = -1;\n            const params = [this.parseIdentifier()];\n            this.expect(types.arrow);\n            this.checkYieldAwaitInDefaultParams();\n            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n            this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;\n            this.state.yieldPos = oldYieldPos;\n            this.state.awaitPos = oldAwaitPos;\n            this.parseArrowExpression(node, params, true);\n            return node;\n          }\n\n          if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {\n            this.next();\n            this.parseArrowExpression(node, [id], false);\n            return node;\n          }\n\n          return id;\n        }\n\n      case types._do:\n        {\n          this.expectPlugin(\"doExpressions\");\n          const node = this.startNode();\n          this.next();\n          const oldLabels = this.state.labels;\n          this.state.labels = [];\n          node.body = this.parseBlock();\n          this.state.labels = oldLabels;\n          return this.finishNode(node, \"DoExpression\");\n        }\n\n      case types.regexp:\n        {\n          const value = this.state.value;\n          node = this.parseLiteral(value.value, \"RegExpLiteral\");\n          node.pattern = value.pattern;\n          node.flags = value.flags;\n          return node;\n        }\n\n      case types.num:\n        return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n      case types.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteral\");\n\n      case types.string:\n        return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n      case types._null:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"NullLiteral\");\n\n      case types._true:\n      case types._false:\n        return this.parseBooleanLiteral();\n\n      case types.parenL:\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n\n      case types.bracketBarL:\n      case types.bracketHashL:\n        {\n          this.expectPlugin(\"recordAndTuple\");\n          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n          const close = this.state.type === types.bracketBarL ? types.bracketBarR : types.bracketR;\n          this.state.inFSharpPipelineDirectBody = false;\n          node = this.startNode();\n          this.next();\n          node.elements = this.parseExprList(close, true, refExpressionErrors, node);\n          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n          return this.finishNode(node, \"TupleExpression\");\n        }\n\n      case types.bracketL:\n        {\n          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n          this.state.inFSharpPipelineDirectBody = false;\n          node = this.startNode();\n          this.next();\n          node.elements = this.parseExprList(types.bracketR, true, refExpressionErrors, node);\n\n          if (!this.state.maybeInArrowParameters) {\n            this.toReferencedList(node.elements);\n          }\n\n          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n          return this.finishNode(node, \"ArrayExpression\");\n        }\n\n      case types.braceBarL:\n      case types.braceHashL:\n        {\n          this.expectPlugin(\"recordAndTuple\");\n          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n          const close = this.state.type === types.braceBarL ? types.braceBarR : types.braceR;\n          this.state.inFSharpPipelineDirectBody = false;\n          const ret = this.parseObj(close, false, true, refExpressionErrors);\n          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n          return ret;\n        }\n\n      case types.braceL:\n        {\n          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n          this.state.inFSharpPipelineDirectBody = false;\n          const ret = this.parseObj(types.braceR, false, false, refExpressionErrors);\n          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n          return ret;\n        }\n\n      case types._function:\n        return this.parseFunctionExpression();\n\n      case types.at:\n        this.parseDecorators();\n\n      case types._class:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case types._new:\n        return this.parseNew();\n\n      case types.backQuote:\n        return this.parseTemplate(false);\n\n      case types.doubleColon:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(callee.start, Errors.UnsupportedBind);\n          }\n        }\n\n      case types.hash:\n        {\n          if (this.state.inPipeline) {\n            node = this.startNode();\n\n            if (this.getPluginOption(\"pipelineOperator\", \"proposal\") !== \"smart\") {\n              this.raise(node.start, Errors.PrimaryTopicRequiresSmartPipeline);\n            }\n\n            this.next();\n\n            if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {\n              this.raise(node.start, Errors.PrimaryTopicNotAllowed);\n            }\n\n            this.registerTopicReference();\n            return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n          }\n        }\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseBooleanLiteral() {\n    const node = this.startNode();\n    node.value = this.match(types._true);\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseMaybePrivateName(isPrivateNameAllowed) {\n    const isPrivate = this.match(types.hash);\n\n    if (isPrivate) {\n      this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]);\n\n      if (!isPrivateNameAllowed) {\n        this.raise(this.state.pos, Errors.UnexpectedPrivateField);\n      }\n\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space between # and identifier\");\n      node.id = this.parseIdentifier(true);\n      return this.finishNode(node, \"PrivateName\");\n    } else {\n      return this.parseIdentifier(true);\n    }\n  }\n\n  parseFunctionExpression() {\n    const node = this.startNode();\n    let meta = this.startNode();\n    this.next();\n    meta = this.createIdentifier(meta, \"function\");\n\n    if (this.prodParam.hasYield && this.eat(types.dot)) {\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n\n    return this.parseFunction(node);\n  }\n\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n\n    if (meta.name === \"function\" && propertyName === \"sent\") {\n      if (this.isContextual(propertyName)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n    }\n\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(node.property.start, Errors.UnsupportedMetaProperty, meta.name, propertyName);\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.expect(types.dot);\n\n    if (this.isContextual(\"meta\")) {\n      this.expectPlugin(\"importMeta\");\n\n      if (!this.inModule) {\n        this.raiseWithData(id.start, {\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n        }, Errors.ImportMetaOutsideModule);\n      }\n\n      this.sawUnambiguousESM = true;\n    } else if (!this.hasPlugin(\"importMeta\")) {\n      this.raise(id.start, Errors.ImportCallArityLtOne);\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    const node = this.startNodeAt(startPos, startLoc);\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let val;\n    this.expect(types.parenL);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    const refNeedsArrowPos = {\n      start: 0\n    };\n    let first = true;\n    let spreadStart;\n    let optionalCommaStart;\n\n    while (!this.match(types.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma, refNeedsArrowPos.start || null);\n\n        if (this.match(types.parenR)) {\n          optionalCommaStart = this.state.start;\n          break;\n        }\n      }\n\n      if (this.match(types.ellipsis)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStart = this.state.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));\n        this.checkCommaAfterRest(41);\n        break;\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refExpressionErrors, this.parseParenItem, refNeedsArrowPos));\n      }\n    }\n\n    const innerEndPos = this.state.start;\n    const innerEndLoc = this.state.startLoc;\n    this.expect(types.parenR);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startPos, startLoc);\n\n    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {\n      if (!this.isAwaitAllowed() && !this.state.maybeInAsyncArrowHead) {\n        this.state.awaitPos = oldAwaitPos;\n      }\n\n      this.checkYieldAwaitInDefaultParams();\n      this.state.yieldPos = oldYieldPos;\n      this.state.awaitPos = oldAwaitPos;\n\n      for (let _i = 0; _i < exprList.length; _i++) {\n        const param = exprList[_i];\n\n        if (param.extra && param.extra.parenthesized) {\n          this.unexpected(param.extra.parenStart);\n        }\n      }\n\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n\n    if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;\n    if (oldAwaitPos !== -1) this.state.awaitPos = oldAwaitPos;\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStart);\n    }\n\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\n    if (spreadStart) this.unexpected(spreadStart);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\n    this.toReferencedListDeep(exprList, true);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(val, \"parenthesized\", true);\n      this.addExtra(val, \"parenStart\", startPos);\n      return val;\n    }\n\n    const parenExpression = this.startNodeAt(startPos, startLoc);\n    parenExpression.expression = val;\n    this.finishNode(parenExpression, \"ParenthesizedExpression\");\n    return parenExpression;\n  }\n\n  shouldParseArrow() {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(node) {\n    if (this.eat(types.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    return node;\n  }\n\n  parseNew() {\n    const node = this.startNode();\n    let meta = this.startNode();\n    this.next();\n    meta = this.createIdentifier(meta, \"new\");\n\n    if (this.eat(types.dot)) {\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        let error = Errors.UnexpectedNewTarget;\n\n        if (this.hasPlugin(\"classProperties\")) {\n          error += \" or class properties\";\n        }\n\n        this.raise(metaProp.start, error);\n      }\n\n      return metaProp;\n    }\n\n    node.callee = this.parseNoCallExpr();\n\n    if (node.callee.type === \"Import\") {\n      this.raise(node.callee.start, Errors.ImportCallNotNewExpression);\n    } else if (node.callee.type === \"OptionalMemberExpression\" || node.callee.type === \"OptionalCallExpression\") {\n      this.raise(this.state.lastTokEnd, Errors.OptionalChainingNoNew);\n    } else if (this.eat(types.questionDot)) {\n      this.raise(this.state.start, Errors.OptionalChainingNoNew);\n    }\n\n    this.parseNewArguments(node);\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewArguments(node) {\n    if (this.eat(types.parenL)) {\n      const args = this.parseExprList(types.parenR);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n  }\n\n  parseTemplateElement(isTagged) {\n    const elem = this.startNode();\n\n    if (this.state.value === null) {\n      if (!isTagged) {\n        this.raise(this.state.start + 1, Errors.InvalidEscapeSequenceTemplate);\n      }\n    }\n\n    elem.value = {\n      raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.state.value\n    };\n    this.next();\n    elem.tail = this.match(types.backQuote);\n    return this.finishNode(elem, \"TemplateElement\");\n  }\n\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    this.next();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  parseObj(close, isPattern, isRecord, refExpressionErrors) {\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n          this.next();\n          break;\n        }\n      }\n\n      const prop = this.parseObjectMember(isPattern, refExpressionErrors);\n\n      if (!isPattern) {\n        this.checkDuplicatedProto(prop, propHash, refExpressionErrors);\n      }\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    let type = \"ObjectExpression\";\n\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n\n    return this.finishNode(node, type);\n  }\n\n  isAsyncProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.match(types.name) || this.match(types.num) || this.match(types.string) || this.match(types.bracketL) || this.state.type.keyword || this.match(types.star)) && !this.hasPrecedingLineBreak();\n  }\n\n  parseObjectMember(isPattern, refExpressionErrors) {\n    let decorators = [];\n\n    if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(this.state.start, Errors.UnsupportedPropertyDecorator);\n      }\n\n      while (this.match(types.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode();\n    let isGenerator = false;\n    let isAsync = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(types.ellipsis)) {\n      if (decorators.length) this.unexpected();\n\n      if (isPattern) {\n        this.next();\n        prop.argument = this.parseIdentifier();\n        this.checkCommaAfterRest(125);\n        return this.finishNode(prop, \"RestElement\");\n      }\n\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (isPattern || refExpressionErrors) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(types.star);\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.parsePropertyName(prop, false);\n\n    if (!isPattern && !containsEsc && !isGenerator && this.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.eat(types.star);\n      this.parsePropertyName(prop, false);\n    } else {\n      isAsync = false;\n    }\n\n    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc);\n    return prop;\n  }\n\n  isGetterOrSetterMethod(prop, isPattern) {\n    return !isPattern && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && (this.match(types.string) || this.match(types.num) || this.match(types.bracketL) || this.match(types.name) || !!this.state.type.keyword);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  checkGetterSetterParams(method) {\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const start = method.start;\n\n    if (method.params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, Errors.BadGetterArity);\n      } else {\n        this.raise(start, Errors.BadSetterArity);\n      }\n    }\n\n    if (method.kind === \"set\" && method.params[method.params.length - 1].type === \"RestElement\") {\n      this.raise(start, Errors.BadSetterRestParameter);\n    }\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {\n    if (isAsync || isGenerator || this.match(types.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n\n    if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {\n      if (isGenerator || isAsync) this.unexpected();\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop, false);\n      this.parseMethod(prop, false, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(prop);\n      return prop;\n    }\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.start, true, true);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else if (this.match(types.eq) && refExpressionErrors) {\n        if (refExpressionErrors.shorthandAssign === -1) {\n          refExpressionErrors.shorthandAssign = this.state.start;\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else {\n        prop.value = prop.key.__clone();\n      }\n\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n\n  parsePropertyName(prop, isPrivateNameAllowed) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n    } else {\n      const oldInPropertyName = this.state.inPropertyName;\n      this.state.inPropertyName = true;\n      prop.key = this.match(types.num) || this.match(types.string) || this.match(types.bigint) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);\n\n      if (prop.key.type !== \"PrivateName\") {\n        prop.computed = false;\n      }\n\n      this.state.inPropertyName = oldInPropertyName;\n    }\n\n    return prop.key;\n  }\n\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor;\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, allowModifiers);\n    this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.yieldPos = oldYieldPos;\n    this.state.awaitPos = oldAwaitPos;\n    return node;\n  }\n\n  parseArrowExpression(node, params, isAsync, trailingCommaPos) {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    this.prodParam.enter(functionFlags(isAsync, false));\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaPos);\n    }\n\n    this.state.maybeInArrowParameters = false;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.yieldPos = oldYieldPos;\n    this.state.awaitPos = oldAwaitPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(node, params, trailingCommaPos) {\n    node.params = this.toAssignableList(params, trailingCommaPos);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    this.finishNode(node, type);\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(types.braceL);\n    const oldInParameters = this.state.inParameters;\n    this.state.inParameters = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n\n        if (hasStrictModeDirective && nonSimple) {\n          const errorPos = (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.end : node.start;\n          this.raise(errorPos, Errors.IllegalLanguageModeDirective);\n        }\n\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n\n        if (this.state.strict && node.id) {\n          this.checkLVal(node.id, BIND_OUTSIDE, undefined, \"function name\", undefined, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n\n    this.state.inParameters = oldInParameters;\n  }\n\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (params[i].type !== \"Identifier\") return false;\n    }\n\n    return true;\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const nameHash = Object.create(null);\n\n    for (let i = 0; i < node.params.length; i++) {\n      this.checkLVal(node.params[i], BIND_VAR, allowDuplicates ? null : nameHash, \"function parameter list\", undefined, strictModeChanged);\n    }\n  }\n\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n\n    return elts;\n  }\n\n  parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {\n    let elt;\n\n    if (allowEmpty && this.match(types.comma)) {\n      elt = null;\n    } else if (this.match(types.ellipsis)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);\n    } else if (this.match(types.question)) {\n      this.expectPlugin(\"partialApplication\");\n\n      if (!allowPlaceholder) {\n        this.raise(this.state.start, Errors.UnexpectedArgumentPlaceholder);\n      }\n\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssign(false, refExpressionErrors, this.parseParenItem, refNeedsArrowPos);\n    }\n\n    return elt;\n  }\n\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(node.start, liberal);\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos, liberal) {\n    let name;\n\n    if (this.match(types.name)) {\n      name = this.state.value;\n    } else if (this.state.type.keyword) {\n      name = this.state.type.keyword;\n      const context = this.state.context;\n\n      if ((name === \"class\" || name === \"function\") && context[context.length - 1].token === \"function\") {\n        context.pop();\n      }\n    } else {\n      throw this.unexpected();\n    }\n\n    if (liberal) {\n      this.state.type = types.name;\n    } else {\n      this.checkReservedWord(name, this.state.start, !!this.state.type.keyword, false);\n    }\n\n    this.next();\n    return name;\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (this.prodParam.hasYield && word === \"yield\") {\n      this.raise(startLoc, Errors.YieldBindingIdentifier);\n      return;\n    }\n\n    if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(startLoc, Errors.AwaitBindingIdentifier);\n        return;\n      }\n\n      if (this.state.awaitPos === -1 && (this.state.maybeInAsyncArrowHead || this.isAwaitAllowed())) {\n        this.state.awaitPos = this.state.start;\n      }\n    }\n\n    if (this.scope.inClass && !this.scope.inNonArrowFunction && word === \"arguments\") {\n      this.raise(startLoc, Errors.ArgumentsDisallowedInInitializer);\n      return;\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(startLoc, Errors.UnexpectedKeyword, word);\n      return;\n    }\n\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      if (!this.prodParam.hasAwait && word === \"await\") {\n        this.raise(startLoc, Errors.AwaitNotInAsyncFunction);\n      } else {\n        this.raise(startLoc, Errors.UnexpectedReservedWord, word);\n      }\n    }\n  }\n\n  isAwaitAllowed() {\n    if (this.scope.inFunction) return this.prodParam.hasAwait;\n    if (this.options.allowAwaitOutsideFunction) return true;\n\n    if (this.hasPlugin(\"topLevelAwait\")) {\n      return this.inModule && this.prodParam.hasAwait;\n    }\n\n    return false;\n  }\n\n  parseAwait() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.state.inParameters) {\n      this.raise(node.start, Errors.AwaitExpressionFormalParameter);\n    } else if (this.state.awaitPos === -1) {\n      this.state.awaitPos = node.start;\n    }\n\n    if (this.eat(types.star)) {\n      this.raise(node.start, Errors.ObsoleteAwaitStar);\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin(\"v8intrinsic\") && this.match(types.modulo)) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary();\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  parseYield(noIn) {\n    const node = this.startNode();\n\n    if (this.state.inParameters) {\n      this.raise(node.start, Errors.YieldInParameter);\n    } else if (this.state.yieldPos === -1) {\n      this.state.yieldPos = node.start;\n    }\n\n    this.next();\n\n    if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign(noIn);\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  checkPipelineAtInfixOperator(left, leftStartPos) {\n    if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(leftStartPos, Errors.PipelineHeadSequenceExpression);\n      }\n    }\n  }\n\n  parseSmartPipelineBody(childExpression, startPos, startLoc) {\n    const pipelineStyle = this.checkSmartPipelineBodyStyle(childExpression);\n    this.checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos);\n    return this.parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc);\n  }\n\n  checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos) {\n    if (this.match(types.arrow)) {\n      throw this.raise(this.state.start, Errors.PipelineBodyNoArrow);\n    } else if (pipelineStyle === \"PipelineTopicExpression\" && childExpression.type === \"SequenceExpression\") {\n      this.raise(startPos, Errors.PipelineBodySequenceExpression);\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc) {\n    const bodyNode = this.startNodeAt(startPos, startLoc);\n\n    switch (pipelineStyle) {\n      case \"PipelineBareFunction\":\n        bodyNode.callee = childExpression;\n        break;\n\n      case \"PipelineBareConstructor\":\n        bodyNode.callee = childExpression.callee;\n        break;\n\n      case \"PipelineBareAwaitedFunction\":\n        bodyNode.callee = childExpression.argument;\n        break;\n\n      case \"PipelineTopicExpression\":\n        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {\n          this.raise(startPos, Errors.PipelineTopicUnused);\n        }\n\n        bodyNode.expression = childExpression;\n        break;\n\n      default:\n        throw new Error(`Internal @babel/parser error: Unknown pipeline style (${pipelineStyle})`);\n    }\n\n    return this.finishNode(bodyNode, pipelineStyle);\n  }\n\n  checkSmartPipelineBodyStyle(expression) {\n    switch (expression.type) {\n      default:\n        return this.isSimpleReference(expression) ? \"PipelineBareFunction\" : \"PipelineTopicExpression\";\n    }\n  }\n\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n\n      case \"Identifier\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  withTopicPermittingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withTopicForbiddingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  primaryTopicReferenceIsAllowedInCurrentTopicContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentTopicContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n\n  parseFSharpPipelineBody(prec, noIn) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n\n}\n\nconst loopLabel = {\n  kind: \"loop\"\n},\n      switchLabel = {\n  kind: \"switch\"\n};\nconst FUNC_NO_FLAGS = 0b000,\n      FUNC_STATEMENT = 0b001,\n      FUNC_HANGING_STATEMENT = 0b010,\n      FUNC_NULLABLE_ID = 0b100;\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    program.sourceType = this.options.sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, types.eof);\n\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (let _i = 0, _Array$from = Array.from(this.scope.undefinedExports); _i < _Array$from.length; _i++) {\n        const [name] = _Array$from[_i];\n        const pos = this.scope.undefinedExports.get(name);\n        this.raise(pos, Errors.ModuleExportUndefined, name);\n      }\n    }\n\n    file.program = this.finishNode(program, \"Program\");\n    file.comments = this.state.comments;\n    if (this.options.tokens) file.tokens = this.tokens;\n    return this.finishNode(file, \"File\");\n  }\n\n  stmtToDirective(stmt) {\n    const expr = stmt.expression;\n    const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\n    const directive = this.startNodeAt(stmt.start, stmt.loc.start);\n    const raw = this.input.slice(expr.start, expr.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    directive.value = this.finishNodeAt(directiveLiteral, \"DirectiveLiteral\", expr.end, expr.loc.end);\n    return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\n  }\n\n  parseInterpreterDirective() {\n    if (!this.match(types.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context) {\n    if (!this.isContextual(\"let\")) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const nextCh = this.input.charCodeAt(next);\n    if (nextCh === 91) return true;\n    if (context) return false;\n    if (nextCh === 123) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      let pos = next + 1;\n\n      while (isIdentifierChar(this.input.charCodeAt(pos))) {\n        ++pos;\n      }\n\n      const ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) return true;\n    }\n\n    return false;\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.match(types.at)) {\n      this.parseDecorators(true);\n    }\n\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(context, topLevel) {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case types._break:\n      case types._continue:\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n\n      case types._debugger:\n        return this.parseDebuggerStatement(node);\n\n      case types._do:\n        return this.parseDoStatement(node);\n\n      case types._for:\n        return this.parseForStatement(node);\n\n      case types._function:\n        if (this.lookaheadCharCode() === 46) break;\n\n        if (context) {\n          if (this.state.strict) {\n            this.raise(this.state.start, Errors.StrictFunction);\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(this.state.start, Errors.SloppyFunction);\n          }\n        }\n\n        return this.parseFunctionStatement(node, false, !context);\n\n      case types._class:\n        if (context) this.unexpected();\n        return this.parseClass(node, true);\n\n      case types._if:\n        return this.parseIfStatement(node);\n\n      case types._return:\n        return this.parseReturnStatement(node);\n\n      case types._switch:\n        return this.parseSwitchStatement(node);\n\n      case types._throw:\n        return this.parseThrowStatement(node);\n\n      case types._try:\n        return this.parseTryStatement(node);\n\n      case types._const:\n      case types._var:\n        kind = kind || this.state.value;\n\n        if (context && kind !== \"var\") {\n          this.raise(this.state.start, Errors.UnexpectedLexicalDeclaration);\n        }\n\n        return this.parseVarStatement(node, kind);\n\n      case types._while:\n        return this.parseWhileStatement(node);\n\n      case types._with:\n        return this.parseWithStatement(node);\n\n      case types.braceL:\n        return this.parseBlock();\n\n      case types.semi:\n        return this.parseEmptyStatement(node);\n\n      case types._export:\n      case types._import:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(this.state.start, Errors.UnexpectedImportExport);\n          }\n\n          this.next();\n          let result;\n\n          if (starttype === types._import) {\n            result = this.parseImport(node);\n\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node);\n\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n\n          this.assertModuleNodeAllowed(node);\n          return result;\n        }\n\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (context) {\n              this.raise(this.state.start, Errors.AsyncFunctionInSingleStatementContext);\n            }\n\n            this.next();\n            return this.parseFunctionStatement(node, true, !context);\n          }\n        }\n    }\n\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raiseWithData(node.start, {\n        code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n      }, Errors.ImportOutsideModule);\n    }\n  }\n\n  takeDecorators(node) {\n    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator() {\n    return this.match(types._class);\n  }\n\n  parseDecorators(allowExport) {\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    while (this.match(types.at)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(types._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (this.hasPlugin(\"decorators\") && !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, Errors.DecoratorExportClass);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(this.state.start, Errors.UnexpectedLeadingDecorator);\n    }\n  }\n\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n    const node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      this.state.decoratorStack.push([]);\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr;\n\n      if (this.eat(types.parenL)) {\n        expr = this.parseExpression();\n        this.expect(types.parenR);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(types.dot)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(types.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(node, keyword) {\n    const isBreak = keyword === \"break\";\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, keyword);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n\n  verifyBreakContinue(node, keyword) {\n    const isBreak = keyword === \"break\";\n    let i;\n\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.state.labels.length) {\n      this.raise(node.start, Errors.IllegalBreakContinue, keyword);\n    }\n  }\n\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression() {\n    this.expect(types.parenL);\n    const val = this.parseExpression();\n    this.expect(types.parenR);\n    return val;\n  }\n\n  parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"do\"));\n    this.state.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(types.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = -1;\n\n    if (this.isAwaitAllowed() && this.eatContextual(\"await\")) {\n      awaitAt = this.state.lastTokStart;\n    }\n\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.parenL);\n\n    if (this.match(types.semi)) {\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    const isLet = this.isLet();\n\n    if (this.match(types._var) || this.match(types._const) || isLet) {\n      const init = this.startNode();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(init, true, kind);\n      this.finishNode(init, \"VariableDeclaration\");\n\n      if ((this.match(types._in) || this.isContextual(\"of\")) && init.declarations.length === 1) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, init);\n    }\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n\n    if (this.match(types._in) || this.isContextual(\"of\")) {\n      this.toAssignable(init);\n      const description = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n      this.checkLVal(init, undefined, undefined, description);\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init);\n  }\n\n  parseFunctionStatement(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);\n  }\n\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.state.start, Errors.IllegalReturn);\n    }\n\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(types.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n    let cur;\n\n    for (let sawDefault; !this.match(types.braceR);) {\n      if (this.match(types._case) || this.match(types._default)) {\n        const isCase = this.match(types._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(this.state.lastTokStart, Errors.MultipleDefaultsInSwitch);\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this.expect(types.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(node) {\n    this.next();\n\n    if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {\n      this.raise(this.state.lastTokEnd, Errors.NewlineAfterThrow);\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(types._catch)) {\n      const clause = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL)) {\n        this.expect(types.parenL);\n        clause.param = this.parseBindingAtom();\n        const simple = clause.param.type === \"Identifier\";\n        this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLVal(clause.param, BIND_LEXICAL, null, \"catch clause\");\n        this.expect(types.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, Errors.NoCatchOrFinally);\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseVarStatement(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"while\"));\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(this.state.start, Errors.StrictWith);\n    }\n\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"with\"));\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(node, maybeName, expr, context) {\n    for (let _i2 = 0, _this$state$labels = this.state.labels; _i2 < _this$state$labels.length; _i2++) {\n      const label = _this$state$labels[_i2];\n\n      if (label.name === maybeName) {\n        this.raise(expr.start, Errors.LabelRedeclaration, maybeName);\n      }\n    }\n\n    const kind = this.state.type.isLoop ? \"loop\" : this.match(types._switch) ? \"switch\" : null;\n\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n    this.expect(types.braceL);\n\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n\n    this.parseBlockBody(node, allowDirectives, false, types.braceR, afterBlockParse);\n\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const octalPositions = [];\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      if (!parsedNonDirective && this.state.octalPositions.length) {\n        octalPositions.push(...this.state.octalPositions);\n      }\n\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {\n        const directive = this.stmtToDirective(stmt);\n        directives.push(directive);\n\n        if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n          hasStrictModeDirective = true;\n          this.setStrict(true);\n        }\n\n        continue;\n      }\n\n      parsedNonDirective = true;\n      body.push(stmt);\n    }\n\n    if (this.state.strict && octalPositions.length) {\n      for (let _i3 = 0; _i3 < octalPositions.length; _i3++) {\n        const pos = octalPositions[_i3];\n        this.raise(pos, Errors.StrictOctalLiteral);\n      }\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  parseFor(node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.match(types.semi) ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.match(types.parenR) ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(types._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt > -1) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt > -1;\n    }\n\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(init.start, Errors.ForInOfLoopInitializer, isForIn ? \"for-in\" : \"for-of\");\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, Errors.InvalidLhs, \"for-loop\");\n    }\n\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  parseVar(node, isFor, kind) {\n    const declarations = node.declarations = [];\n    const isTypescript = this.hasPlugin(\"typescript\");\n    node.kind = kind;\n\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n\n      if (this.eat(types.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else {\n        if (kind === \"const\" && !(this.match(types._in) || this.isContextual(\"of\"))) {\n          if (!isTypescript) {\n            this.unexpected();\n          }\n        } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(types._in) || this.isContextual(\"of\")))) {\n          this.raise(this.state.lastTokEnd, Errors.DeclarationMissingInitializer, \"Complex binding patterns\");\n        }\n\n        decl.init = null;\n      }\n\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) break;\n    }\n\n    return node;\n  }\n\n  parseVarId(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, undefined, \"variable declaration\", kind !== \"var\");\n  }\n\n  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n    this.initFunction(node, isAsync);\n\n    if (this.match(types.star) && isHangingStatement) {\n      this.raise(this.state.start, Errors.GeneratorInSingleStatementContext);\n    }\n\n    node.generator = this.eat(types.star);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    this.state.maybeInArrowParameters = false;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node);\n    this.withTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      this.registerFunctionStatementId(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.yieldPos = oldYieldPos;\n    this.state.awaitPos = oldAwaitPos;\n    return node;\n  }\n\n  parseFunctionId(requireId) {\n    return requireId || this.match(types.name) ? this.parseIdentifier() : null;\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const oldInParameters = this.state.inParameters;\n    this.state.inParameters = true;\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);\n    this.state.inParameters = oldInParameters;\n    this.checkYieldAwaitInDefaultParams();\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    this.state.strict = oldStrict;\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n\n  isClassProperty() {\n    return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);\n  }\n\n  isClassMethod() {\n    return this.match(types.parenL);\n  }\n\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n\n  parseClassBody(constructorAllowsSuper, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(types.braceL);\n    this.withTopicForbiddingContext(() => {\n      while (!this.match(types.braceR)) {\n        if (this.eat(types.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(this.state.lastTokEnd, Errors.DecoratorSemicolon);\n          }\n\n          continue;\n        }\n\n        if (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode();\n\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state, constructorAllowsSuper);\n\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(member.start, Errors.DecoratorConstructor);\n        }\n      }\n    });\n\n    if (!oldStrict) {\n      this.state.strict = false;\n    }\n\n    this.next();\n\n    if (decorators.length) {\n      throw this.raise(this.state.start, Errors.TrailingDecorator);\n    }\n\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  parseClassMemberFromModifier(classBody, member) {\n    const containsEsc = this.state.containsEsc;\n    const key = this.parseIdentifier(true);\n\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    } else if (containsEsc) {\n      throw this.unexpected();\n    }\n\n    return false;\n  }\n\n  parseClassMember(classBody, member, state, constructorAllowsSuper) {\n    const isStatic = this.isContextual(\"static\");\n\n    if (isStatic && this.parseClassMemberFromModifier(classBody, member)) {\n      return;\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n\n    if (this.eat(types.star)) {\n      method.kind = \"method\";\n      this.parseClassPropertyName(method);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(publicMethod.key.start, Errors.ConstructorIsGenerator);\n      }\n\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parseClassPropertyName(member);\n    const isPrivate = key.type === \"PrivateName\";\n    const isSimple = key.type === \"Identifier\";\n    const maybeQuestionTokenStart = this.state.start;\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(key.start, Errors.DuplicateConstructor);\n        }\n\n        state.hadConstructor = true;\n        allowsDirectSuper = constructorAllowsSuper;\n      }\n\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isSimple && key.name === \"async\" && !containsEsc && !this.isLineTerminator()) {\n      const isGenerator = this.eat(types.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStart);\n      }\n\n      method.kind = \"method\";\n      this.parseClassPropertyName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, Errors.ConstructorIsAsync);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isSimple && (key.name === \"get\" || key.name === \"set\") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {\n      method.kind = key.name;\n      this.parseClassPropertyName(publicMethod);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, Errors.ConstructorIsAccessor);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  parseClassPropertyName(member) {\n    const key = this.parsePropertyName(member, true);\n\n    if (!member.computed && member.static && (key.name === \"prototype\" || key.value === \"prototype\")) {\n      this.raise(key.start, Errors.StaticPrototype);\n    }\n\n    if (key.type === \"PrivateName\" && key.id.name === \"constructor\") {\n      this.raise(key.start, Errors.ConstructorClassPrivateField);\n    }\n\n    return key;\n  }\n\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(prop.key.start, Errors.ConstructorClassField);\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(classBody, prop) {\n    this.expectPlugin(\"classPrivateProperties\", prop.key.start);\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(node.key.id.name, CLASS_ELEMENT_OTHER, node.key.start);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    this.expectPlugin(\"classPrivateMethods\", method.key.start);\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === \"set\" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;\n    this.classScope.declarePrivateName(node.key.id.name, kind, node.key.start);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {}\n\n  parseAccessModifier() {\n    return undefined;\n  }\n\n  parseClassPrivateProperty(node) {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;\n    this.semicolon();\n    this.prodParam.exit();\n    this.scope.exit();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  parseClassProperty(node) {\n    if (!node.typeAnnotation) {\n      this.expectPlugin(\"classProperties\");\n    }\n\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.prodParam.enter(PARAM);\n\n    if (this.match(types.eq)) {\n      this.expectPlugin(\"classProperties\");\n      this.next();\n      node.value = this.parseMaybeAssign();\n    } else {\n      node.value = null;\n    }\n\n    this.semicolon();\n    this.prodParam.exit();\n    this.scope.exit();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {\n    if (this.match(types.name)) {\n      node.id = this.parseIdentifier();\n\n      if (isStatement) {\n        this.checkLVal(node.id, bindingType, undefined, \"class name\");\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        this.unexpected(null, Errors.MissingClassName);\n      }\n    }\n  }\n\n  parseClassSuper(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  parseExport(node) {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(types.comma);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {\n      throw this.unexpected(null, types.braceL);\n    }\n\n    let hasDeclaration;\n\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(node, true, false, !!node.source);\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(types._default)) {\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, types.braceL);\n  }\n\n  eatExportStar(node) {\n    return this.eat(types.star);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(\"as\")) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(types.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      node.specifiers.push(...this.parseExportSpecifiers());\n      node.source = null;\n      node.declaration = null;\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      if (this.isContextual(\"async\")) {\n        const next = this.nextTokenStart();\n\n        if (!this.isUnparsedContextual(next, \"function\")) {\n          this.unexpected(next, types._function);\n        }\n      }\n\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  isAsyncFunction() {\n    if (!this.isContextual(\"async\")) return false;\n    const next = this.nextTokenStart();\n    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(types._function) || isAsync) {\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);\n    } else if (this.match(types._class)) {\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, Errors.DecoratorBeforeExport);\n      }\n\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {\n      throw this.raise(this.state.start, Errors.UnsupportedDefaultExport);\n    } else {\n      const res = this.parseMaybeAssign();\n      this.semicolon();\n      return res;\n    }\n  }\n\n  parseExportDeclaration(node) {\n    return this.parseStatement(null);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types.name)) {\n      const value = this.state.value;\n\n      if (value === \"async\" || value === \"let\") {\n        return false;\n      }\n\n      if ((value === \"type\" || value === \"interface\") && !this.state.containsEsc) {\n        const l = this.lookahead();\n\n        if (l.type === types.name && l.value !== \"from\" || l.type === types.braceL) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(types._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    return this.input.charCodeAt(next) === 44 || this.isUnparsedContextual(next, \"from\");\n  }\n\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(\"from\")) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n    } else {\n      if (expect) {\n        this.unexpected();\n      } else {\n        node.source = null;\n      }\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.match(types.at)) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          this.unexpected(this.state.start, Errors.DecoratorBeforeExport);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return this.state.type.keyword === \"var\" || this.state.type.keyword === \"const\" || this.state.type.keyword === \"function\" || this.state.type.keyword === \"class\" || this.isLet() || this.isAsyncFunction();\n  }\n\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n      } else if (node.specifiers && node.specifiers.length) {\n        for (let _i4 = 0, _node$specifiers = node.specifiers; _i4 < _node$specifiers.length; _i4++) {\n          const specifier = _node$specifiers[_i4];\n          this.checkDuplicateExports(specifier, specifier.exported.name);\n\n          if (!isFrom && specifier.local) {\n            this.checkReservedWord(specifier.local.name, specifier.local.start, true, false);\n            this.scope.checkLocalExport(specifier.local);\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (let _i5 = 0, _node$declaration$dec = node.declaration.declarations; _i5 < _node$declaration$dec.length; _i5++) {\n            const declaration = _node$declaration$dec[_i5];\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (currentContextDecorators.length) {\n      const isClass = node.declaration && (node.declaration.type === \"ClassDeclaration\" || node.declaration.type === \"ClassExpression\");\n\n      if (!node.declaration || !isClass) {\n        throw this.raise(node.start, Errors.UnsupportedDecoratorExport);\n      }\n\n      this.takeDecorators(node.declaration);\n    }\n  }\n\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (let _i6 = 0, _node$properties = node.properties; _i6 < _node$properties.length; _i6++) {\n        const prop = _node$properties[_i6];\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (let _i7 = 0, _node$elements = node.elements; _i7 < _node$elements.length; _i7++) {\n        const elem = _node$elements[_i7];\n\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(node, name) {\n    if (this.state.exportedIdentifiers.indexOf(name) > -1) {\n      this.raise(node.start, name === \"default\" ? Errors.DuplicateDefaultExport : Errors.DuplicateExport, name);\n    }\n\n    this.state.exportedIdentifiers.push(name);\n  }\n\n  parseExportSpecifiers() {\n    const nodes = [];\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      const node = this.startNode();\n      node.local = this.parseIdentifier(true);\n      node.exported = this.eatContextual(\"as\") ? this.parseIdentifier(true) : node.local.__clone();\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    return nodes;\n  }\n\n  parseImport(node) {\n    node.specifiers = [];\n\n    if (!this.match(types.string)) {\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      const parseNext = !hasDefault || this.eat(types.comma);\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(\"from\");\n    }\n\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    if (!this.match(types.string)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  shouldParseDefaultImport(node) {\n    return this.match(types.name);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\", \"default import specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(types.star)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\", \"import namespace specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(types.colon)) {\n          throw this.raise(this.state.start, Errors.DestructureNamedImport);\n        }\n\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      this.parseImportSpecifier(node);\n    }\n  }\n\n  parseImportSpecifier(node) {\n    const specifier = this.startNode();\n    specifier.imported = this.parseIdentifier(true);\n\n    if (this.eatContextual(\"as\")) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      this.checkReservedWord(specifier.imported.name, specifier.start, true, true);\n      specifier.local = specifier.imported.__clone();\n    }\n\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, \"import specifier\");\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n\n}\n\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n\n}\nclass ClassScopeHandler {\n  constructor(raise) {\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n  }\n\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n\n    for (let _i = 0, _Array$from = Array.from(oldClassScope.undefinedPrivateNames); _i < _Array$from.length; _i++) {\n      const [name, pos] = _Array$from[_i];\n\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, pos);\n        }\n      } else {\n        this.raise(pos, Errors.InvalidPrivateFieldResolution, name);\n      }\n    }\n  }\n\n  declarePrivateName(name, elementType, pos) {\n    const classScope = this.current();\n    let redefined = classScope.privateNames.has(name);\n\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && classScope.loneAccessors.get(name);\n\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) classScope.loneAccessors.delete(name);\n      } else if (!redefined) {\n        classScope.loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.raise(pos, Errors.PrivateNameRedeclaration, name);\n    }\n\n    classScope.privateNames.add(name);\n    classScope.undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name, pos) {\n    let classScope;\n\n    for (let _i2 = 0, _this$stack = this.stack; _i2 < _this$stack.length; _i2++) {\n      classScope = _this$stack[_i2];\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, pos);\n    } else {\n      this.raise(pos, Errors.InvalidPrivateFieldResolution, name);\n    }\n  }\n\n}\n\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    const ScopeHandler = this.getScopeHandler();\n    this.options = options;\n    this.inModule = this.options.sourceType === \"module\";\n    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);\n    this.prodParam = new ProductionParameterHandler();\n    this.classScope = new ClassScopeHandler(this.raise.bind(this));\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n\n  parse() {\n    let paramFlags = PARAM;\n\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n\n}\n\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n\n  for (let _i = 0; _i < plugins.length; _i++) {\n    const plugin = plugins[_i];\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n\n  return pluginMap;\n}\n\nfunction parse(input, options) {\n  if (options && options.sourceType === \"unambiguous\") {\n    options = Object.assign({}, options);\n\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n\n  return parser.getExpression();\n}\n\nfunction getParser(options, input) {\n  let cls = Parser;\n\n  if (options && options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache = {};\n\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n\n  if (!cls) {\n    cls = Parser;\n\n    for (let _i = 0; _i < pluginList.length; _i++) {\n      const plugin = pluginList[_i];\n      cls = mixinPlugins[plugin](cls);\n    }\n\n    parserClassCache[key] = cls;\n  }\n\n  return cls;\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = types;\n//# sourceMappingURL=index.js.map\n","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n","// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = require('./_wks')('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","var core = module.exports = { version: '2.6.11' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n","var global = require('./_global');\nvar core = require('./_core');\nvar hide = require('./_hide');\nvar redefine = require('./_redefine');\nvar ctx = require('./_ctx');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n","module.exports = require('./_shared')('native-function-to-string', Function.toString);\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","'use strict';\nvar create = require('./_object-create');\nvar descriptor = require('./_property-desc');\nvar setToStringTag = require('./_set-to-string-tag');\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n","'use strict';\nvar LIBRARY = require('./_library');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar $iterCreate = require('./_iter-create');\nvar setToStringTag = require('./_set-to-string-tag');\nvar getPrototypeOf = require('./_object-gpo');\nvar ITERATOR = require('./_wks')('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n","module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n","module.exports = {};\n","module.exports = false;\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = require('./_has');\nvar toObject = require('./_to-object');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var global = require('./_global');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar SRC = require('./_uid')('src');\nvar $toString = require('./_function-to-string');\nvar TO_STRING = 'toString';\nvar TPL = ('' + $toString).split(TO_STRING);\n\nrequire('./_core').inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","var core = require('./_core');\nvar global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: require('./_library') ? 'pure' : 'global',\n  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'\n});\n","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables');\nvar step = require('./_iter-step');\nvar Iterators = require('./_iterators');\nvar toIObject = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n","var $iterators = require('./es6.array.iterator');\nvar getKeys = require('./_object-keys');\nvar redefine = require('./_redefine');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar wks = require('./_wks');\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n","import{parse}from\"@babel/parser\";import{VariableInfo,createModuleScope,createGlobalScope,HegelError}from\"@hegel/core\";let module=undefined;const STANDARD_LIB_OPTIONS={plugins:[\"typescript\"]};const DEFAULT_OPTIONS={plugins:[\"bigInt\",\"classProperties\",\"numericSeparator\",\"classPrivateMethods\",\"classPrivateProperties\",[\"flow\",{all:true}]]};// eslint-disable-next-line\nconst STANDARD_AST=parse(STD_LIB_CONTENT,STANDARD_LIB_OPTIONS);export function getTypeByLocation(location){if(module===undefined){return;}const varInfoOrType=module.getVarAtPosition(location);if(varInfoOrType===undefined){return;}return varInfoOrType instanceof VariableInfo?varInfoOrType.type:varInfoOrType;}if(typeof getTypeByLocation!=='undefined'&&getTypeByLocation&&getTypeByLocation===Object(getTypeByLocation)&&Object.isExtensible(getTypeByLocation)&&!getTypeByLocation.hasOwnProperty('__filemeta')){Object.defineProperty(getTypeByLocation,'__filemeta',{configurable:true,value:{name:\"getTypeByLocation\",filename:\"src/docs/try/components/hegel.js\"}});}if(typeof getTypeByLocation!=='undefined'&&getTypeByLocation&&getTypeByLocation===Object(getTypeByLocation)&&Object.isExtensible(getTypeByLocation)&&!getTypeByLocation.hasOwnProperty('__filemeta')){Object.defineProperty(getTypeByLocation,'__filemeta',{configurable:true,value:{name:\"getTypeByLocation\",filename:\"src/docs/try/components/hegel.js\"}});}let stdLibTypeGraph;export async function mixTypeDefinitions(globalScope){if(stdLibTypeGraph===undefined){stdLibTypeGraph=await getStandardTypeDefinitions(globalScope);}const body=new Map(globalScope.body);for(const[name,variable]of stdLibTypeGraph.body.entries()){variable.parent=globalScope;body.set(name,variable);}const typesBody=new Map(globalScope.typeScope.body);for(const[name,type]of stdLibTypeGraph.typeScope.body.entries()){type.parent=globalScope.typeScope;typesBody.set(name,type);}globalScope.body=body;globalScope.typeScope.body=typesBody;}if(typeof mixTypeDefinitions!=='undefined'&&mixTypeDefinitions&&mixTypeDefinitions===Object(mixTypeDefinitions)&&Object.isExtensible(mixTypeDefinitions)&&!mixTypeDefinitions.hasOwnProperty('__filemeta')){Object.defineProperty(mixTypeDefinitions,'__filemeta',{configurable:true,value:{name:\"mixTypeDefinitions\",filename:\"src/docs/try/components/hegel.js\"}});}if(typeof mixTypeDefinitions!=='undefined'&&mixTypeDefinitions&&mixTypeDefinitions===Object(mixTypeDefinitions)&&Object.isExtensible(mixTypeDefinitions)&&!mixTypeDefinitions.hasOwnProperty('__filemeta')){Object.defineProperty(mixTypeDefinitions,'__filemeta',{configurable:true,value:{name:\"mixTypeDefinitions\",filename:\"src/docs/try/components/hegel.js\"}});}export async function getStandardTypeDefinitions(globalScope){const errors=[];const graph=await createModuleScope(STANDARD_AST,errors,()=>{},globalScope,true);if(errors.length>0){throw errors;}return graph;}if(typeof getStandardTypeDefinitions!=='undefined'&&getStandardTypeDefinitions&&getStandardTypeDefinitions===Object(getStandardTypeDefinitions)&&Object.isExtensible(getStandardTypeDefinitions)&&!getStandardTypeDefinitions.hasOwnProperty('__filemeta')){Object.defineProperty(getStandardTypeDefinitions,'__filemeta',{configurable:true,value:{name:\"getStandardTypeDefinitions\",filename:\"src/docs/try/components/hegel.js\"}});}if(typeof getStandardTypeDefinitions!=='undefined'&&getStandardTypeDefinitions&&getStandardTypeDefinitions===Object(getStandardTypeDefinitions)&&Object.isExtensible(getStandardTypeDefinitions)&&!getStandardTypeDefinitions.hasOwnProperty('__filemeta')){Object.defineProperty(getStandardTypeDefinitions,'__filemeta',{configurable:true,value:{name:\"getStandardTypeDefinitions\",filename:\"src/docs/try/components/hegel.js\"}});}export async function getDiagnostics(sourceCode){let errors=[];try{const file=parse(sourceCode,DEFAULT_OPTIONS);[[module],errors]=await createGlobalScope([file],()=>{},false,mixTypeDefinitions,true);}catch(e){const error=new HegelError(`AnalyzationError: ${e.message}`,{start:{line:0,column:0},end:{line:Number.MAX_VALUE,column:Number.MAX_VALUE}});errors=[error];}return errors.map(toTransferableObject);}if(typeof getDiagnostics!=='undefined'&&getDiagnostics&&getDiagnostics===Object(getDiagnostics)&&Object.isExtensible(getDiagnostics)&&!getDiagnostics.hasOwnProperty('__filemeta')){Object.defineProperty(getDiagnostics,'__filemeta',{configurable:true,value:{name:\"getDiagnostics\",filename:\"src/docs/try/components/hegel.js\"}});}if(typeof getDiagnostics!=='undefined'&&getDiagnostics&&getDiagnostics===Object(getDiagnostics)&&Object.isExtensible(getDiagnostics)&&!getDiagnostics.hasOwnProperty('__filemeta')){Object.defineProperty(getDiagnostics,'__filemeta',{configurable:true,value:{name:\"getDiagnostics\",filename:\"src/docs/try/components/hegel.js\"}});}function toTransferableObject(error){const loc=error.loc;return{message:error.message,source:error.source,loc:loc&&formatLoc(loc)};}function formatLoc(loc){return loc.start?{start:{line:loc.start.line,column:loc.start.column},end:{line:loc.end.line,column:loc.end.column}}:{start:{line:loc.line,column:loc.column},end:{line:loc.line,column:loc.column+1}};}\naddEventListener('message', function (e) {var ref = e.data;var type = ref.type;var method = ref.method;var id = ref.id;var params = ref.params;var f,p;if (type === 'RPC' && method) {if (f = __webpack_exports__[method]) {p = Promise.resolve().then(function () { return f.apply(__webpack_exports__, params); });} else {p = Promise.reject('No such method');}p.then(function (result) {postMessage({type: 'RPC',id: id,result: result});}).catch(function (e) {var error = {message: e};if (e.stack) {error.message = e.message;error.stack = e.stack;error.name = e.name;}postMessage({type: 'RPC',id: id,error: error});});}});postMessage({type: 'RPC',method: 'ready'});","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _callMeta = require(\"../type-graph/meta/call-meta\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _functionType = require(\"../inference/function-type\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _functionType2 = require(\"../type-graph/types/function-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getActualType(actual, typeScope) {\n  if (actual === undefined || actual === null) {\n    return _type.Type.Undefined;\n  }\n\n  if (Array.isArray(actual)) {\n    const items = actual.map(a => getActualType(a, typeScope));\n    return _tupleType.TupleType.term(_tupleType.TupleType.getName(items), {}, items);\n  }\n\n  if (actual instanceof _variableInfo.VariableInfo) {\n    return getActualType(actual.type, typeScope);\n  }\n\n  if (actual instanceof _typeVar.TypeVar && actual.root != undefined) {\n    return actual.root;\n  }\n\n  return actual;\n}\n\nfunction isAssign(call) {\n  return call.targetName.includes(\"=\") && !call.targetName.includes(\"==\");\n}\n\nfunction isValidTypes(targetName, declaratedType, actual, typeScope) {\n  let declaratedRootType = declaratedType instanceof _functionType2.RestArgument ? declaratedType.type : declaratedType;\n  const actualRootType = getActualType(actual, typeScope);\n\n  if (declaratedType instanceof _functionType2.RestArgument && Array.isArray(actual)) {\n    return isValidTypes(targetName, declaratedType.type, actualRootType, typeScope);\n  } else if (!(declaratedType instanceof _functionType2.RestArgument)) {\n    declaratedRootType = declaratedRootType instanceof _typeVar.TypeVar && declaratedRootType.root ? declaratedRootType.root : declaratedRootType;\n\n    if (actualRootType instanceof _unionType.UnionType) {\n      return actualRootType.variants.every(t => isValidTypes(targetName, declaratedRootType, //$FlowIssue it's needed for the property consistency\n      actual instanceof _variableInfo.VariableInfo ? new _variableInfo.VariableInfo(t) : t, typeScope));\n    }\n\n    if (declaratedRootType.onlyLiteral && !(declaratedRootType instanceof _objectType.ObjectType && declaratedRootType.isNominal) && declaratedRootType !== _objectType.ObjectType.Object && declaratedRootType !== _objectType.ObjectType.Object.root && declaratedRootType !== _functionType2.FunctionType.Function && declaratedRootType !== _functionType2.FunctionType.Function.root && actual instanceof _variableInfo.VariableInfo) {\n      return declaratedRootType.equalsTo(actualRootType);\n    }\n\n    if (targetName === \"return\" || targetName === \"init\" || targetName === \"=\" || declaratedRootType.parent.priority >= _typeScope.TypeScope.MODULE_SCOPE_PRIORITY && (0, _typeUtils.isReachableType)(declaratedRootType, typeScope)) {\n      _typeVar.TypeVar.strictEquality = true;\n      const result = declaratedRootType.isPrincipalTypeFor(actualRootType);\n      _typeVar.TypeVar.strictEquality = false;\n      return result;\n    }\n\n    return declaratedRootType.isPrincipalTypeFor(actualRootType);\n  }\n\n  throw new Error(\"Never!\");\n}\n\nfunction checkSingleCall(path, call, typeScope, errors) {\n  const givenArgumentsTypes = call.arguments.map(t => t instanceof _variableInfo.VariableInfo ? t.type : t);\n  const targetFunctionType = (0, _functionType.getCallTarget)(call);\n  const targetArguments = targetFunctionType.argumentsTypes;\n  const requiredTargetArguments = targetArguments.filter(a => !(a instanceof _unionType.UnionType && a.variants.find(a => a.equalsTo(_type.Type.Undefined)) || a instanceof _functionType2.RestArgument));\n\n  if (requiredTargetArguments.length > givenArgumentsTypes.length) {\n    errors.push(new _errors2.default(`${requiredTargetArguments.length} arguments are required. Given ${givenArgumentsTypes.length}.`, call.loc, path));\n  } else if (targetArguments.length < givenArgumentsTypes.length && !(targetArguments[targetArguments.length - 1] instanceof _functionType2.RestArgument)) {\n    errors.push(new _errors2.default(`${targetArguments.length} arguments are expected. Given ${givenArgumentsTypes.length}.`, call.loc, path));\n  } else {\n    let firstArgumentType = call.arguments[0];\n    firstArgumentType = firstArgumentType instanceof _variableInfo.VariableInfo ? firstArgumentType.type : firstArgumentType;\n\n    if (isAssign(call) && firstArgumentType instanceof _immutableType.$AppliedImmutable) {\n      errors.push(new _errors2.default(`Attempt to mutate immutable type`, call.loc, path));\n    }\n\n    for (let i = 0; i < targetArguments.length; i++) {\n      const arg1 = targetArguments[i];\n      const arg2 = arg1 instanceof _functionType2.RestArgument ? call.arguments.slice(i) : call.arguments[i];\n\n      if (!isValidTypes(call.targetName, arg1, arg2, call.typeScope)) {\n        let actualType = arg1 instanceof _functionType2.RestArgument ? givenArgumentsTypes.slice(i) : givenArgumentsTypes[i];\n        actualType = actualType instanceof _variableInfo.VariableInfo ? actualType.type : actualType;\n        const actualTypeName = // $FlowIssue\n        arg2 === undefined ? \"undefined\" : _tupleType.TupleType.getName(actualType);\n        errors.push(new _errors2.default(`Type \"${actualTypeName}\" is incompatible with type \"${String(arg1.name)}\"`, arg1 instanceof _functionType2.RestArgument ? call.loc : call.argumentsLocations[i] || call.loc, path));\n      }\n    }\n  }\n}\n\nfunction checkCalls(path, scope, typeScope, errors) {\n  let returnWasCalled = false;\n  let finalWasCalled = false;\n\n  for (let i = 0; i < scope.calls.length; i++) {\n    const call = scope.calls[i];\n\n    if (call.target === undefined) {\n      continue;\n    }\n\n    if (call.targetName === \"return\") {\n      returnWasCalled = true;\n    }\n\n    if (call.isFinal) {\n      finalWasCalled = true;\n    }\n\n    checkSingleCall(path, call, typeScope, errors);\n  }\n\n  if (scope instanceof _variableScope.VariableScope && scope.type === _variableScope.VariableScope.FUNCTION_TYPE && scope.declaration instanceof _variableInfo.VariableInfo && !returnWasCalled && !finalWasCalled) {\n    const {\n      declaration\n    } = scope;\n    const {\n      returnType,\n      isAsync\n    } = declaration.type instanceof _genericType.GenericType ? declaration.type.subordinateType : declaration.type;\n\n    if (!declaration.isInferenced && !isFunctionShouldNotCallReturn(returnType, isAsync)) {\n      errors.push(new _errors2.default(`Function should return something with type \"${String(returnType.name)}\"`, declaration.meta.loc, path));\n    }\n  }\n}\n\nfunction isFunctionShouldNotCallReturn(returnType, isAsync) {\n  if (returnType === undefined || returnType instanceof _typeVar.TypeVar && !returnType.isUserDefined) {\n    return true;\n  }\n\n  if (returnType instanceof _unionType.UnionType) {\n    return returnType.variants.some(returnType => isFunctionShouldNotCallReturn(returnType, isAsync));\n  }\n\n  return returnType === _type.Type.Undefined || isAsync && returnType.equalsTo(_type.Type.Undefined.promisify());\n}\n\nexports.default = checkCalls;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createModuleScope = exports.createGlobalScope = exports.HegelError = exports.VariableInfo = exports.Type = exports.PositionedModuleScope = exports.ModuleScope = exports.VariableScope = exports.TypeScope = undefined;\n\nvar _errors = require(\"./utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type-graph/types/type\");\n\nvar _typeScope = require(\"./type-graph/type-scope\");\n\nvar _variableInfo = require(\"./type-graph/variable-info\");\n\nvar _variableScope = require(\"./type-graph/variable-scope\");\n\nvar _moduleScope = require(\"./type-graph/module-scope\");\n\nvar _typeGraph = require(\"./type-graph/type-graph\");\n\nvar _typeGraph2 = _interopRequireDefault(_typeGraph);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst TypeScope = exports.TypeScope = _typeScope.TypeScope;\nconst VariableScope = exports.VariableScope = _variableScope.VariableScope;\nconst ModuleScope = exports.ModuleScope = _moduleScope.ModuleScope;\nconst PositionedModuleScope = exports.PositionedModuleScope = _moduleScope.PositionedModuleScope;\nconst Type = exports.Type = _type.Type;\nconst VariableInfo = exports.VariableInfo = _variableInfo.VariableInfo;\nconst HegelError = exports.HegelError = _errors2.default;\nconst createGlobalScope = exports.createGlobalScope = _typeGraph2.default;\nconst createModuleScope = exports.createModuleScope = _typeGraph.createModuleScope;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.refinePropertyWithConstraint = refinePropertyWithConstraint;\nexports.refinementProperty = refinementProperty;\nexports.equalsRefinement = equalsRefinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _common = require(\"../utils/common\");\n\nvar _inferenceUtils = require(\"../utils/inference-utils\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isIdentifierOrProperty(node) {\n  return node.type === _nodes2.default.IDENTIFIER && node.name !== \"undefined\" || node.type === _nodes2.default.MEMBER_EXPRESSION;\n}\n\nfunction getEqualsArguments(left, right, refinementNode) {\n  if ((refinementNode.type !== _nodes2.default.SWITCH_CASE || right === null || left === null) && (refinementNode.type !== _nodes2.default.BINARY_EXPRESSION || ![\"===\", \"==\", \"!==\", \"!=\"].includes(refinementNode.operator))) {\n    return;\n  }\n\n  let target = null;\n\n  if (isIdentifierOrProperty(left)) {\n    target = left;\n  } else if (isIdentifierOrProperty(right)) {\n    target = right;\n  }\n\n  let value = null;\n\n  if (isSimpleLiteral(left)) {\n    value = left;\n  } else if (isSimpleLiteral(right)) {\n    value = right;\n  }\n\n  if (!target || !value) {\n    return null;\n  }\n\n  return {\n    value,\n    target\n  };\n}\n\nfunction isStrict(refinementNode) {\n  if (refinementNode.type === _nodes2.default.SWITCH_CASE) {\n    return true;\n  }\n\n  switch (refinementNode.operator) {\n    case \"===\":\n    case \"!==\":\n      return true;\n\n    case \"==\":\n    case \"!=\":\n      return false;\n  }\n\n  throw new Error(\"Never!\");\n}\n\nfunction isSimpleLiteral(node) {\n  return node.type === _nodes2.default.NULL_LITERAL || node.type === _nodes2.default.NUMERIC_LITERAL || node.type === _nodes2.default.BIGINT_LITERAL || node.type === _nodes2.default.STRING_LITERAL || node.type === _nodes2.default.BOOLEAN_LITERAL || node.type === _nodes2.default.IDENTIFIER && node.name === \"undefined\";\n}\n\nfunction getRefinmentType(value, refinementNode) {\n  const UNION = _unionType.UnionType.term(\"undefined | null\", {}, [_type.Type.Undefined, _type.Type.Null]);\n\n  const strict = isStrict(refinementNode);\n\n  switch (value.type) {\n    case _nodes2.default.NUMERIC_LITERAL:\n      return _type.Type.term(value.value, {\n        isSubtypeOf: _type.Type.Number\n      });\n\n    case _nodes2.default.BIGINT_LITERAL:\n      return _type.Type.term(`${value.value}n`, {\n        isSubtypeOf: _type.Type.BigInt\n      });\n\n    case _nodes2.default.STRING_LITERAL:\n      return _type.Type.term(`'${value.value}'`, {\n        isSubtypeOf: _type.Type.String\n      });\n\n    case _nodes2.default.BOOLEAN_LITERAL:\n      return _type.Type.term(value.value);\n\n    case _nodes2.default.NULL_LITERAL:\n      return strict ? _type.Type.Null : UNION;\n  }\n\n  if (value.type === _nodes2.default.IDENTIFIER && value.name === \"undefined\") {\n    return strict ? _type.Type.Undefined : UNION;\n  }\n\n  throw new Error(\"Never!\");\n}\n\nfunction refinementVariants([refinementedVariants, alternateVariants], variant, refinementType) {\n  if (refinementType.isPrincipalTypeFor(variant)) {\n    return [refinementedVariants.concat([variant]), alternateVariants];\n  }\n\n  if (variant.isPrincipalTypeFor(refinementType)) {\n    return [refinementedVariants.concat([refinementType]), alternateVariants.concat([variant])];\n  }\n\n  return [refinementedVariants, alternateVariants.concat([variant])];\n}\n\nfunction equalsIdentifier(node, currentScope, typeScope, value, refinementNode, isSwitch) {\n  const variableName = node.name;\n  const refinementType = getRefinmentType(value, refinementNode);\n  const variableInfo = currentScope.findVariable(node);\n  const [refinementedVariants, alternateVariants] = variableInfo.type instanceof _unionType.UnionType ? variableInfo.type.variants.reduce((res, variant) => refinementVariants(res, variant, refinementType), [[], []]) : refinementVariants([[], []], variableInfo.type, refinementType);\n\n  if (!(variableInfo.type instanceof _typeVar.TypeVar) && variableInfo.type !== _type.Type.Unknown && refinementedVariants.length === 0) {\n    throw new _errors2.default(`Type ${String(variableInfo.type.name)} can't be \"${String(refinementType.name)}\" type`, refinementNode.loc);\n  }\n\n  const refinementedType = _unionType.UnionType.term(null, {}, refinementedVariants);\n\n  const alternateType = alternateVariants.length === 0 || refinementType === variableInfo.type ? _type.Type.Never : _unionType.UnionType.term(null, {}, alternateVariants);\n\n  if (refinementedType == _type.Type.Never || alternateType == _type.Type.Never && !isSwitch) {\n    const typeName = String(refinementType.name);\n    throw new _errors2.default(`Type ${refinementedType === _type.Type.Never ? \"can't be\" : \"is always\"} \"${typeName}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinementedType, alternateType];\n}\n\nfunction refinePropertyWithConstraint(chaining, refinementType, variableType, typeScope) {\n  const refinementedType = chaining.reduceRight((res, property) => (0, _typeUtils.createObjectWith)(property, res, typeScope), refinementType);\n  return [refinementedType, variableType];\n}\n\nfunction propertyWith(propertyName, propertyType, propertyOwner, typeScope) {\n  if (propertyType == undefined) {\n    return propertyType;\n  }\n\n  const newPropertyOwner = (0, _typeUtils.createObjectWith)(propertyName, propertyType, typeScope);\n  return (0, _typeUtils.mergeObjectsTypes)(propertyOwner, newPropertyOwner, typeScope);\n}\n\nfunction refinementProperty(variableName, variableType, refinementType, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope, destructUnion = false) {\n  const currentPropertyName = chainingProperties[currentPropertyNameIndex];\n  const isLast = currentPropertyNameIndex === chainingProperties.length - 1;\n\n  if (variableType instanceof _typeVar.TypeVar || variableType === _type.Type.Unknown) {\n    if (!(variableType instanceof _typeVar.TypeVar) || variableType.constraint === undefined) {\n      return refinePropertyWithConstraint(chainingProperties.slice(currentPropertyNameIndex), refinementType, variableType, typeScope);\n    }\n\n    variableType = variableType.constraint;\n  }\n\n  if (isLast && variableType instanceof _collectionType.CollectionType) {\n    return;\n  }\n\n  if (variableType instanceof _objectType.ObjectType) {\n    const property = variableType.getPropertyType(currentPropertyName);\n\n    if (property == null) {\n      return;\n    }\n\n    if (isLast) {\n      if (property instanceof _unionType.UnionType) {\n        const [refinementedVariants, alternateVariants] = property.variants.reduce((res, variant) => refinementVariants(res, variant, refinementType), [[], []]);\n        const [refinemented, alternate] = (0, _inferenceUtils.getTypesFromVariants)( // $FlowIssue\n        refinementedVariants, // $FlowIssue\n        alternateVariants, typeScope);\n        return [propertyWith(currentPropertyName, refinemented, variableType, typeScope), propertyWith(currentPropertyName, alternate, variableType, typeScope)];\n      }\n\n      if (refinementType.isPrincipalTypeFor(property)) {\n        return [variableType, undefined];\n      }\n\n      if (property.isPrincipalTypeFor(refinementType)) {\n        return [propertyWith(currentPropertyName, refinementType, variableType, typeScope), variableType];\n      }\n\n      if (destructUnion && refinementType instanceof _unionType.UnionType) {\n        const pickedVariants = refinementType.variants.filter(variant => property.isPrincipalTypeFor(variant));\n        return [propertyWith(currentPropertyName, _unionType.UnionType.term(null, {}, pickedVariants), variableType, typeScope), variableType];\n      }\n\n      return [undefined, variableType];\n    }\n\n    const nextIndex = currentPropertyNameIndex + 1;\n    const nestedRefinement = refinementProperty(variableName, property, refinementType, refinementNode, nextIndex, chainingProperties, typeScope);\n\n    if (!nestedRefinement) {\n      return;\n    }\n\n    return [propertyWith(currentPropertyName, nestedRefinement[0], variableType, typeScope), propertyWith(currentPropertyName, nestedRefinement[1], variableType, typeScope)];\n  }\n\n  if (variableType instanceof _unionType.UnionType) {\n    const [refinementedVariants, alternateVariants] = variableType.variants.reduce(([refinementedVariants, alternateVariants], variant) => {\n      const isNotAlternateVariant = variant instanceof _objectType.ObjectType && variant.getPropertyType(currentPropertyName);\n      const refinementedTypeAndAlternateType = isNotAlternateVariant ? refinementProperty(variableName, variant, refinementType, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope) : undefined;\n\n      if (!refinementedTypeAndAlternateType) {\n        return [refinementedVariants, alternateVariants.concat([variant])];\n      }\n\n      const [refinementedType, alternateType] = refinementedTypeAndAlternateType;\n      return [refinementedType ? refinementedVariants.concat([refinementedType]) : refinementedVariants, alternateType ? alternateVariants.concat([alternateType]) : alternateVariants];\n    }, [[], []]);\n    return (0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope);\n  }\n\n  return [undefined, undefined];\n}\n\nfunction equalsProperty(node, currentScope, typeScope, value, refinementNode, isSwitch) {\n  const targetObject = (0, _common.getMemberExressionTarget)(node);\n\n  if (targetObject.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const variableName = targetObject.name;\n  const propertiesChaining = (0, _inferenceUtils.getPropertyChaining)(node);\n  const refinementType = getRefinmentType(value, refinementNode);\n  const targetVariableInfo = currentScope.findVariable(targetObject);\n\n  if (!variableName || !targetVariableInfo || !propertiesChaining || targetVariableInfo instanceof _variableScope.VariableScope) {\n    return;\n  }\n\n  const refinmentedAndAlternate = refinementProperty(variableName, targetVariableInfo.type, refinementType, refinementNode, 0, propertiesChaining, typeScope);\n\n  if (refinmentedAndAlternate == undefined) {\n    return;\n  }\n\n  const [refinemented, alternate] = refinmentedAndAlternate;\n\n  if (refinemented != undefined && alternate == undefined && isSwitch) {\n    return [variableName, refinemented, _type.Type.Never];\n  }\n\n  if (refinemented == undefined || alternate == undefined && !isSwitch) {\n    const typeName = String(refinementType.name);\n    throw new _errors2.default(`Property ${refinemented === undefined ? \"can't be\" : \"is always\"} \"${typeName}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinemented, alternate || _type.Type.Never];\n}\n\nfunction equalsRefinement(currentRefinementNode, currentScope, typeScope, moduleScope) {\n  const isSwitch = currentRefinementNode.type === _nodes2.default.SWITCH_CASE;\n  const args = getEqualsArguments(isSwitch ? currentRefinementNode.parent.discriminant : currentRefinementNode.left, isSwitch ? currentRefinementNode.test : currentRefinementNode.right, currentRefinementNode);\n\n  if (!args) {\n    return;\n  }\n\n  const {\n    target,\n    value\n  } = args;\n  let refinementedType, alternateType, name;\n\n  if (target.type === _nodes2.default.IDENTIFIER) {\n    [name, refinementedType, alternateType] = equalsIdentifier(target, currentScope, typeScope, value, currentRefinementNode, isSwitch);\n  }\n\n  if (target.type === _nodes2.default.MEMBER_EXPRESSION) {\n    const result = equalsProperty(target, currentScope, typeScope, value, currentRefinementNode, isSwitch);\n\n    if (!result) {\n      return;\n    }\n\n    [name, refinementedType, alternateType] = result;\n  }\n\n  if (refinementedType) {\n    if (currentRefinementNode.operator === \"!==\" || currentRefinementNode.operator === \"!=\") {\n      // $FlowIssue\n      return [name, alternateType, refinementedType];\n    } // $FlowIssue\n\n\n    return [name, refinementedType, alternateType];\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inferenceErrorType = inferenceErrorType;\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nfunction inferenceErrorType(tryNode, moduleScope) {\n  const tryScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(tryNode));\n\n  if (tryScope === undefined || tryScope.throwable === undefined) {\n    throw new Error(\"Never\");\n  }\n\n  const variants = tryScope.throwable.map(t => t instanceof _variableInfo.VariableInfo ? t.type : t);\n  return _unionType.UnionType.term(null, {}, variants);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inferenceFunctionLiteralType = inferenceFunctionLiteralType;\nexports.getCallTarget = getCallTarget;\nexports.implicitApplyGeneric = implicitApplyGeneric;\nexports.getRawFunctionType = getRawFunctionType;\nexports.getInvocationType = getInvocationType;\nexports.clearRoot = clearRoot;\nexports.prepareGenericFunctionType = prepareGenericFunctionType;\nexports.inferenceFunctionTypeByScope = inferenceFunctionTypeByScope;\nexports.isGenericFunctionType = isGenericFunctionType;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _callMeta = require(\"../type-graph/meta/call-meta\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _constants = require(\"../type-graph/constants\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _bottomType = require(\"../type-graph/types/bottom-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _propertyType = require(\"../type-graph/types/property-type\");\n\nvar _throwsType = require(\"../type-graph/types/throws-type\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _variableUtils = require(\"../utils/variable-utils\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _call = require(\"../type-graph/call\");\n\nvar _scopeUtils = require(\"../utils/scope-utils\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst typeVarNames = [\"_a\", \"_b\", \"_c\", \"_d\", \"_e\", \"_f\", \"_g\", \"_h\", \"_i\", \"_j\", \"_k\", \"_l\", \"_m\", \"_n\", \"_o\", \"_p\", \"__a\", \"__b\", \"__c\", \"__d\", \"__e\", \"__f\", \"__g\", \"__h\", \"__i\", \"__j\", \"__k\", \"__l\", \"__m\", \"__n\", \"__o\", \"__p\"];\n\nconst isValidRestArgumentType = type => type instanceof _collectionType.CollectionType || type instanceof _tupleType.TupleType || type instanceof _bottomType.$BottomType && type.getRootedSubordinateType().isPrincipalTypeFor(_collectionType.CollectionType.Array);\n\nfunction inferenceFunctionLiteralType(currentNode, typeScope, parentScope, typeGraph, isTypeDefinitions, parentNode, pre, middle, post) {\n  const localTypeScope = new _typeScope.TypeScope((0, _scopeUtils.findNearestTypeScope)(parentScope, typeGraph));\n  const functionScope = isTypeDefinitions ? new _variableScope.VariableScope(_variableScope.VariableScope.FUNCTION_TYPE, parentScope) : typeGraph.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n  if (!(functionScope instanceof _variableScope.VariableScope)) {\n    throw new Error(\"Function scope should be created before inference\");\n  }\n\n  const genericArguments = new Set();\n\n  if (currentNode.typeParameters != undefined) {\n    currentNode.typeParameters.params.forEach(typeAnnotation => genericArguments.add((0, _typeUtils.getTypeFromTypeAnnotation)({\n      typeAnnotation\n    }, localTypeScope, parentScope, true, null, parentNode, typeGraph, pre, middle, post)));\n  } else {\n    localTypeScope.makeCustom();\n  }\n\n  let nameIndex = 0;\n\n  try {\n    do {\n      _type.Type.find(typeVarNames[nameIndex], {\n        parent: localTypeScope\n      });\n\n      nameIndex++;\n    } while (true);\n  } catch {}\n\n  const self = parentScope.type === _variableScope.VariableScope.CLASS_TYPE || parentScope.type === _variableScope.VariableScope.OBJECT_TYPE ? // $FlowIssue\n  parentScope.body.get(_constants.THIS_TYPE).type : null;\n  const argumentsTypes = currentNode.params.map((param, index) => {\n    if (param.optional && !isTypeDefinitions) {\n      throw new _errors2.default(\"The optional argument syntax is not allowed. Use optional type instead.\", param.loc);\n    }\n\n    const {\n      name\n    } = param.left || param;\n    const typeNode = param.left !== undefined ? param.left.typeAnnotation : param.typeAnnotation;\n    const typeAnnotation = param.optional ? {\n      typeAnnotation: { ...typeNode,\n        type: _nodes2.default.NULLABLE_TYPE_ANNOTATION\n      }\n    } : typeNode;\n    let paramType = (0, _typeUtils.getTypeFromTypeAnnotation)(typeAnnotation, localTypeScope, parentScope, false, // $FlowIssue\n    self, parentNode, typeGraph, pre, middle, post);\n    const isWithoutAnnotation = typeNode == undefined;\n    functionScope.body.set(name, new _variableInfo.VariableInfo(paramType, functionScope, new _meta.Meta(param.loc)));\n\n    if (param.left !== undefined) {\n      if (!isWithoutAnnotation && typeNode.typeAnnotation.type === _nodes2.default.NULLABLE_TYPE_ANNOTATION) {\n        throw new _errors2.default(\"Argument cannot be optional and has initializer.\", typeNode.typeAnnotation.loc);\n      }\n\n      const callResultType = (0, _call.addCallToTypeGraph)(param, typeGraph, functionScope, parentNode, pre, middle, post);\n      const newType = callResultType.result instanceof _variableInfo.VariableInfo ? callResultType.result.type : callResultType.result;\n      paramType = !isWithoutAnnotation ? paramType : (0, _variableUtils.getVariableType)(new _variableInfo.VariableInfo(paramType, functionScope), newType, typeScope, callResultType.inferenced);\n      const variants = [paramType, _type.Type.Undefined];\n      paramType = _unionType.UnionType.term(null, {}, variants);\n    }\n\n    if (isWithoutAnnotation && paramType === _type.Type.Unknown) {\n      const typeVar = (0, _typeUtils.addTypeVar)(typeVarNames[nameIndex + index], localTypeScope);\n\n      if (typeVar instanceof _typeVar.TypeVar) {\n        genericArguments.add(typeVar);\n      }\n\n      paramType = typeVar;\n    }\n\n    if (param.type === _nodes2.default.REST_ELEMENT) {\n      if (!isWithoutAnnotation && !(paramType instanceof _unionType.UnionType && paramType.variants.every(isValidRestArgumentType) || isValidRestArgumentType(paramType))) {\n        throw new _errors2.default(\"Rest argument type should be an array-like\", param.typeAnnotation.loc);\n      }\n\n      paramType = paramType instanceof _typeVar.TypeVar && !paramType.isUserDefined ? _type.Type.find(\"Array\").applyGeneric([_type.Type.Unknown]) : paramType;\n      paramType = _functionType.RestArgument.term(null, {}, paramType);\n    }\n\n    return paramType;\n  });\n  let throwableType;\n  let returnType = currentNode.returnType != undefined ? (0, _typeUtils.getTypeFromTypeAnnotation)(currentNode.returnType, localTypeScope, parentScope, false, // $FlowIssue\n  self, parentNode, typeGraph, pre, middle, post) : (0, _typeUtils.addTypeVar)(typeVarNames[nameIndex + argumentsTypes.length], localTypeScope);\n\n  if (currentNode.returnType == undefined) {\n    if (returnType instanceof _typeVar.TypeVar) {\n      genericArguments.add(returnType);\n    }\n  }\n\n  if (returnType instanceof _throwsType.$ThrowsResult || returnType instanceof _unionType.UnionType) {\n    if (returnType instanceof _unionType.UnionType) {\n      const [returnTypes, errors] = returnType.variants.reduce(([result, errors], type) => type instanceof _throwsType.$ThrowsResult ? [result, [...errors, type.errorType]] : [[...result, type], errors], [[], []]);\n\n      if (errors.length !== 0) {\n        returnType = _unionType.UnionType.term(null, {}, returnTypes);\n        throwableType = new _throwsType.$ThrowsResult(null, {}, _unionType.UnionType.term(null, {}, errors));\n      }\n    } else {\n      throwableType = returnType;\n      returnType = _type.Type.Undefined;\n    }\n  }\n\n  if (currentNode.async) {\n    const unknownPromise = _type.Type.Unknown.promisify();\n\n    if (!unknownPromise.isPrincipalTypeFor(returnType) && currentNode.returnType != undefined) {\n      throw new _errors2.default(`Return type of async function should be an promise`, currentNode.returnType.loc);\n    }\n  }\n\n  const genericArgumentsTypes = [...genericArguments];\n\n  const typeName = _functionType.FunctionType.getName(argumentsTypes, returnType, genericArgumentsTypes, currentNode.async, throwableType && throwableType.errorType);\n\n  const type = _functionType.FunctionType.term(typeName, {}, argumentsTypes, returnType);\n\n  type.isAsync = currentNode.async === true;\n  type.throwable = throwableType && throwableType.errorType;\n\n  if (genericArgumentsTypes.length === 0 || !(type instanceof _functionType.FunctionType)) {\n    return type;\n  }\n\n  return _genericType.GenericType.new(typeName, {}, genericArgumentsTypes, localTypeScope, type);\n}\n\nfunction getCallTarget(call, withClean = true) {\n  let callTargetType = call.target instanceof _variableInfo.VariableInfo ? call.target.type : call.target;\n\n  if (callTargetType instanceof _immutableType.$AppliedImmutable) {\n    callTargetType = callTargetType.readonly;\n  }\n\n  if (callTargetType instanceof _typeVar.TypeVar) {\n    callTargetType = _type.Type.getTypeRoot(callTargetType);\n  }\n\n  if (callTargetType instanceof _genericType.GenericType) {\n    callTargetType = getRawFunctionType(callTargetType, call.arguments, null, callTargetType.localTypeScope, call.loc, // $FlowIssue\n    withClean);\n  }\n\n  return callTargetType;\n}\n\nconst isArgumentVariable = x => {\n  const type = x instanceof _variableInfo.VariableInfo ? x.type : x;\n  return type instanceof _typeVar.TypeVar;\n};\n\nfunction resolveOuterTypeVarsFromCall(call, genericArguments, oldGenericArguments, typeScope, typeGraph) {\n  const callTarget = getCallTarget(call, false);\n\n  if (callTarget === undefined) {\n    return;\n  } // $FlowIssue\n\n\n  const level = oldGenericArguments[0];\n  const roots = new Map();\n\n  for (let i = 0; i < call.arguments.length; i++) {\n    const callArgument = call.arguments[i];\n    let actualType = callArgument instanceof _variableInfo.VariableInfo ? callArgument.type : callArgument;\n    let declaratedType = callTarget.argumentsTypes[i];\n\n    if (actualType === undefined || declaratedType === undefined) {\n      continue;\n    }\n\n    if (declaratedType instanceof _functionType.RestArgument) {\n      actualType = _tupleType.TupleType.term(null, {}, call.arguments.slice(i).map(a => a instanceof _variableInfo.VariableInfo ? a.type : a));\n      i = call.arguments.length;\n    }\n\n    actualType = _type.Type.getTypeRoot(actualType, true);\n    declaratedType = _type.Type.getTypeRoot(declaratedType); // $FlowIssue\n\n    let difference = declaratedType.parent.priority > actualType.parent.priority ? actualType.getDifference(declaratedType, true) : declaratedType.getDifference(actualType, true);\n\n    for (let j = 0; j < difference.length; j++) {\n      let {\n        root,\n        variable\n      } = difference[j];\n\n      if (_typeVar.TypeVar.isSelf(root)) {\n        continue;\n      }\n\n      root = _type.Type.getTypeRoot(root);\n      variable = _type.Type.getTypeRoot(variable, true);\n\n      if (!genericArguments.some(arg => arg.contains(variable)) || genericArguments.includes(variable) && variable.isUserDefined) {\n        continue;\n      }\n\n      const shouldSetNewRoot = variable instanceof _typeVar.TypeVar && !root.contains(variable) && (variable.constraint === undefined || variable.constraint.isPrincipalTypeFor(root)) && (variable.root === undefined || variable.root.isSuperTypeFor(variable.root));\n\n      if (!genericArguments.includes(variable)) {\n        genericArguments.push(variable);\n      }\n\n      if (!shouldSetNewRoot) {\n        continue;\n      }\n\n      variable.root = root;\n    }\n  }\n}\n\nfunction implicitApplyGeneric(fn, argumentsTypes, localTypeScope, loc, withClean = true, dropUnknown = false) {\n  const appliedArgumentsTypes = new Map();\n  const unreachableTypes = new Set();\n  const declaratedArgumentsTypes = fn.subordinateType.argumentsTypes;\n\n  for (let i = 0; i < declaratedArgumentsTypes.length; i++) {\n    const maybeBottom = declaratedArgumentsTypes[i];\n    const givenArgument = argumentsTypes[i] || _type.Type.Undefined;\n    let givenArgumentType = givenArgument instanceof _variableInfo.VariableInfo ? givenArgument.type : givenArgument;\n    let declaratedArgument = maybeBottom;\n    declaratedArgument = declaratedArgument instanceof _bottomType.$BottomType ? declaratedArgument.unpack() : declaratedArgument;\n    declaratedArgument = declaratedArgument instanceof _genericType.GenericType ? declaratedArgument.subordinateType : declaratedArgument;\n\n    if (declaratedArgument instanceof _functionType.RestArgument) {\n      givenArgumentType = _tupleType.TupleType.term(null, {}, argumentsTypes.slice(i).map(a => a instanceof _variableInfo.VariableInfo ? a.type : a));\n      declaratedArgument = declaratedArgument.type;\n    }\n\n    const difference = givenArgumentType.getDifference(declaratedArgument, true);\n\n    for (let j = 0; j < difference.length; j++) {\n      let {\n        root,\n        variable\n      } = difference[j];\n\n      if (_typeVar.TypeVar.isSelf(root)) {\n        continue;\n      }\n\n      root = _type.Type.getTypeRoot(root);\n      variable = _type.Type.getTypeRoot(variable); // $FlowIssue\n\n      variable = fn.genericArguments.find(arg => arg.equalsTo(variable));\n\n      if (variable === undefined) {\n        continue;\n      }\n\n      const existed = appliedArgumentsTypes.get(variable);\n      const shouldSetNewRoot = variable instanceof _typeVar.TypeVar && variable !== root && (existed === undefined || existed instanceof _typeVar.TypeVar || dropUnknown && existed === _type.Type.Unknown || !(root instanceof _typeVar.TypeVar && !root.isUserDefined) && root.isSuperTypeFor(existed));\n\n      if (!shouldSetNewRoot) {\n        const principal = existed && existed.findPrincipal(root);\n\n        if (principal === undefined) {\n          continue;\n        }\n\n        root = principal;\n      }\n\n      appliedArgumentsTypes.set(variable, root);\n    }\n\n    if (maybeBottom instanceof _bottomType.$BottomType) {\n      maybeBottom.unrootSubordinateType();\n    }\n  }\n\n  const rootFinder = t => {\n    const root = _type.Type.getTypeRoot(t);\n\n    let mainRoot = appliedArgumentsTypes.get(root);\n\n    while (appliedArgumentsTypes.has(mainRoot)) {\n      mainRoot = appliedArgumentsTypes.get(mainRoot);\n    }\n\n    return mainRoot;\n  };\n\n  const appliedParameters = fn.genericArguments.map(t => {\n    const resultType = rootFinder(t) || _type.Type.getTypeRoot(t);\n\n    if (resultType instanceof _typeVar.TypeVar && !(0, _typeUtils.isReachableType)(resultType, localTypeScope)) {\n      unreachableTypes.add(resultType);\n    }\n\n    if (resultType instanceof _typeVar.TypeVar && resultType === t && resultType.defaultType !== undefined) {\n      return rootFinder(resultType.defaultType) || _type.Type.getTypeRoot(resultType.defaultType);\n    }\n\n    return resultType;\n  });\n  const result = fn.applyGeneric(appliedParameters, loc).generalize([...unreachableTypes], localTypeScope);\n\n  if (withClean) {\n    fn.genericArguments.forEach(clearRoot);\n  }\n\n  return result;\n}\n\nconst invocationTypeNames = [\"_q\", \"_r\", \"_s\", \"_t\", \"_u\", \"_v\", \"_w\", \"_x\", \"_y\", \"_z\"];\nlet iterator = 0;\n\nfunction getRawFunctionType(fn, args, genericArguments, localTypeScope, loc, withClean = true, initializing = false, dropUnknown = false) {\n  fn = fn instanceof _typeVar.TypeVar && fn.root !== undefined ? _type.Type.getTypeRoot(fn) : fn;\n  fn = fn instanceof _bottomType.$BottomType ? fn.unpack(loc) : fn;\n\n  if (fn instanceof _functionType.FunctionType) {\n    return fn;\n  }\n\n  if (fn instanceof _typeVar.TypeVar) {\n    if (fn.isUserDefined) {\n      throw new Error(\"Never!\");\n    }\n\n    const argTypes = args.map(a => {\n      const result = a instanceof _variableInfo.VariableInfo ? a.type : a;\n\n      if (result instanceof _typeVar.TypeVar && !(0, _typeUtils.isReachableType)(result, fn.parent)) {\n        fn.parent.body.set(result.name, result);\n      }\n\n      return result;\n    });\n    const returnTypeName = invocationTypeNames[iterator];\n\n    const returnType = _typeVar.TypeVar.new(returnTypeName, {\n      parent: fn.parent\n    });\n\n    const newFunctionTypeName = _functionType.FunctionType.getName(argTypes, returnType, []);\n\n    const result = _functionType.FunctionType.term(newFunctionTypeName, {\n      parent: localTypeScope\n    }, argTypes, returnType);\n\n    fn.root = result;\n    return result;\n  }\n\n  let result = genericArguments != null ? // $FlowIssue\n  fn.applyGeneric(genericArguments, loc, true, false, initializing) : implicitApplyGeneric(fn, args, localTypeScope, loc, withClean, dropUnknown);\n\n  if (result instanceof _bottomType.$BottomType) {\n    result = result.unpack();\n  }\n\n  if (result instanceof _bottomType.$BottomType) {\n    result = result.subordinateMagicType;\n  }\n\n  if (result instanceof _genericType.GenericType) {\n    result = result.subordinateType;\n  }\n\n  return result;\n}\n\nfunction getInvocationType(fn, argumentsTypes, genericArguments, localTypeScope, loc, initializing = false, dropUnknown = false) {\n  let {\n    returnType\n  } = fn instanceof _functionType.FunctionType ? fn : getRawFunctionType(fn, argumentsTypes, genericArguments, localTypeScope, loc, true, initializing, dropUnknown);\n  returnType = returnType instanceof _typeVar.TypeVar ? _type.Type.getTypeRoot(returnType) : returnType;\n  returnType = returnType instanceof _bottomType.$BottomType && (returnType.genericArguments.every(t => !(t instanceof _typeVar.TypeVar)) || returnType.subordinateMagicType instanceof _propertyType.$PropertyType) ? returnType.unpack() : returnType;\n  return returnType instanceof _typeVar.TypeVar ? _type.Type.getTypeRoot(returnType) : returnType;\n}\n\nfunction clearRoot(type) {\n  type.root = undefined;\n}\n\nfunction prepareGenericFunctionType(functionScope) {\n  const {\n    genericArguments\n  } = functionScope.declaration.type;\n\n  for (let i = 0; i < genericArguments.length; i++) {\n    const genericArgument = genericArguments[i];\n\n    if (genericArgument instanceof _typeVar.TypeVar && genericArgument.isUserDefined) {\n      clearRoot(genericArgument);\n    }\n  }\n}\n\nfunction inferenceFunctionTypeByScope(functionScope, typeScope, typeGraph) {\n  const {\n    calls = []\n  } = functionScope;\n  const {\n    genericArguments: oldGenericArguments,\n    localTypeScope,\n    subordinateType: {\n      argumentsTypes,\n      returnType,\n      isAsync,\n      throwable\n    }\n  } = functionScope.declaration.type;\n  const genericArguments = [...oldGenericArguments];\n  let returnWasCalled = false;\n  let finalReturnWasCalled = false; // $FlowIssue\n\n  const nestedScopes = functionScope.getAllChildScopes(typeGraph);\n\n  for (const {\n    calls\n  } of nestedScopes) {\n    for (let i = 0; i < calls.length; i++) {\n      resolveOuterTypeVarsFromCall(calls[i], genericArguments, oldGenericArguments, localTypeScope, typeGraph);\n    }\n  }\n\n  for (let i = 0; i < calls.length; i++) {\n    const call = calls[i];\n\n    if (call.isFinal) {\n      finalReturnWasCalled = true;\n    }\n\n    if (call.targetName === \"return\" && returnType instanceof _typeVar.TypeVar && !returnType.isUserDefined) {\n      returnWasCalled = true;\n      const {\n        arguments: [returnArgument],\n        inferenced\n      } = call;\n      const newReturnType = returnArgument instanceof _variableInfo.VariableInfo ? returnArgument.type : returnArgument;\n      const newOneRoot = (0, _variableUtils.getVariableType)(undefined, newReturnType instanceof _typeVar.TypeVar ? _type.Type.getTypeRoot(newReturnType) : newReturnType, typeScope, inferenced);\n\n      if (newOneRoot === returnType) {\n        continue;\n      }\n\n      const oldRoot = _type.Type.getTypeRoot(returnType);\n\n      if (returnType.root === undefined || newOneRoot.isPrincipalTypeFor(oldRoot)) {\n        returnType.root = newOneRoot;\n      } else if (!oldRoot.isPrincipalTypeFor(newOneRoot)) {\n        const variants = (oldRoot instanceof _unionType.UnionType ? oldRoot.variants : [oldRoot]).concat([newOneRoot]);\n        returnType.root = _unionType.UnionType.term(null, {}, variants);\n      }\n    }\n  }\n\n  if (!returnWasCalled && returnType instanceof _typeVar.TypeVar && !returnType.isUserDefined) {\n    returnType.root = isAsync ? _type.Type.Undefined.promisify() : _type.Type.Undefined;\n  }\n\n  if (returnWasCalled && !finalReturnWasCalled && returnType instanceof _typeVar.TypeVar && !returnType.isUserDefined) {\n    const variants = returnType.root !== undefined ? [_type.Type.getTypeRoot(returnType)] : [];\n    returnType.root = _unionType.UnionType.term(null, {}, [...variants, isAsync ? _type.Type.Undefined.promisify() : _type.Type.Undefined]);\n  }\n\n  const created = new Map();\n\n  for (let i = 0; i < genericArguments.length; i++) {\n    const genericArg = genericArguments[i];\n\n    const root = _type.Type.getTypeRoot(genericArg);\n\n    if (root instanceof _typeVar.TypeVar && !genericArguments.includes(root)) {\n      const alreadyCreated = created.get(root);\n      const newRoot = alreadyCreated !== undefined ? alreadyCreated : Object.assign(new _typeVar.TypeVar(\"\"), root, {\n        isUserDefined: false\n      });\n      genericArg.root = newRoot;\n\n      if (alreadyCreated === undefined) {\n        created.set(root, newRoot);\n      }\n    }\n  }\n\n  const [allVars, allRoots] = genericArguments.reduce(([vars, roots], t) => t.root !== undefined ? [vars.concat([t]), roots.concat([_type.Type.getTypeRoot(t)])] : [vars, roots], [[], []]);\n\n  for (const scope of nestedScopes) {\n    for (const [_, v] of scope.body) {\n      if (v.type instanceof _typeVar.TypeVar && v.type.root != undefined) {\n        v.type = _type.Type.getTypeRoot(v.type);\n      } else {\n        // $FlowIssue\n        v.type = v.type.changeAll(allVars, allRoots);\n      }\n    }\n  }\n\n  let newGenericArguments = new Set();\n  const newArgumentsTypes = argumentsTypes.map(t => {\n    let result = t instanceof _typeVar.TypeVar && t.root != undefined ? _type.Type.getTypeRoot(t) : t; // $FlowIssue\n\n    result = result.changeAll(allVars, allRoots, typeScope);\n\n    if (result instanceof _typeVar.TypeVar && // $FlowIssue\n    !(0, _typeUtils.isReachableType)(result, localTypeScope.parent)) {\n      newGenericArguments.add(result);\n    }\n\n    return result;\n  });\n  let newReturnType = returnType instanceof _typeVar.TypeVar && returnType.root != undefined ? _type.Type.getTypeRoot(returnType) : returnType;\n  newReturnType = newReturnType.changeAll(allVars, allRoots, typeScope);\n\n  if (newReturnType instanceof _typeVar.TypeVar) {\n    newGenericArguments.add(newReturnType);\n  }\n\n  const shouldBeCleaned = [];\n\n  for (const {\n    calls\n  } of nestedScopes) {\n    for (let i = 0; i < calls.length; i++) {\n      const call = calls[i];\n      const args = call.arguments;\n      const target = call.target;\n      const targetType = target instanceof _variableInfo.VariableInfo ? target.type : target;\n\n      for (let j = 0; j < args.length; j++) {\n        const argument = args[j];\n        const argumentType = argument instanceof _variableInfo.VariableInfo ? argument.type : argument;\n\n        if (!(argumentType instanceof _typeVar.TypeVar)) {\n          if (argument instanceof _type.Type) {\n            args[j] = argument.changeAll(allVars, allRoots, typeScope);\n          }\n\n          continue;\n        }\n\n        const copy = created.get(argumentType);\n\n        if (argumentType.root !== undefined) {\n          args[j] = _type.Type.getTypeRoot(argumentType);\n\n          if (oldGenericArguments.includes(argumentType) && argumentType.isUserDefined) {\n            shouldBeCleaned.push(argumentType);\n          }\n        } else if (copy !== undefined) {\n          args[j] = copy;\n\n          if (call.targetName === \"return\" && call.target instanceof _functionType.FunctionType) {\n            // $FlowIssue\n            call.target = targetType.changeAll([argumentType], [copy], typeScope);\n          }\n        }\n      }\n\n      if (targetType instanceof _genericType.GenericType) {\n        targetType.genericArguments.forEach(a => a.isUserDefined && shouldBeCleaned.push(a));\n      }\n    }\n  }\n\n  for (let i = 0; i < oldGenericArguments.length; i++) {\n    const genericArgument = oldGenericArguments[i];\n\n    if (genericArgument.isUserDefined) {\n      newGenericArguments.add(genericArgument);\n      continue;\n    }\n\n    const oldRoot = _type.Type.getTypeRoot(genericArgument);\n\n    clearRoot(genericArgument);\n    const isTypeVarStillExisted = newArgumentsTypes.find(arg => arg.contains(genericArgument) && !(0, _typeUtils.isReachableType)(arg, localTypeScope.parent));\n\n    if (isTypeVarStillExisted && genericArgument instanceof _typeVar.TypeVar) {\n      newGenericArguments.add(genericArgument);\n    }\n\n    if (genericArgument instanceof _typeVar.TypeVar && !genericArgument.isUserDefined && genericArgument !== oldRoot) {\n      genericArgument.root = oldRoot;\n    }\n  }\n\n  for (let i = 0; i < genericArguments.length; i++) {\n    const genericArgument = genericArguments[i];\n\n    const root = _type.Type.getTypeRoot(genericArgument.changeAll(allVars, allRoots, localTypeScope));\n\n    if (!(root instanceof _typeVar.TypeVar) || oldGenericArguments.some(a => root.equalsTo(a, true) || genericArgument.equalsTo(a, true))) {\n      continue;\n    }\n\n    newGenericArguments.add(root);\n  }\n\n  shouldBeCleaned.forEach(clearRoot);\n  const newGenericArgumentsTypes = [...newGenericArguments].filter(t => !(0, _typeUtils.isReachableType)(t, localTypeScope.parent)).map(t => {\n    t.isUserDefined = true;\n    return t;\n  });\n\n  const newFunctionTypeName = _functionType.FunctionType.getName(newArgumentsTypes, newReturnType, newGenericArgumentsTypes, isAsync, throwable);\n\n  let newFunctionType = _functionType.FunctionType.term(newFunctionTypeName, {}, newArgumentsTypes, newReturnType, isAsync);\n\n  if (newFunctionType instanceof _functionType.FunctionType && newFunctionType.throwble === undefined) {\n    newFunctionType.throwable = throwable;\n  }\n\n  if (newGenericArgumentsTypes.length > 0) {\n    newFunctionType = _genericType.GenericType.new(newFunctionTypeName, {}, newGenericArgumentsTypes, localTypeScope, newFunctionType);\n  } // $FlowIssue\n\n\n  functionScope.declaration.type = newFunctionType;\n}\n\nfunction isGenericFunctionType(type) {\n  return type instanceof _genericType.GenericType && type.subordinateType instanceof _functionType.FunctionType;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inRefinement = inRefinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _common = require(\"../utils/common\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _inferenceUtils = require(\"../utils/inference-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inIdentifier(targetNode, currentScope, typeScope, propertyName, refinementNode) {\n  const variable = currentScope.findVariable(targetNode);\n  const type = variable.type;\n\n  if (type instanceof _unionType.UnionType) {\n    const [refinementedVariants, alternateVariants] = type.variants.reduce(([refinementedVariants, alternateVariants], variant) => {\n      if (variant instanceof _objectType.ObjectType && variant.getPropertyType(propertyName)) {\n        return [refinementedVariants.concat([variant]), alternateVariants];\n      }\n\n      return [refinementedVariants, alternateVariants.concat([variant])];\n    }, [[], []]);\n    return [targetNode.name, ...(0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope)];\n  }\n\n  if (type instanceof _objectType.ObjectType && !type.isStrict && type.getPropertyType(targetNode.name) === null) {\n    return [targetNode.name, _objectType.ObjectType.term(null, {\n      isSoft: true\n    }, [...type.properties, [propertyName, new _variableInfo.VariableInfo(_type.Type.Unknown, currentScope)]]), type];\n  }\n}\n\nfunction refinementProperty(variableName, variableType, propertyName, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope) {\n  const currentPropertyName = chainingProperties[currentPropertyNameIndex];\n  const isLast = currentPropertyNameIndex === chainingProperties.length - 1;\n\n  if (variableType instanceof _objectType.ObjectType) {\n    const property = variableType.properties.get(currentPropertyName);\n\n    if (property === undefined) {\n      return;\n    }\n\n    const propertyType = property.type;\n\n    if (isLast) {\n      if (!(propertyType instanceof _unionType.UnionType) && !(propertyType instanceof _objectType.ObjectType)) {\n        throw new _errors2.default(`Property has not \"${propertyName}\" property`, refinementNode.loc);\n      }\n\n      if (propertyType instanceof _objectType.ObjectType) {\n        const existed = propertyType.getPropertyType(propertyName);\n\n        if (!propertyType.isStrict && !existed) {\n          return [(0, _typeUtils.mergeObjectsTypes)(propertyType, (0, _typeUtils.createObjectWith)(propertyName, _type.Type.Unknown, typeScope), typeScope), property.type];\n        }\n\n        return existed ? [propertyType, undefined] : [undefined, propertyType];\n      }\n\n      const [refinementedVariants, alternateVariants] = propertyType.variants.reduce(([refinementedVariants, alternateVariants], variant) => variant instanceof _objectType.ObjectType && variant.getPropertyType(propertyName) ? [refinementedVariants.concat([variant]), alternateVariants] : [refinementedVariants, alternateVariants.concat([variant])], [[], []]);\n      const refinement = (0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope);\n      return (0, _inferenceUtils.mergeRefinementsVariants)(refinement[0], refinement[1], new _variableInfo.VariableInfo(_objectType.ObjectType.term(\"{ }\", {}, []), property.parent, property.meta), currentPropertyName, typeScope);\n    }\n\n    return refinementProperty(variableName, property.type, propertyName, refinementNode, currentPropertyNameIndex + 1, chainingProperties, typeScope);\n  }\n\n  if (variableType instanceof _unionType.UnionType) {\n    const [refinementedVariants, alternateVariants] = variableType.variants.reduce(([refinementedVariants, alternateVariants], variant) => {\n      const isNotAlternateVariant = variant instanceof _objectType.ObjectType && variant.getPropertyType(currentPropertyName);\n      const refinementedTypeAndAlternateType = isNotAlternateVariant ? refinementProperty(variableName, variant, propertyName, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope) : undefined;\n\n      if (!refinementedTypeAndAlternateType) {\n        return [refinementedVariants, alternateVariants.concat([variant])];\n      }\n\n      const [refinementedType, alternateType] = refinementedTypeAndAlternateType;\n      return [refinementedType ? refinementedVariants.concat([(0, _typeUtils.mergeObjectsTypes)(variant, (0, _typeUtils.createObjectWith)(currentPropertyName, refinementedType, typeScope), typeScope)]) : refinementedVariants, alternateType ? alternateVariants.concat([(0, _typeUtils.mergeObjectsTypes)(variant, (0, _typeUtils.createObjectWith)(currentPropertyName, alternateType, typeScope), typeScope)]) : alternateVariants];\n    }, [[], []]);\n    return (0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope);\n  }\n}\n\nfunction inProperty(targetNode, currentScope, typeScope, propertyName, refinementNode) {\n  const targetObject = (0, _common.getMemberExressionTarget)(targetNode);\n\n  if (targetObject.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const variableName = targetObject.name;\n  const propertiesChaining = (0, _inferenceUtils.getPropertyChaining)(targetNode);\n  const targetVariableInfo = currentScope.findVariable(targetObject);\n\n  if (!variableName || !targetVariableInfo || !propertiesChaining || targetVariableInfo instanceof _variableScope.VariableScope) {\n    return;\n  }\n\n  const refinmentedAndAlternate = refinementProperty(variableName, targetVariableInfo.type, propertyName, refinementNode, 0, propertiesChaining, typeScope);\n\n  if (!refinmentedAndAlternate) {\n    return;\n  }\n\n  if (!refinmentedAndAlternate[0] || !refinmentedAndAlternate[1]) {\n    throw new _errors2.default(`Property always ${refinmentedAndAlternate[0] === undefined ? \"has not\" : \"has\"} property \"${propertyName}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinmentedAndAlternate[0], refinmentedAndAlternate[1]];\n}\n\nfunction inRefinement(currentRefinementNode, currentScope, typeScope, moduleScope) {\n  if (currentRefinementNode.left.type !== _nodes2.default.STRING_LITERAL || currentRefinementNode.right.type !== _nodes2.default.IDENTIFIER && currentRefinementNode.right.type !== _nodes2.default.MEMBER_EXPRESSION) {\n    return;\n  }\n\n  const {\n    left: propertyNameNode,\n    right: targetNode\n  } = currentRefinementNode;\n  const propertyName = propertyNameNode.value;\n  let refinementedType, alternateType, name;\n\n  if (currentRefinementNode.right.type === _nodes2.default.IDENTIFIER) {\n    const result = inIdentifier(currentRefinementNode.right, currentScope, typeScope, propertyName, currentRefinementNode);\n\n    if (!result) {\n      return;\n    }\n\n    [name, refinementedType, alternateType] = result;\n  }\n\n  if (currentRefinementNode.right.type === _nodes2.default.MEMBER_EXPRESSION) {\n    const result = inProperty(currentRefinementNode.right, currentScope, typeScope, propertyName, currentRefinementNode);\n\n    if (!result) {\n      return;\n    }\n\n    [name, refinementedType, alternateType] = result;\n  }\n\n  return name && refinementedType && alternateType ? [name, refinementedType, alternateType] : undefined;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inferenceTypeForNode = inferenceTypeForNode;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _constants = require(\"../type-graph/constants\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _functionType = require(\"./function-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inferenceTypeForNode(currentNode, typeScope, parentScope, typeGraph, parentNode, pre, middle, post, isTypeDefinitions = false, isImmutable = false) {\n  let result = null;\n\n  switch (currentNode.type) {\n    case _nodes2.default.NUMERIC_LITERAL:\n      result = _type.Type.term(currentNode.value, {\n        isSubtypeOf: _type.Type.Number\n      });\n      break;\n\n    case _nodes2.default.BIGINT_LITERAL:\n      result = _type.Type.term(`${currentNode.value}n`, {\n        isSubtypeOf: _type.Type.BigInt\n      });\n      break;\n\n    case _nodes2.default.TEMPLATE_LITERAL:\n      result = _type.Type.String;\n      break;\n\n    case _nodes2.default.STRING_LITERAL:\n      result = _type.Type.term(`'${currentNode.value}'`, {\n        isSubtypeOf: _type.Type.String\n      });\n      break;\n\n    case _nodes2.default.BOOLEAN_LITERAL:\n      result = _type.Type.term(currentNode.value);\n      break;\n\n    case _nodes2.default.NULL_LITERAL:\n      result = _type.Type.Null;\n      break;\n\n    case _nodes2.default.REG_EXP_LITERAL:\n      result = _type.Type.find(\"RegExp\");\n      break;\n\n    case _nodes2.default.ARRAY_EXPRESSION:\n      result = (0, _tupleType.inferenceTupleType)(currentNode, typeScope, parentScope, typeGraph, parentNode, pre, middle, post);\n      break;\n\n    case _nodes2.default.OBJECT_EXPRESSION:\n    case _nodes2.default.CLASS_EXPRESSION:\n      const objectScope = typeGraph.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n      if (objectScope === undefined) {\n        throw new Error(\"Never!!!\");\n      }\n\n      const self = objectScope.type === _variableScope.VariableScope.OBJECT_TYPE ? objectScope.body.get(_constants.THIS_TYPE) : objectScope.declaration;\n\n      if (!(self instanceof _variableInfo.VariableInfo)) {\n        throw new Error(\"Never!!!\");\n      }\n\n      result = self.type;\n      break;\n\n    case _nodes2.default.OBJECT_METHOD:\n    case _nodes2.default.CLASS_METHOD:\n    case _nodes2.default.CLASS_PRIVATE_METHOD:\n    case _nodes2.default.FUNCTION_DECLARATION:\n    case _nodes2.default.TS_DECLARE_METHOD:\n    case _nodes2.default.FUNCTION_EXPRESSION:\n    case _nodes2.default.ARROW_FUNCTION_EXPRESSION:\n    case _nodes2.default.TS_FUNCTION_DECLARATION:\n      result = (0, _functionType.inferenceFunctionLiteralType)(currentNode, typeScope, parentScope, typeGraph, isTypeDefinitions, parentNode, pre, middle, post);\n      break;\n\n    case _nodes2.default.IDENTIFIER:\n    case _nodes2.default.THIS_EXPRESSION:\n      const query = { ...currentNode,\n        name: currentNode.name || _constants.THIS_TYPE\n      };\n      const variableInfo = parentScope.findVariable(query);\n      result = variableInfo.type;\n      break;\n  }\n\n  if (isImmutable && result !== null && currentNode.type !== _nodes2.default.IDENTIFIER && currentNode.type !== _nodes2.default.THIS_EXPRESSION) {\n    result = _immutableType.$AppliedImmutable.term(null, {}, result);\n  }\n\n  if (result) {\n    return result;\n  }\n\n  throw new Error(currentNode.type);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.instanceofRefinement = instanceofRefinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _common = require(\"../utils/common\");\n\nvar _inferenceUtils = require(\"../utils/inference-utils\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction instanceofIdentifier(targetNode, constructor, currentScope, typeScope, refinementNode) {\n  const variable = currentScope.findVariable(targetNode);\n  const type = variable.type;\n\n  if (!(type instanceof _unionType.UnionType) && type !== _type.Type.Unknown && !(type instanceof _typeVar.TypeVar) && !type.isPrincipalTypeFor(constructor)) {\n    throw new _errors2.default(`Variable can't be an instance of \"${refinementNode.right.name}\"`, refinementNode.loc);\n  }\n\n  if (type.equalsTo(constructor)) {\n    throw new _errors2.default(`Variable is always instance of \"${refinementNode.right.name}\"`, refinementNode.loc);\n  }\n\n  if (type === _type.Type.Unknown || !(type instanceof _unionType.UnionType)) {\n    return [targetNode.name, constructor, type];\n  } // $FlowIssue\n\n\n  const [refinementedVariants, alternateVariants] = type.variants.reduce(([refinementedVariants, alternateVariants], variant) => constructor.isPrincipalTypeFor(variant) ? [refinementedVariants.concat([variant]), alternateVariants] : [refinementedVariants, alternateVariants.concat([variant])], [[], []]);\n  return [targetNode.name, ...(0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope)];\n}\n\nfunction refinementProperty(variableName, variableType, constructor, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope) {\n  const currentPropertyName = chainingProperties[currentPropertyNameIndex];\n  const isLast = currentPropertyNameIndex === chainingProperties.length - 1;\n\n  if (variableType instanceof _objectType.ObjectType) {\n    const property = variableType.properties.get(currentPropertyName);\n\n    if (property === undefined) {\n      return;\n    }\n\n    if (isLast) {\n      if (!(property.type instanceof _unionType.UnionType)) {\n        return constructor.isPrincipalTypeFor(property.type) ? [property.type, undefined] : [undefined, property.type];\n      }\n\n      const [refinementedVariants, alternateVariants] = property.type.variants.reduce(([refinementedVariants, alternateVariants], variant) => {\n        const refinmentedProperty = variant instanceof _objectType.ObjectType ? variant.properties.get(currentPropertyName) : undefined;\n        return refinmentedProperty && constructor.isSuperTypeFor(refinementProperty.type) ? [refinementedVariants.concat([variant]), alternateVariants] : [refinementedVariants, alternateVariants.concat([variant])];\n      }, [[], []]);\n      return (0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope);\n    }\n\n    return refinementProperty(variableName, property.type, constructor, refinementNode, currentPropertyNameIndex + 1, chainingProperties, typeScope);\n  }\n\n  if (variableType instanceof _unionType.UnionType) {\n    const [refinementedVariants, alternateVariants] = variableType.variants.reduce(([refinementedVariants, alternateVariants], variant) => {\n      const isNotAlternateVariant = variant instanceof _objectType.ObjectType && variant.getPropertyType(currentPropertyName);\n      const refinementedTypeAndAlternateType = isNotAlternateVariant ? refinementProperty(variableName, variant, constructor, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope) : undefined;\n\n      if (!refinementedTypeAndAlternateType) {\n        return [refinementedVariants, alternateVariants.concat([variant])];\n      }\n\n      const [refinementedType, alternateType] = refinementedTypeAndAlternateType;\n      return [refinementedType ? refinementedVariants.concat([(0, _typeUtils.mergeObjectsTypes)(variant, (0, _typeUtils.createObjectWith)(currentPropertyName, refinementedType, typeScope), typeScope)]) : refinementedVariants, alternateType ? alternateVariants.concat([(0, _typeUtils.mergeObjectsTypes)(variant, (0, _typeUtils.createObjectWith)(currentPropertyName, alternateType, typeScope), typeScope)]) : alternateVariants];\n    }, [[], []]);\n    return (0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope);\n  }\n}\n\nfunction instanceofProperty(targetNode, constructor, currentScope, typeScope, refinementNode) {\n  const targetObject = (0, _common.getMemberExressionTarget)(targetNode);\n\n  if (targetObject.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const variableName = targetObject.name;\n  const propertiesChaining = (0, _inferenceUtils.getPropertyChaining)(targetNode);\n  const targetVariableInfo = currentScope.findVariable(targetObject);\n\n  if (!variableName || !targetVariableInfo || !propertiesChaining || targetVariableInfo instanceof _variableScope.VariableScope) {\n    return;\n  }\n\n  const refinmentedAndAlternate = refinementProperty(variableName, targetVariableInfo.type, constructor, refinementNode, 0, propertiesChaining, typeScope);\n\n  if (!refinmentedAndAlternate) {\n    return;\n  }\n\n  if (!refinmentedAndAlternate[0] || !refinmentedAndAlternate[1]) {\n    throw new _errors2.default(`Property ${refinmentedAndAlternate[0] === undefined ? \"can't be\" : \"is always\"} instance of \"${refinementNode.right.name}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinmentedAndAlternate[0], refinmentedAndAlternate[1]];\n}\n\nfunction instanceofRefinement(currentRefinementNode, currentScope, typeScope, moduleScope) {\n  const {\n    left: target,\n    right: constructorNode\n  } = currentRefinementNode;\n\n  if (target.type !== _nodes2.default.IDENTIFIER && target.type !== _nodes2.default.MEMBER_EXPRESSION || constructorNode.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const constructor = currentScope.findVariable(constructorNode);\n\n  if (!(constructor.type instanceof _objectType.ObjectType && constructor.type.instanceType !== null)) {\n    throw new _errors2.default(\"Cannot apply instanceof to non-class type\", constructorNode.loc);\n  }\n\n  const instanceType = constructor.type.instanceType;\n  let refinementedType, alternateType, name;\n\n  if (target.type === _nodes2.default.IDENTIFIER) {\n    [name, refinementedType, alternateType] = instanceofIdentifier(target, instanceType, currentScope, typeScope, currentRefinementNode);\n  }\n\n  if (target.type === _nodes2.default.MEMBER_EXPRESSION) {\n    const result = instanceofProperty(target, instanceType, currentScope, typeScope, currentRefinementNode);\n\n    if (!result) {\n      return;\n    }\n\n    [name, refinementedType, alternateType] = result;\n  }\n\n  return name && refinementedType && alternateType ? [name, refinementedType, alternateType] : undefined;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.refinement = refinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _refinementedType = require(\"../type-graph/types/refinemented-type\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _inOperator = require(\"./in-operator\");\n\nvar _equalsRefinement = require(\"./equals-refinement\");\n\nvar _typeof = require(\"./typeof\");\n\nvar _variableRefinement = require(\"./variable-refinement\");\n\nvar _common = require(\"../utils/common\");\n\nvar _instanceof = require(\"./instanceof\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getScopesForLogicalExpression(condition, currentScope, moduleScope) {\n  const primaryScopeName = _variableScope.VariableScope.getName({\n    loc: {\n      start: condition.loc.end\n    }\n  }); // $FlowIssue\n\n\n  let primaryScope = moduleScope.scopes.get(primaryScopeName);\n\n  if (!(primaryScope instanceof _variableScope.VariableScope)) {\n    primaryScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope);\n    moduleScope.scopes.set(primaryScopeName, primaryScope);\n  }\n\n  const alternateScopeName = _variableScope.VariableScope.getName({\n    loc: {\n      start: condition.loc.start\n    }\n  }); // $FlowIssue\n\n\n  let alternateScope = moduleScope.scopes.get(alternateScopeName);\n\n  if (!(alternateScope instanceof _variableScope.VariableScope)) {\n    alternateScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope);\n    moduleScope.scopes.set(alternateScopeName, alternateScope);\n  }\n\n  return condition.operator === \"&&\" ? [primaryScope, alternateScope] : [alternateScope, primaryScope];\n}\n\nfunction getScopesForSwitchCase(condition, currentScope, moduleScope) {\n  const primaryScopeName = _variableScope.VariableScope.getName(condition.consequent); // $FlowIssue\n\n\n  let primaryScope = moduleScope.scopes.get(primaryScopeName);\n\n  if (!(primaryScope instanceof _variableScope.VariableScope)) {\n    primaryScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope, undefined, condition.test === null ? \"default-case\" : \"case\");\n    moduleScope.scopes.set(primaryScopeName, primaryScope);\n  }\n\n  const currentCaseIndex = condition.parent.cases.indexOf(condition);\n\n  if (currentCaseIndex === -1) {\n    return [primaryScope, []];\n  }\n\n  const alternateScopes = [];\n\n  for (let i = currentCaseIndex + 1; i < condition.parent.cases.length; i++) {\n    const $case = condition.parent.cases[i];\n\n    const alternateScopeName = _variableScope.VariableScope.getName($case.consequent); // $FlowIssue\n\n\n    let alternateScope = moduleScope.scopes.get(alternateScopeName);\n\n    if (!(alternateScope instanceof _variableScope.VariableScope)) {\n      alternateScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope, undefined, $case.test === null ? \"default-case\" : \"case\");\n      moduleScope.scopes.set(alternateScopeName, alternateScope);\n    }\n\n    alternateScopes.push(alternateScope);\n  }\n\n  return [primaryScope, alternateScopes];\n}\n\nfunction getScopesForConditionalExpression(condition, currentScope, moduleScope) {\n  const primaryScopeName = _variableScope.VariableScope.getName({\n    loc: {\n      start: condition.loc.start\n    }\n  }); // $FlowIssue\n\n\n  let primaryScope = moduleScope.scopes.get(primaryScopeName);\n\n  if (!(primaryScope instanceof _variableScope.VariableScope)) {\n    primaryScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope);\n    moduleScope.scopes.set(primaryScopeName, primaryScope);\n  }\n\n  const alternateScopeName = _variableScope.VariableScope.getName({\n    loc: {\n      start: condition.loc.end\n    }\n  }); // $FlowIssue\n\n\n  let alternateScope = moduleScope.scopes.get(alternateScopeName);\n\n  if (!(alternateScope instanceof _variableScope.VariableScope)) {\n    alternateScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope);\n    moduleScope.scopes.set(alternateScopeName, alternateScope);\n  }\n\n  return [primaryScope, alternateScope];\n}\n\nfunction getPrimaryAndAlternativeScopes(currentRefinementNode, currentScope, typeScope, moduleScope) {\n  let primaryScope;\n  let alternateScope;\n\n  switch (currentRefinementNode.type) {\n    case _nodes2.default.IF_STATEMENT:\n      primaryScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(currentRefinementNode.consequent));\n      alternateScope = currentRefinementNode.alternate && moduleScope.scopes.get(_variableScope.VariableScope.getName(currentRefinementNode.alternate));\n      break;\n\n    case _nodes2.default.WHILE_STATEMENT:\n    case _nodes2.default.DO_WHILE_STATEMENT:\n    case _nodes2.default.FOR_STATEMENT:\n      primaryScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(currentRefinementNode.body));\n      break;\n\n    case _nodes2.default.LOGICAL_EXPRESSION:\n      [primaryScope, alternateScope] = getScopesForLogicalExpression(currentRefinementNode, currentScope, moduleScope);\n      break;\n\n    case _nodes2.default.CONDITIONAL_EXPRESSION:\n      [primaryScope, alternateScope] = getScopesForConditionalExpression(currentRefinementNode, currentScope, moduleScope);\n      break;\n\n    case _nodes2.default.SWITCH_CASE:\n      [primaryScope, alternateScope] = getScopesForSwitchCase(currentRefinementNode, currentScope, moduleScope);\n      break;\n  }\n\n  if (!primaryScope || primaryScope instanceof _variableInfo.VariableInfo || alternateScope instanceof _variableInfo.VariableInfo) {\n    throw new Error(\"Never!\");\n  }\n\n  return [primaryScope, alternateScope];\n}\n\nfunction getCondition(currentRefinementNode) {\n  switch (currentRefinementNode.type) {\n    case _nodes2.default.IF_STATEMENT:\n    case _nodes2.default.CONDITIONAL_EXPRESSION:\n    case _nodes2.default.WHILE_STATEMENT:\n    case _nodes2.default.DO_WHILE_STATEMENT:\n    case _nodes2.default.FOR_STATEMENT:\n      return currentRefinementNode.test;\n\n    case _nodes2.default.LOGICAL_EXPRESSION:\n    case _nodes2.default.SWITCH_CASE:\n      return currentRefinementNode;\n  }\n}\n\nfunction intersectionOfTypes(type1, type2, typeScope) {\n  if (type1 instanceof _unionType.UnionType && type2 instanceof _unionType.UnionType) {\n    const intersectedVariants = (0, _common.intersection)(type1.variants, type2.variants, (a, b) => a.equalsTo(b))[0];\n    return _unionType.UnionType.term(null, {}, intersectedVariants);\n  }\n\n  if (type1 instanceof _unionType.UnionType || type2 instanceof _unionType.UnionType) {\n    // $FlowIssue\n    const [unionType, notUnion] = // $FlowIssue\n    type1 instanceof _unionType.UnionType ? [type1, type2] : [type2, type1];\n    const isTypeExisting = unionType.variants.some(t => t.equalsTo(notUnion));\n    return isTypeExisting ? notUnion : _type.Type.Never;\n  }\n\n  return type1;\n}\n\nfunction unionOfTypes(type1, type2, typeScope) {\n  if (type1 instanceof _unionType.UnionType && type2 instanceof _unionType.UnionType) {\n    const unionVariants = (0, _common.union)(type1.variants, type2.variants, (a, b) => a.equalsTo(b));\n    return _unionType.UnionType.term(null, {}, unionVariants);\n  }\n\n  if (type1 instanceof _unionType.UnionType || type2 instanceof _unionType.UnionType) {\n    const [unionType, notUnion] = type1 instanceof _unionType.UnionType ? [type1, type2] : [type2, type1];\n    const newVariants = (0, _common.union)( // $FlowIssue\n    unionType.variants, [notUnion], (a, b) => a.equalsTo(b));\n    return _unionType.UnionType.term(null, {}, newVariants);\n  }\n\n  if (type1.isPrincipalTypeFor(type2)) {\n    return type1;\n  }\n\n  if (type2.isPrincipalTypeFor(type1)) {\n    return type2;\n  }\n\n  const variants = [type1, type2];\n  return _unionType.UnionType.term(null, {}, variants);\n}\n\nfunction getRefinementByBinaryExpression(binaryExpression, currentScope, typeScope, moduleScope) {\n  switch (binaryExpression.operator) {\n    case \"==\":\n    case \"!=\":\n    case \"===\":\n    case \"!==\":\n      return (0, _typeof.typeofRefinement)(binaryExpression, currentScope, typeScope, moduleScope);\n\n    case \"in\":\n      return (0, _inOperator.inRefinement)(binaryExpression, currentScope, typeScope, moduleScope);\n\n    case \"instanceof\":\n      return (0, _instanceof.instanceofRefinement)(binaryExpression, currentScope, typeScope, moduleScope);\n  }\n}\n\nfunction refinementByCondition(condition, currentScope, typeScope, moduleScope, primaryScope) {\n  switch (condition.type) {\n    case _nodes2.default.SWITCH_CASE:\n      const caseRefinement = (0, _equalsRefinement.equalsRefinement)(condition, primaryScope, typeScope, moduleScope);\n      const indexOfCurrentCase = condition.parent.cases.indexOf(condition);\n      const previousCase = indexOfCurrentCase > 0 ? condition.parent.cases[indexOfCurrentCase - 1] : undefined;\n\n      if (caseRefinement && previousCase && !previousCase.consequent.body.some(a => a.type === _nodes2.default.BREAK_STATEMENT || a.type === _nodes2.default.THROW_STATEMENT || a.type === _nodes2.default.RETURN_STATEMENT)) {\n        const [name, primary, alternate] = caseRefinement;\n        const previousCaseScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(previousCase.consequent));\n\n        if (previousCaseScope === undefined) {\n          throw new Error(\"Never!!!\");\n        }\n\n        const previousPrimaryRefinement = previousCaseScope.body.get(name);\n\n        if (previousPrimaryRefinement === undefined) {\n          return;\n        }\n\n        return [[name, _unionType.UnionType.term(null, {}, [primary, previousPrimaryRefinement.type]), alternate]];\n      }\n\n      return caseRefinement && [caseRefinement];\n\n    case _nodes2.default.UNARY_EXPRESSION:\n      if (condition.operator === \"!\") {\n        const refinements = refinementByCondition(condition.argument, currentScope, typeScope, moduleScope, primaryScope);\n        return refinements && refinements.map(refinement => refinement && [refinement[0], refinement[2], refinement[1]]);\n      }\n\n    case _nodes2.default.BINARY_EXPRESSION:\n      const typeofResult = getRefinementByBinaryExpression(condition, currentScope, typeScope, moduleScope);\n      return typeofResult && [typeofResult];\n\n    case _nodes2.default.IDENTIFIER:\n    case _nodes2.default.MEMBER_EXPRESSION:\n      const refinemented = (0, _variableRefinement.variableRefinement)(condition, currentScope, typeScope, moduleScope);\n      return refinemented && [refinemented];\n\n    case _nodes2.default.LOGICAL_EXPRESSION:\n      const [additionalPrimaryScope, additionalAlternateScope] = getScopesForLogicalExpression(condition, currentScope, moduleScope);\n      const leftSideRefinement = refinementByCondition(condition.left.body || condition.left, currentScope, typeScope, moduleScope, primaryScope);\n\n      if (leftSideRefinement) {\n        leftSideRefinement.forEach(([key, refinement, alternate]) => {\n          if (refinement !== undefined && !additionalPrimaryScope.body.has(key)) {\n            additionalPrimaryScope.body.set(key, new _variableInfo.VariableInfo(refinement, additionalPrimaryScope));\n          }\n\n          if (alternate !== undefined && !additionalAlternateScope.body.has(key)) {\n            additionalAlternateScope.body.set(key, new _variableInfo.VariableInfo(alternate, additionalAlternateScope));\n          }\n        });\n      }\n\n      const rightSideRefinement = refinementByCondition(condition.right.body || condition.right, condition.operator === \"||\" ? additionalAlternateScope : additionalPrimaryScope, typeScope, moduleScope, primaryScope);\n\n      if (!leftSideRefinement || !rightSideRefinement) {\n        return condition.operator === \"&&\" ? leftSideRefinement : rightSideRefinement;\n      }\n\n      const [sameRefinement, other] = (0, _common.intersection)(leftSideRefinement, rightSideRefinement, (a, b) => a[0] === b[0]);\n\n      if (sameRefinement.length === 0) {\n        return other;\n      }\n\n      const sameRefinementVariants = sameRefinement.map(([key, refinementedType, alternateType]) => {\n        const sameRefinement = leftSideRefinement.find(a => a[0] === key);\n\n        if (sameRefinement === undefined) {\n          return [key, refinementedType, alternateType];\n        }\n\n        if (condition.operator === \"||\" && sameRefinement[1] !== undefined && sameRefinement[2] !== undefined) {\n          return [key, unionOfTypes(refinementedType, sameRefinement[1], typeScope), intersectionOfTypes(alternateType, sameRefinement[2], typeScope)];\n        }\n\n        if (condition.operator === \"&&\" && sameRefinement[1] !== undefined && sameRefinement[2] !== undefined) {\n          return [key, intersectionOfTypes(refinementedType, sameRefinement[1], typeScope), unionOfTypes(alternateType, sameRefinement[2], typeScope)];\n        }\n\n        return [key, refinementedType, alternateType];\n      });\n      return sameRefinementVariants.concat(other);\n  }\n}\n\nfunction refinement(currentRefinementNode, currentScope, typeScope, moduleScope, errors) {\n  if (currentRefinementNode.isRefinemented) {\n    return;\n  }\n\n  const [primaryScope, alternateScope] = getPrimaryAndAlternativeScopes(currentRefinementNode, currentScope, typeScope, moduleScope);\n  const alternateScopes = Array.isArray(alternateScope) || alternateScope == undefined ? alternateScope : [alternateScope];\n  const condition = getCondition(currentRefinementNode);\n\n  if (condition == undefined) {\n    return;\n  }\n\n  let currentRefinements;\n\n  try {\n    currentRefinements = refinementByCondition(condition, currentScope, typeScope, moduleScope, primaryScope);\n  } catch (e) {\n    if (!(e instanceof _errors2.default)) {\n      throw e;\n    }\n\n    errors.push(e);\n  }\n\n  if (!currentRefinements) {\n    return;\n  }\n\n  currentRefinements.forEach(refinement => {\n    let [varName, refinementedType, alternateType] = refinement;\n    const existed = currentScope.findVariable({\n      name: varName\n    });\n\n    if (!(existed.type instanceof _unionType.UnionType)) {\n      if (existed.type !== refinementedType) {\n        refinementedType = new _refinementedType.$Refinemented(refinementedType, existed.type);\n      }\n\n      if (existed.type !== alternateType) {\n        alternateType = new _refinementedType.$Refinemented(alternateType, existed.type);\n      }\n    }\n\n    if (!primaryScope.body.has(varName) || condition.type === _nodes2.default.SWITCH_CASE) {\n      primaryScope.body.set(varName, new _variableInfo.VariableInfo(refinementedType, currentScope));\n    }\n\n    if (alternateType && alternateScopes) {\n      alternateScopes.forEach(alternateScope => {\n        if (!alternateScope.body.has(varName) || condition.type === _nodes2.default.SWITCH_CASE) {\n          alternateScope.body.set(varName, new _variableInfo.VariableInfo(alternateType, currentScope));\n        }\n      });\n    }\n  });\n  currentRefinementNode.isRefinemented = true;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findUnhandledCases = findUnhandledCases;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _call = require(\"../type-graph/call\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction findUnhandledCases(node, errors, moduleScope, currentScope, parentNode, pre, middle, post) {\n  const {\n    discriminant,\n    cases\n  } = node; // test equals null only if it's default case\n\n  const hasDefaultCase = cases.some(switchCase => switchCase.test === null);\n  const {\n    result: switchedValue\n  } = (0, _call.addCallToTypeGraph)(discriminant, moduleScope, currentScope, parentNode, pre, middle, post);\n\n  if ( // if switch statement doesn't have default case, we should check whether cases exhaustive or not\n  hasDefaultCase || discriminant.type !== _nodes2.default.IDENTIFIER && discriminant.type !== _nodes2.default.CALL_EXPRESSION && discriminant.type !== _nodes2.default.MEMBER_EXPRESSION) {\n    return;\n  }\n\n  const switchedValueType = switchedValue instanceof _variableInfo.VariableInfo ? switchedValue.type : switchedValue;\n\n  if (!(switchedValueType instanceof _unionType.UnionType)) {\n    return;\n  }\n\n  let unmatchedVariants = [...switchedValueType.variants];\n  cases.forEach(({\n    test\n  }) => {\n    const {\n      result: matcherValue\n    } = (0, _call.addCallToTypeGraph)(test, moduleScope, currentScope, parentNode, pre, middle, post);\n    const matcherValueType = matcherValue instanceof _variableInfo.VariableInfo ? matcherValue.type : matcherValue;\n\n    if (matcherValueType instanceof _unionType.UnionType) {\n      errors.push(new _errors2.default(\"It is not safe to use variable which type is Union as case matcher, you should infer it value first\", node.loc));\n    }\n\n    unmatchedVariants = unmatchedVariants.filter(variant => !variant.equalsTo(matcherValueType));\n  });\n\n  if (unmatchedVariants.length !== 0) {\n    const notMatchedCases = _unionType.UnionType.getName(unmatchedVariants);\n\n    errors.push(new _errors2.default(`This switch case statement is not exhaustive. Here is an example of a case that is not matched: ${notMatchedCases}`, node.loc));\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inferenceTupleType = inferenceTupleType;\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _call = require(\"../type-graph/call\");\n\nfunction inferenceTupleType(currentNode, typeScope, parentScope, typeGraph, parentNode, pre, middle, post) {\n  const items = currentNode.elements.map(a => {\n    if (a === null) {\n      return _type.Type.Undefined;\n    }\n\n    const {\n      result\n    } = (0, _call.addCallToTypeGraph)(a, typeGraph, parentScope, parentNode, pre, middle, post);\n    return result instanceof _type.Type ? result : result.type;\n  });\n  return _tupleType.TupleType.term(null, {}, items);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeofRefinement = typeofRefinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _common = require(\"../utils/common\");\n\nvar _equalsRefinement = require(\"./equals-refinement\");\n\nvar _inferenceUtils = require(\"../utils/inference-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isEqualOperator(node) {\n  return node.type === _nodes2.default.BINARY_EXPRESSION && (node.operator === \"===\" || node.operator === \"==\" || node.operator === \"!==\" || node.operator === \"!=\");\n}\n\nfunction isTypeofOperator(node) {\n  return node.type === _nodes2.default.UNARY_EXPRESSION && node.operator === \"typeof\";\n}\n\nfunction isReturnTypeOfTypeof(node) {\n  return node.type === _nodes2.default.STRING_LITERAL;\n}\n\nfunction getTypeofAndLiteral(left, right, typeofOperator) {\n  let typeofNode = null;\n\n  if (isTypeofOperator(left)) {\n    typeofNode = left;\n  } else if (isTypeofOperator(right)) {\n    typeofNode = right;\n  }\n\n  let stringNode = null;\n\n  if (isReturnTypeOfTypeof(left)) {\n    stringNode = left;\n  } else if (isReturnTypeOfTypeof(right)) {\n    stringNode = right;\n  }\n\n  if (!typeofNode || !stringNode) {\n    return null;\n  }\n\n  return {\n    typeofNode,\n    stringNode\n  };\n}\n\nfunction getRefinmentType(stringNode) {\n  switch (stringNode.value) {\n    case \"number\":\n      return _type.Type.Number;\n\n    case \"string\":\n      return _type.Type.String;\n\n    case \"boolean\":\n      return _unionType.UnionType.Boolean;\n\n    case \"bigint\":\n      return _type.Type.BigInt;\n\n    case \"undefined\":\n      return _type.Type.Undefined;\n\n    case \"symbol\":\n      return _type.Type.Symbol;\n\n    case \"function\":\n      return _functionType.FunctionType.Function;\n\n    case \"object\":\n      return _unionType.UnionType.term(\"{ ... } | null\", {}, [_objectType.ObjectType.term(\"{ ... }\", {\n        isSoft: true\n      }, []), _type.Type.Null]);\n  }\n\n  throw new _errors2.default(`Typeof cannot return \"${stringNode.value}\" value`, stringNode.loc);\n}\n\nfunction refinementVariants([refinementedVariants, alternateVariants], variant, refinementType) {\n  if (refinementType.isPrincipalTypeFor(variant)) {\n    return [refinementedVariants.concat([variant]), alternateVariants];\n  }\n\n  if (variant.isPrincipalTypeFor(refinementType)) {\n    return [refinementedVariants.concat([refinementType]), alternateVariants.concat([variant])];\n  }\n\n  return [refinementedVariants, alternateVariants.concat([variant])];\n}\n\nfunction typeofIdentifier(node, currentScope, typeScope, stringNode, refinementNode) {\n  const variableName = node.name;\n  const refinementType = getRefinmentType(stringNode);\n  const variableInfo = currentScope.findVariable(node);\n  const [refinementedVariants, alternateVariants] = variableInfo.type instanceof _unionType.UnionType ? variableInfo.type.variants.reduce((res, variant) => refinementVariants(res, variant, refinementType), [[], []]) : refinementVariants([[], []], variableInfo.type, refinementType);\n\n  if (!(variableInfo.type instanceof _typeVar.TypeVar) && variableInfo.type !== _type.Type.Unknown && refinementedVariants.length === 0) {\n    throw new _errors2.default(`Type ${String(variableInfo.type.name)} can't be \"${stringNode.value}\" type`, refinementNode.loc);\n  }\n\n  const refinementedType = _unionType.UnionType.term(null, {}, refinementedVariants);\n\n  const alternateType = alternateVariants.length === 0 || refinementType === variableInfo.type ? _type.Type.Never : _unionType.UnionType.term(null, {}, alternateVariants);\n\n  if (refinementedType === _type.Type.Never || alternateType === _type.Type.Never) {\n    throw new _errors2.default(`Variable ${refinementedType === _type.Type.Never ? \"can't be\" : \"is always\"} \"${stringNode.value}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinementedType, alternateType];\n}\n\nfunction typeofProperty(node, currentScope, typeScope, stringNode, refinementNode) {\n  const targetObject = (0, _common.getMemberExressionTarget)(node);\n\n  if (targetObject.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const variableName = targetObject.name;\n  const propertiesChaining = (0, _inferenceUtils.getPropertyChaining)(node);\n  const refinementType = getRefinmentType(stringNode);\n  const targetVariableInfo = currentScope.findVariable(targetObject);\n\n  if (!variableName || !propertiesChaining) {\n    return;\n  }\n\n  const refinmentedAndAlternate = (0, _equalsRefinement.refinementProperty)(variableName, targetVariableInfo.type, refinementType, refinementNode, 0, propertiesChaining, typeScope);\n\n  if (!refinmentedAndAlternate) {\n    return;\n  }\n\n  if (!refinmentedAndAlternate[0] || !refinmentedAndAlternate[1]) {\n    throw new _errors2.default(`Property ${refinmentedAndAlternate[0] === undefined ? \"can't be\" : \"is always\"} \"${stringNode.value}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinmentedAndAlternate[0], refinmentedAndAlternate[1]];\n}\n\nfunction typeofRefinement(currentRefinementNode, currentScope, typeScope, moduleScope) {\n  const typeofOperator = moduleScope.findVariable({\n    name: \"typeof\"\n  });\n\n  if (!isEqualOperator(currentRefinementNode)) {\n    return;\n  }\n\n  const args = getTypeofAndLiteral(currentRefinementNode.left, currentRefinementNode.right, typeofOperator);\n\n  if (!args) {\n    return (0, _equalsRefinement.equalsRefinement)(currentRefinementNode, currentScope, typeScope, moduleScope);\n  }\n\n  const {\n    typeofNode,\n    stringNode\n  } = args;\n  let refinementedType, alternateType, name;\n\n  if (typeofNode.argument.type === _nodes2.default.IDENTIFIER) {\n    [name, refinementedType, alternateType] = typeofIdentifier(typeofNode.argument, currentScope, typeScope, stringNode, currentRefinementNode);\n  }\n\n  if (typeofNode.argument.type === _nodes2.default.MEMBER_EXPRESSION) {\n    const result = typeofProperty(typeofNode.argument, currentScope, typeScope, stringNode, currentRefinementNode);\n\n    if (!result) {\n      return;\n    }\n\n    [name, refinementedType, alternateType] = result;\n  }\n\n  if (refinementedType) {\n    if (currentRefinementNode.operator === \"!==\" || currentRefinementNode.operator === \"!=\") {\n      // $FlowIssue\n      return [name, alternateType, refinementedType];\n    } // $FlowIssue\n\n\n    return [name, refinementedType, alternateType];\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.variableRefinement = variableRefinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _equalsRefinement = require(\"./equals-refinement\");\n\nvar _inferenceUtils = require(\"../utils/inference-utils\");\n\nvar _common = require(\"../utils/common\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getFalsyVariants(type) {\n  return (0, _typeUtils.getFalsy)().filter(falsy => type.isPrincipalTypeFor(falsy));\n}\n\nfunction getTruthyVariants(type) {\n  if ((0, _typeUtils.isFalsy)(type)) {\n    return [];\n  }\n\n  if (type === _unionType.UnionType.Boolean) {\n    return [_type.Type.True];\n  }\n\n  if (type instanceof _unionType.UnionType) {\n    return type.variants.filter(variant => !(0, _typeUtils.isFalsy)(variant));\n  }\n\n  return [type];\n}\n\nfunction forVariable(node, currentScope, typeScope) {\n  const name = node.name;\n  const variableInfo = currentScope.findVariable(node);\n  const refinementedVariants = getTruthyVariants(variableInfo.type);\n  const alternateVariants = getFalsyVariants(variableInfo.type);\n\n  if (!(variableInfo.type instanceof _typeVar.TypeVar) && (refinementedVariants.length === 0 || alternateVariants.length === 0)) {\n    return;\n  }\n\n  return [name, _unionType.UnionType.term(null, {}, refinementedVariants), _unionType.UnionType.term(null, {}, alternateVariants)];\n}\n\nfunction forProperty(node, currentScope, typeScope) {\n  const targetObject = (0, _common.getMemberExressionTarget)(node);\n\n  if (targetObject.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const variableName = targetObject.name;\n  const propertiesChaining = (0, _inferenceUtils.getPropertyChaining)(node);\n  const targetVariableInfo = currentScope.findVariable(targetObject);\n\n  if (!variableName || !propertiesChaining) {\n    return;\n  }\n\n  const refinementType = _unionType.UnionType.term(null, {}, (0, _typeUtils.getFalsy)());\n\n  const refinmentedAndAlternate = (0, _equalsRefinement.refinementProperty)(variableName, targetVariableInfo.type, refinementType, node, 0, propertiesChaining, typeScope, true);\n\n  if (!refinmentedAndAlternate || !refinmentedAndAlternate[0] || !refinmentedAndAlternate[1]) {\n    return;\n  }\n\n  return [variableName, refinmentedAndAlternate[1], refinmentedAndAlternate[0]];\n}\n\nfunction variableRefinement(node, currentScope, typeScope, moduleScope) {\n  return node.type === _nodes2.default.IDENTIFIER ? forVariable(node, currentScope, typeScope) : forProperty(node, currentScope, typeScope);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addCallToTypeGraph = addCallToTypeGraph;\nexports.addPropertyToThis = addPropertyToThis;\nexports.addMethodToThis = addMethodToThis;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _meta = require(\"./meta/meta\");\n\nvar _type = require(\"./types/type\");\n\nvar _keysType = require(\"./types/keys-type\");\n\nvar _valuesType = require(\"./types/values-type\");\n\nvar _typeVar = require(\"./types/type-var\");\n\nvar _callMeta = require(\"./meta/call-meta\");\n\nvar _typeScope = require(\"./type-scope\");\n\nvar _unionType = require(\"./types/union-type\");\n\nvar _objectType = require(\"./types/object-type\");\n\nvar _genericType = require(\"./types/generic-type\");\n\nvar _bottomType = require(\"./types/bottom-type\");\n\nvar _functionType = require(\"./types/function-type\");\n\nvar _variableInfo = require(\"./variable-info\");\n\nvar _propertyType = require(\"./types/property-type\");\n\nvar _variableScope = require(\"./variable-scope\");\n\nvar _refinementedType = require(\"./types/refinemented-type\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _functionUtils = require(\"../utils/function-utils\");\n\nvar _common = require(\"../utils/common\");\n\nvar _immutableType = require(\"./types/immutable-type\");\n\nvar _inference = require(\"../inference\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _variableUtils = require(\"../utils/variable-utils\");\n\nvar _moduleScope = require(\"./module-scope\");\n\nvar _throwable = require(\"../utils/throwable\");\n\nvar _constants = require(\"./constants\");\n\nvar _functionType2 = require(\"../inference/function-type\");\n\nvar _scopeUtils = require(\"../utils/scope-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addCallToTypeGraph(node, moduleScope, currentScope, parentNode, pre, middle, post, meta = {}) {\n  let target = null;\n  let inferenced = undefined;\n  let isFinal = undefined;\n  let targetName = \"\";\n  let args = null;\n  let argsLocations = [];\n  let genericArguments = null;\n  const typeScope = (0, _scopeUtils.findNearestTypeScope)(currentScope, moduleScope);\n  const withPositions = moduleScope instanceof _moduleScope.PositionedModuleScope;\n\n  if (node == null) {\n    return {\n      result: _type.Type.Undefined,\n      inferenced: false\n    };\n  }\n\n  if (node.type === _nodes2.default.EXPRESSION_STATEMENT) {\n    node = node.expression;\n  }\n\n  if (node.type === _nodes2.default.SUPER) {\n    node = {\n      type: _nodes2.default.IDENTIFIER,\n      name: \"super\",\n      loc: node.loc\n    };\n  }\n\n  if (node.operator === \"delete\") {\n    node = {\n      loc: node.loc,\n      type: _nodes2.default.ASSIGNMENT_EXPRESSION,\n      operator: \"=\",\n      // $FlowIssue\n      left: node.argument,\n      right: {\n        type: _nodes2.default.IDENTIFIER,\n        name: \"undefined\",\n        loc: node.loc\n      }\n    };\n  }\n\n  switch (node.type) {\n    case _nodes2.default.TYPE_CAST:\n      throw new _errors2.default(\"Type cast does not exist in Hegel\", node.loc);\n\n    case _nodes2.default.TEMPLATE_LITERAL:\n      args = node.expressions.map(expression => addCallToTypeGraph(expression, moduleScope, currentScope, parentNode, pre, middle, post, meta).result);\n      argsLocations = node.expressions.map(node => node.loc);\n      targetName = \"tamplate literal\";\n      target = new _functionType.FunctionType(targetName, {}, args.map(() => _type.Type.String), _type.Type.String);\n      break;\n\n    case _nodes2.default.IF_STATEMENT:\n      target = currentScope.findVariable({\n        name: \"if\",\n        loc: node.loc\n      });\n      args = [addCallToTypeGraph(node.test, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      break;\n\n    case _nodes2.default.WHILE_STATEMENT:\n      target = currentScope.findVariable({\n        name: \"while\",\n        loc: node.loc\n      });\n      args = [addCallToTypeGraph(node.test, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      break;\n\n    case _nodes2.default.DO_WHILE_STATEMENT:\n      target = currentScope.findVariable({\n        name: \"do-while\",\n        loc: node.loc\n      });\n      args = [addCallToTypeGraph(node.test, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      break;\n\n    case _nodes2.default.FOR_STATEMENT:\n      target = currentScope.findVariable({\n        name: \"for\",\n        loc: node.loc\n      });\n      args = [_type.Type.Unknown, node.test ? addCallToTypeGraph(node.test, moduleScope, // $FlowIssue\n      moduleScope.scopes.get(_variableScope.VariableScope.getName(node.body)), parentNode, pre, middle, post, meta).result : _type.Type.Undefined, _type.Type.Unknown];\n      break;\n\n    case _nodes2.default.FUNCTION_EXPRESSION:\n    case _nodes2.default.ARROW_FUNCTION_EXPRESSION:\n    case _nodes2.default.IDENTIFIER:\n      const nodeName = node.type === _nodes2.default.IDENTIFIER ? node : {\n        name: (0, _common.getAnonymousKey)(node),\n        loc: node.loc\n      };\n      const varInfo = currentScope.findVariable(nodeName, parentNode, moduleScope, pre, middle, post);\n\n      if (withPositions && node.type === _nodes2.default.IDENTIFIER) {\n        // $FlowIssue\n        moduleScope.addPosition(node, varInfo);\n      }\n\n      return {\n        result: varInfo\n      };\n\n    case _nodes2.default.CLASS_PROPERTY:\n    case _nodes2.default.CLASS_PRIVATE_PROPERTY:\n    case _nodes2.default.OBJECT_PROPERTY:\n      const self = currentScope.findVariable({\n        name: _constants.THIS_TYPE\n      }); // $FlowIssue\n\n      let selfObject = node.static ? // $FlowIssue\n      self.parent.declaration.type : // $FlowIssue\n      self.type;\n      selfObject = selfObject instanceof _bottomType.$BottomType ? selfObject.subordinateMagicType.subordinateType : selfObject;\n\n      const _propertyName = (0, _variableUtils.getPropertyName)(node);\n\n      const propertyType = selfObject.properties.get(_propertyName);\n\n      if (propertyType === undefined) {\n        throw new Error(\"Never!!!\");\n      }\n\n      const value = node.value === null ? {\n        result: _type.Type.Undefined,\n        inferenced: false\n      } : addCallToTypeGraph(node.value, moduleScope, currentScope, parentNode, pre, middle, post, meta);\n      inferenced = value.inferenced;\n      args = [node.typeAnnotation != null ? propertyType : value.result, value.result];\n      targetName = \"=\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      });\n      break;\n\n    case _nodes2.default.VARIABLE_DECLARATOR:\n      const variableType = currentScope.findVariable(node.id);\n\n      if (withPositions) {\n        // $FlowIssue\n        moduleScope.addPosition(node.id, variableType);\n      }\n\n      const init = node.init === null ? {\n        result: _type.Type.Undefined,\n        inferenced: false\n      } : addCallToTypeGraph(node.init, moduleScope, currentScope, parentNode, pre, middle, post, { ...meta,\n        isImmutable: variableType.type instanceof _immutableType.$AppliedImmutable\n      });\n      inferenced = init.inferenced;\n      targetName = \"init\";\n      args = [variableType, init.result];\n      target = currentScope.findVariable({\n        name: \"=\",\n        loc: node.loc\n      }).type;\n      target = target instanceof _genericType.GenericType && node.id.typeAnnotation != undefined ? target.applyGeneric([variableType.type]) : target;\n      break;\n\n    case _nodes2.default.THROW_STATEMENT:\n      const error = addCallToTypeGraph(node.argument, moduleScope, currentScope, parentNode, pre, middle, post, meta);\n      args = [(0, _variableUtils.getVariableType)(undefined, error.result instanceof _variableInfo.VariableInfo ? error.result.type : error.result, typeScope, error.inferenced)];\n      targetName = \"throw\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      }, parentNode, moduleScope, pre, middle, post);\n      const nearestFn = (0, _scopeUtils.findNearestScopeByType)(_variableScope.VariableScope.FUNCTION_TYPE, currentScope);\n      isFinal = nearestFn instanceof _moduleScope.ModuleScope || currentScope === nearestFn || currentScope.getParentsUntil(nearestFn).every(parent => parent.creator === \"block\" || parent.creator === \"catch\" || parent.creator === \"default-case\");\n      const nearestThrowableScope = (0, _throwable.findThrowableBlock)(currentScope);\n      const throwableDeclaration = nearestThrowableScope && nearestThrowableScope.declaration;\n\n      if (nearestThrowableScope != null) {\n        (0, _throwable.addToThrowable)(args[0], nearestThrowableScope);\n      }\n\n      if (isFinal && currentScope !== nearestFn) {\n        nearestFn.calls.push(new _callMeta.CallMeta(undefined, [], node.loc, \"throw\", typeScope, false, true));\n      }\n\n      if (nearestThrowableScope == null || nearestThrowableScope.type !== _variableScope.VariableScope.FUNCTION_TYPE || throwableDeclaration == undefined) {\n        break;\n      } // $FlowIssue\n\n\n      const currentTargetType = target.type;\n      const declarationType = throwableDeclaration.type instanceof _genericType.GenericType ? throwableDeclaration.type.subordinateType : throwableDeclaration.type;\n\n      if (declarationType instanceof _objectType.ObjectType) {\n        throw new Error(\"Never!!!\");\n      }\n\n      if (declarationType.throwable !== undefined) {\n        target = currentTargetType.applyGeneric([declarationType.throwable]);\n      }\n\n      break;\n\n    case _nodes2.default.AWAIT_EXPRESSION:\n      args = [addCallToTypeGraph(node.argument, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      targetName = \"await\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      }, parentNode, moduleScope, pre, middle, post);\n      break;\n\n    case _nodes2.default.LOGICAL_EXPRESSION:\n      args = [addCallToTypeGraph(node.left.body, moduleScope, // $FlowIssue\n      moduleScope.scopes.get(_variableScope.VariableScope.getName(node.left)), node.left, pre, middle, post, meta).result, addCallToTypeGraph(node.right.body, moduleScope, // $FlowIssue\n      moduleScope.scopes.get(_variableScope.VariableScope.getName(node.right)), node.right, pre, middle, post, meta).result];\n      let leftArg = args[0];\n      leftArg = leftArg instanceof _variableInfo.VariableInfo ? leftArg.type : leftArg;\n      leftArg = node.operator === \"&&\" ? (0, _typeUtils.pickFalsy)(leftArg) : (0, _typeUtils.pickTruthy)(leftArg);\n      args[0] = leftArg || args[0];\n\n    case _nodes2.default.BINARY_EXPRESSION:\n      args = args || [addCallToTypeGraph(node.left, moduleScope, currentScope, parentNode, pre, middle, post, meta).result, addCallToTypeGraph(node.right, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      targetName = node.operator === \"+\" ? \"b+\" : node.operator;\n      targetName = node.operator === \"-\" ? \"b-\" : targetName;\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      });\n      break;\n\n    case _nodes2.default.ASSIGNMENT_EXPRESSION:\n    case _nodes2.default.ASSIGNMENT_PATTERN:\n      const right = addCallToTypeGraph(node.right, moduleScope, currentScope, parentNode, pre, middle, post, meta);\n      const left = addCallToTypeGraph(node.left, moduleScope, currentScope, parentNode, pre, middle, post, { ...meta,\n        isForAssign: true\n      });\n      args = [left.result, right.result];\n\n      if (left.result instanceof _variableInfo.VariableInfo && left.result.isConstant) {\n        throw new _errors2.default(\"Cannot assign to variable because it is a constant.\", node.loc);\n      }\n\n      targetName = node.operator || \"=\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      }).type;\n      target = target instanceof _genericType.GenericType && (node.type !== _nodes2.default.ASSIGNMENT_PATTERN || node.left.typeAnnotation != undefined) ? // $FlowIssue\n      target.applyGeneric([left.result.type || left.result]) : target;\n      inferenced = right.inferenced;\n      break;\n\n    case _nodes2.default.RETURN_STATEMENT:\n      targetName = \"return\";\n      const fn = (0, _scopeUtils.findNearestScopeByType)(_variableScope.VariableScope.FUNCTION_TYPE, currentScope);\n\n      if (fn instanceof _moduleScope.ModuleScope) {\n        throw new _errors2.default(\"Call return outside a function\", node.loc);\n      }\n\n      const arg = addCallToTypeGraph(node.argument, moduleScope, currentScope, parentNode, pre, middle, post, meta);\n      inferenced = arg.inferenced;\n      let argType = arg.result instanceof _variableInfo.VariableInfo ? arg.result.type : arg.result;\n      argType = argType instanceof _refinementedType.$Refinemented ? argType.from : argType;\n      let fType = fn.declaration.type;\n      fType = fType instanceof _genericType.GenericType ? fType.subordinateType : fType;\n      args = [fType.isAsync && !argType.isPromise() ? argType.promisify() : argType];\n      const declaration = fn.declaration.type instanceof _genericType.GenericType ? fn.declaration.type.subordinateType : fn.declaration.type;\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      }, parentNode, moduleScope, pre, middle, post); // $FlowIssue\n\n      target = target.type.subordinateType.changeAll( // $FlowIssue\n      target.type.genericArguments, [declaration.returnType]);\n      isFinal = currentScope === fn || currentScope.getParentsUntil(fn).every(parent => parent.creator === \"block\" || parent.creator === \"default-case\");\n      currentScope = fn;\n      break;\n\n    case _nodes2.default.UNARY_EXPRESSION:\n    case _nodes2.default.UPDATE_EXPRESSION:\n      targetName = node.operator;\n      args = [addCallToTypeGraph(node.argument, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      });\n      break;\n\n    case _nodes2.default.PURE_KEY:\n      args = [addCallToTypeGraph(node.of, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      targetName = \"Object.keys\";\n      args = args.map(a => a instanceof _variableInfo.VariableInfo ? a.type : a);\n      target = new _keysType.$Keys().applyGeneric(args, node.loc); // $FlowIssue\n\n      target = new _functionType.FunctionType(targetName, {}, args, target);\n      break;\n\n    case _nodes2.default.PURE_VALUE:\n    case _nodes2.default.VALUE:\n      target = addCallToTypeGraph(node.of, moduleScope, currentScope, parentNode, pre, middle, post, meta).result;\n      args = [target];\n      targetName = \"Object.values\";\n      args = args.map(a => a instanceof _variableInfo.VariableInfo ? a.type : a);\n      const isArray = args[0] instanceof _collectionType.CollectionType;\n      target = new _valuesType.$Values().applyGeneric(args, node.loc);\n      target = isArray && node.type === _nodes2.default.VALUE ? _unionType.UnionType.term(null, {}, [target, _type.Type.Undefined]) : target; // $FlowIssue\n\n      target = new _functionType.FunctionType(targetName, {}, args, target);\n      break;\n\n    case _nodes2.default.MEMBER_EXPRESSION:\n      const propertyName = node.property.type === _nodes2.default.PRIVATE_NAME ? `#${node.property.id.name}` : node.property.name;\n      const isNotComputed = (node.property.type === _nodes2.default.IDENTIFIER || node.property.type === _nodes2.default.PRIVATE_NAME) && !node.computed;\n      args = [(0, _typeUtils.getWrapperType)(addCallToTypeGraph(node.object, moduleScope, currentScope, parentNode, pre, middle, post, meta).result, moduleScope), isNotComputed ? _type.Type.term(`'${propertyName}'`, {\n        isSubtypeOf: _type.Type.String\n      }) : addCallToTypeGraph(node.property, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      targetName = \".\";\n      genericArguments = args.map(t => t instanceof _variableInfo.VariableInfo ? t.type : t);\n      const lts = new _typeScope.TypeScope(typeScope);\n      const argsTypes = [_typeVar.TypeVar.new(\"A\", {\n        parent: lts\n      }, undefined, undefined, true), _typeVar.TypeVar.new(\"B\", {\n        parent: lts\n      }, undefined, undefined, true)];\n      const property = new _bottomType.$BottomType({\n        isForAssign: meta.isForAssign\n      }, new _propertyType.$PropertyType(\"\", {}, meta.isForInit), genericArguments);\n      target = _genericType.GenericType.term(`<A, B>(A, B) => ${String(property.name)}`, {}, argsTypes, lts, new _functionType.FunctionType(\"\", {}, argsTypes, property));\n      break;\n\n    case _nodes2.default.CONDITIONAL_EXPRESSION:\n      args = [addCallToTypeGraph(node.test, moduleScope, currentScope, parentNode, pre, middle, post, meta).result, addCallToTypeGraph(node.consequent.body, moduleScope, // $FlowIssue\n      moduleScope.scopes.get(_variableScope.VariableScope.getName(node.consequent)), node.consequent, pre, middle, post, meta).result, addCallToTypeGraph(node.alternate.body, moduleScope, // $FlowIssue\n      moduleScope.scopes.get(_variableScope.VariableScope.getName(node.alternate)), node.alternate, pre, middle, post, meta).result];\n      targetName = \"?:\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      });\n      break;\n\n    case _nodes2.default.NEW_EXPRESSION:\n      const argument = addCallToTypeGraph(node.callee, moduleScope, currentScope, parentNode, pre, middle, post, meta).result;\n      const argumentType = argument instanceof _variableInfo.VariableInfo ? argument.type : argument;\n      const potentialArgument = addCallToTypeGraph({ ...node,\n        type: _nodes2.default.CALL_EXPRESSION,\n        isConstructor: true\n      }, moduleScope, currentScope, parentNode, pre, middle, post, meta).result;\n\n      const defaultObject = _objectType.ObjectType.term(\"{  }\", {}, []);\n\n      args = [_objectType.ObjectType.Object.isPrincipalTypeFor(potentialArgument) ? potentialArgument : defaultObject];\n      targetName = \"new\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      });\n      break;\n\n    case _nodes2.default.TAGGED_TEMPLATE_EXPRESSION:\n      node = {\n        loc: node.loc,\n        type: _nodes2.default.CALL_EXPRESSION,\n        callee: node.tag,\n        arguments: [{\n          type: _nodes2.default.ARRAY_EXPRESSION,\n          loc: node.quasi.loc,\n          elements: node.quasi.quasis.map(a => ({ ...a,\n            type: _nodes2.default.STRING_LITERAL,\n            value: a.value.raw\n          }))\n        }, ...node.quasi.expressions]\n      };\n\n    case _nodes2.default.CALL_EXPRESSION:\n      if (node.callee.type === _nodes2.default.IDENTIFIER || node.callee.type === _nodes2.default.THIS_EXPRESSION || node.callee.type === _nodes2.default.SUPER) {\n        targetName = node.callee.name;\n\n        if (node.callee.type === _nodes2.default.SUPER) {\n          targetName = \"super\";\n        }\n\n        if (node.callee.type === _nodes2.default.THIS_EXPRESSION) {\n          targetName = _constants.THIS_TYPE;\n        }\n\n        target = currentScope.findVariable({\n          name: targetName,\n          loc: node.callee.loc\n        }, parentNode, moduleScope, pre, middle, post);\n\n        if (withPositions) {\n          // $FlowIssue\n          moduleScope.addPosition(node.callee, target);\n        }\n      } else {\n        target = addCallToTypeGraph(node.callee, moduleScope, currentScope, parentNode, pre, middle, post, meta).result;\n      }\n\n      let targetType = target instanceof _variableInfo.VariableInfo ? target.type : target;\n      targetType = targetType instanceof _immutableType.$AppliedImmutable ? targetType.readonly : targetType;\n      targetType = targetType instanceof _bottomType.$BottomType ? targetType.unpack(node.loc) : targetType;\n\n      if (!(targetType instanceof _functionType.FunctionType) && !(targetType instanceof _genericType.GenericType && targetType.subordinateType instanceof _functionType.FunctionType)) {\n        target = targetType.getPropertyType(node.isConstructor ? _constants.CONSTRUCTABLE : _constants.CALLABLE) || target;\n        target = typeof targetType === \"string\" ? _variableScope.VariableScope.addAndTraverseNodeWithType( // $FlowIssue\n        undefined, target, parentNode, moduleScope, pre, middle, post) : target;\n        target = target instanceof _variableInfo.VariableInfo ? target : // $FlowIssue\n        new _variableInfo.VariableInfo(target, currentScope);\n        targetType =\n        /*::target.type !== undefined ?*/\n        target.type\n        /*:: : targetType*/\n        ;\n      }\n\n      genericArguments = node.typeArguments && node.typeArguments.params.map(arg => (0, _typeUtils.getTypeFromTypeAnnotation)({\n        typeAnnotation: arg\n      }, typeScope, currentScope, false, null, parentNode, moduleScope, pre, middle, post));\n      const localTypeScope = targetType instanceof _genericType.GenericType ? targetType.localTypeScope : typeScope;\n\n      if (targetType instanceof _genericType.GenericType && genericArguments != null) {\n        targetType = (0, _functionType2.getRawFunctionType)( // $FlowIssue\n        targetType, [], genericArguments, localTypeScope, node.loc);\n      }\n\n      let fnType = targetType instanceof _genericType.GenericType ? targetType.subordinateType : targetType;\n\n      if (fnType != undefined && !(fnType instanceof _functionType.FunctionType) && !(fnType instanceof _typeVar.TypeVar && !fnType.isUserDefined)) {\n        throw new _errors2.default(fnType instanceof _unionType.UnionType && fnType.variants.every(_functionUtils.isCallableType) ? `Signatures of each variant of type \"${String(fnType.name)}\" are not compatible with each other` : `The type \"${String(fnType.name)}\" is not callable.`, node.loc);\n      }\n\n      args = node.arguments.map((n, i) => {\n        argsLocations.push(n.loc); // $FlowIssue\n\n        const defaultArg = (fnType.argumentsTypes || [])[i];\n        return n.type === _nodes2.default.FUNCTION_EXPRESSION || n.type === _nodes2.default.ARROW_FUNCTION_EXPRESSION ? defaultArg : addCallToTypeGraph(n, moduleScope, currentScope, parentNode, pre, middle, post, { ...meta,\n          isImmutable: defaultArg instanceof _immutableType.$AppliedImmutable\n        }).result;\n      });\n      targetType.asNotUserDefined();\n      args = node.arguments.map((n, i) => {\n        if (n.type !== _nodes2.default.FUNCTION_EXPRESSION && n.type !== _nodes2.default.ARROW_FUNCTION_EXPRESSION) {\n          // $FlowIssue\n          return args[i];\n        }\n\n        let expectedType = fnType instanceof _functionType.FunctionType ? fnType.argumentsTypes[i] : undefined; // We need it for right type inference of the argument function\n\n        if (targetType instanceof _genericType.GenericType) {\n          const existedGenericArguments = expectedType instanceof _genericType.GenericType ? expectedType.genericArguments : [];\n          const subordinateType = expectedType instanceof _genericType.GenericType ? expectedType.subordinateType : expectedType;\n          expectedType = new _genericType.GenericType(\"\", {}, [...existedGenericArguments, ...targetType.genericArguments], new _typeScope.TypeScope(), subordinateType);\n        }\n\n        const result = _variableScope.VariableScope.addAndTraverseNodeWithType( // $FlowIssue\n        expectedType, n, parentNode, moduleScope, pre, middle, post);\n\n        return result;\n      });\n      fnType = (0, _functionType2.getRawFunctionType)( // $FlowIssue\n      targetType, args, genericArguments, localTypeScope, node.loc);\n      targetType.asUserDefined();\n      const throwableType = targetType instanceof _genericType.GenericType ? targetType.subordinateType : targetType;\n\n      if (throwableType.throwable !== undefined && !(currentScope instanceof _moduleScope.ModuleScope)) {\n        const nearestThrowableScope = (0, _throwable.findThrowableBlock)(currentScope);\n\n        if (nearestThrowableScope != undefined) {\n          (0, _throwable.addToThrowable)(throwableType.throwable, nearestThrowableScope);\n\n          if (nearestThrowableScope.type === _variableScope.VariableScope.FUNCTION_TYPE) {\n            const declaration = nearestThrowableScope.declaration;\n\n            if (declaration === undefined) {\n              throw new Error(\"Never!!!\");\n            }\n\n            const declarationType = declaration.type instanceof _genericType.GenericType ? declaration.type.subordinateType : declaration.type;\n\n            if (declarationType instanceof _objectType.ObjectType) {\n              throw new Error(\"Never!!!\");\n            }\n\n            const declaratedThrowable = declarationType.throwable;\n\n            if (declaratedThrowable !== undefined && !declaratedThrowable.isPrincipalTypeFor(throwableType.throwable)) {\n              throw new _errors2.default(`Current function throws \"${String(throwableType.throwable.name)}\" type which is incompatible with declareted throw type \"${String(declaratedThrowable.name)}\"`, node.loc);\n            }\n          }\n        }\n      }\n\n      if (genericArguments != null || target.type instanceof _bottomType.$BottomType) {\n        target = fnType;\n      }\n\n      inferenced = targetType instanceof _genericType.GenericType && targetType.subordinateType.returnType instanceof _typeVar.TypeVar;\n      break;\n\n    case _nodes2.default.THIS_EXPRESSION:\n      const selfVar = currentScope.findVariable({\n        name: _constants.THIS_TYPE,\n        loc: node.loc\n      });\n      const nearestFunctionScope = (0, _scopeUtils.findNearestScopeByType)(_variableScope.VariableScope.FUNCTION_TYPE, currentScope);\n      nearestFunctionScope.calls.push(new _callMeta.CallMeta(undefined, [], node.loc, \"this\", typeScope));\n      return {\n        result: selfVar.type instanceof _bottomType.$BottomType ? selfVar.type.subordinateMagicType.subordinateType : selfVar.type,\n        inferenced: false\n      };\n\n    case _nodes2.default.SEQUENCE_EXPRESSION:\n      return addCallToTypeGraph(node.expressions[node.expressions.length - 1], moduleScope, currentScope, parentNode, pre, middle, post, meta);\n\n    default:\n      return {\n        result: (0, _inference.inferenceTypeForNode)(node, typeScope, currentScope, moduleScope, parentNode, pre, middle, post, meta.isTypeDefinitions, meta.isImmutable),\n        isLiteral: true,\n        inferenced: true\n      };\n  }\n\n  if (target === null || args === null) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const targetType = target instanceof _variableInfo.VariableInfo ? target.type : target;\n  const options = {\n    pre,\n    args,\n    meta,\n    node,\n    post,\n    middle,\n    target,\n    moduleScope,\n    typeScope,\n    targetType,\n    parentNode,\n    dropUnknown: targetName === \"=\" || targetName === \"init\",\n    genericArguments: genericArguments && genericArguments.map(a => a instanceof _type.Type ? a : a.type)\n  };\n\n  const getResult = targetType => {\n    const {\n      result,\n      inferenced: localInferenced\n    } = invoke({ ...options,\n      targetType\n    });\n    inferenced = inferenced || localInferenced;\n    return result;\n  };\n\n  const invocationType = targetType instanceof _unionType.UnionType ? _unionType.UnionType.term(null, {}, targetType.variants.map(getResult)) : getResult(targetType);\n  const callMeta = new _callMeta.CallMeta(target, args, node.loc, targetName, typeScope, inferenced, isFinal, argsLocations);\n\n  while (currentScope.skipCalls !== false && currentScope !== moduleScope) {\n    // $FlowIssue\n    currentScope = currentScope.parent;\n  }\n\n  currentScope.calls.push(callMeta);\n  return {\n    result: invocationType,\n    inferenced\n  };\n}\n\nfunction invoke({\n  parentNode,\n  typeScope,\n  moduleScope,\n  pre,\n  middle,\n  post,\n  target,\n  targetType,\n  genericArguments,\n  args,\n  node,\n  meta,\n  dropUnknown\n}) {\n  if (targetType instanceof _immutableType.$AppliedImmutable) {\n    targetType = targetType.readonly;\n  }\n\n  if (!(targetType instanceof _bottomType.$BottomType) && !(targetType instanceof _typeVar.TypeVar && !targetType.isUserDefined) && !(targetType instanceof _functionType.FunctionType) && !(targetType instanceof _genericType.GenericType && targetType.subordinateType instanceof _functionType.FunctionType)) {\n    throw new _errors2.default(\"The target is not callable type.\", node.loc);\n  }\n\n  try {\n    const invocationType = (0, _functionType2.getInvocationType)(targetType, args, genericArguments, typeScope, node.loc, meta.isForAssign, dropUnknown);\n\n    if (!(invocationType instanceof _type.Type)) {\n      return {\n        result: addPropertyToThis(invocationType, parentNode, typeScope, moduleScope, pre, middle, post),\n        inferenced: false\n      };\n    }\n\n    if (targetType instanceof _typeVar.TypeVar && !targetType.isUserDefined && target instanceof _variableInfo.VariableInfo) {\n      let func = (0, _scopeUtils.findNearestScopeByType)(_variableScope.VariableScope.FUNCTION_TYPE, // $FlowIssue\n      target.parent);\n\n      if (func.declaration && func.declaration.type instanceof _genericType.GenericType && invocationType instanceof _typeVar.TypeVar) {\n        const genericArguments = func.declaration.type.genericArguments;\n        genericArguments.push(invocationType);\n\n        const fn = _type.Type.getTypeRoot(targetType);\n\n        fn.argumentsTypes.forEach(arg => {\n          if (arg instanceof _typeVar.TypeVar && !arg.isUserDefined && !genericArguments.includes(arg)) {\n            genericArguments.push(arg);\n          }\n        });\n      }\n    }\n\n    return {\n      result: invocationType,\n      inferenced: isInferencedTypeVar(targetType) && isInferencedTypeVar(invocationType, true)\n    };\n  } catch (e) {\n    if (e.loc === undefined) {\n      e.loc = node.loc;\n    }\n\n    throw e;\n  }\n}\n\nfunction isInferencedTypeVar(t, withoutRoot = false) {\n  return t instanceof _typeVar.TypeVar && !t.isUserDefined && (!withoutRoot || t.root === undefined);\n}\n\nfunction addPropertyToThis(currentNode, parentNode, typeScope, moduleScope, precompute, middlecompute, postcompute) {\n  let propertyName;\n  const isPrivate = currentNode.type === _nodes2.default.CLASS_PRIVATE_PROPERTY;\n\n  if (isPrivate) {\n    propertyName = `#${currentNode.key.id.name}`;\n  } else {\n    propertyName = currentNode.key.name || `${currentNode.key.value}`;\n  } // $FlowIssue\n\n\n  const currentScope = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, moduleScope);\n  const currentClassScope = (0, _scopeUtils.findNearestScopeByType)([_variableScope.VariableScope.CLASS_TYPE, _variableScope.VariableScope.OBJECT_TYPE], currentScope); // $FlowIssue\n\n  const self = currentNode.static ? currentClassScope.declaration : currentClassScope.findVariable({\n    name: _constants.THIS_TYPE\n  });\n  const selfType = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.subordinateType : self.type;\n\n  if (currentClassScope.isProcessed) {\n    // $FlowIssue\n    return selfType.properties.get(propertyName).type;\n  }\n\n  const currentTypeScope = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.localTypeScope : typeScope;\n  let type = _type.Type.Undefined;\n\n  if (currentNode.typeAnnotation != null) {\n    type = (0, _typeUtils.getTypeFromTypeAnnotation)(currentNode.typeAnnotation, currentTypeScope, currentClassScope, false, null, parentNode, moduleScope, precompute, middlecompute, postcompute);\n  }\n\n  const property = new _variableInfo.VariableInfo(type, currentClassScope, new _meta.Meta(currentNode.loc), false, false, isPrivate);\n\n  if (!(selfType instanceof _objectType.ObjectType)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  if (currentNode.hasInitializer || currentNode.type === _nodes2.default.OBJECT_PROPERTY) {\n    property.hasInitializer = true;\n  }\n\n  selfType.properties.set(propertyName, property);\n\n  if (moduleScope instanceof _moduleScope.PositionedModuleScope) {\n    moduleScope.addPosition(currentNode.key, property);\n  }\n\n  if (currentNode.type === _nodes2.default.OBJECT_METHOD || currentNode.type === _nodes2.default.CLASS_METHOD) {\n    const fn = _variableScope.VariableScope.addAndTraverseNodeWithType(null, currentNode, parentNode, moduleScope, precompute, middlecompute, postcompute);\n\n    property.hasInitializer = true;\n\n    if (fn === undefined) {\n      throw new Error(\"Never!!!\");\n    }\n\n    property.type = fn.type;\n  } else if (currentNode.value != null) {\n    const inferenced = addCallToTypeGraph(currentNode, moduleScope, currentClassScope, parentNode, precompute, middlecompute, postcompute).result;\n    property.hasInitializer = true;\n\n    if (currentNode.typeAnnotation === undefined) {\n      property.type = inferenced instanceof _variableInfo.VariableInfo ? inferenced.type : inferenced;\n    }\n  }\n\n  if (moduleScope instanceof _moduleScope.PositionedModuleScope) {\n    moduleScope.addPosition(currentNode, property);\n  }\n\n  return property.type;\n}\n\nfunction addMethodToThis(currentNode, parentNode, moduleScope, pre, middle, post, isTypeDefinitions) {\n  const currentScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(parentNode));\n\n  if (currentScope === undefined) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const classScope = (0, _scopeUtils.findNearestScopeByType)([_variableScope.VariableScope.CLASS_TYPE, _variableScope.VariableScope.OBJECT_TYPE], currentScope);\n\n  if (classScope.isProcessed) {\n    return;\n  }\n\n  let propertyName;\n  const isPrivate = currentNode.type === _nodes2.default.CLASS_PRIVATE_METHOD;\n\n  if (isPrivate) {\n    propertyName = `#${currentNode.key.id.name}`;\n  } else {\n    propertyName = currentNode.key.name || `${currentNode.key.value}`;\n  }\n\n  if (currentNode.kind === \"constructor\") {\n    propertyName = _constants.CONSTRUCTABLE;\n  }\n\n  const self = classScope.findVariable({\n    name: _constants.THIS_TYPE\n  }); // $FlowIssue\n\n  const classVar = currentNode.static || propertyName === _constants.CONSTRUCTABLE ? classScope.declaration : self;\n  const classType = classVar.type instanceof _bottomType.$BottomType ? classVar.type.subordinateMagicType.subordinateType : classVar.type;\n  const methodScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n  if (methodScope !== undefined && !isTypeDefinitions) {\n    return false;\n  } // $FlowIssue\n\n\n  const existedProperty = classType.properties.get(propertyName);\n  const expectedType = existedProperty instanceof _variableInfo.VariableInfo ? existedProperty.type : undefined;\n  currentNode.expected = currentNode.expected || expectedType;\n  let fn = (0, _functionUtils.addFunctionToTypeGraph)(currentNode, parentNode, moduleScope, pre, middle, post, isTypeDefinitions);\n\n  if (isPrivate) {\n    fn = new _variableInfo.VariableInfo(fn.type, fn.parent, fn.meta, fn.isConstant, fn.isInferenced, true);\n  }\n\n  fn.hasInitializer = true;\n\n  if (!isTypeDefinitions && classScope.type === _variableScope.VariableScope.CLASS_TYPE) {\n    const fnScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n    if (fnScope === undefined) {\n      throw new Error(\"Never!!!\");\n    }\n\n    fnScope.declaration = fn; // $FlowIssue\n\n    fnScope.body.set(_constants.THIS_TYPE, currentNode.static ? classScope.declaration : self);\n\n    if (classScope.declaration.type.isSubtypeOf !== _objectType.ObjectType.Object && currentNode.static) {\n      // $FlowIssue\n      fnScope.body.set(\"super\", new _variableInfo.VariableInfo(classScope.declaration.type.isSubtypeOf, fnScope));\n    }\n  } // $FlowIssue\n\n\n  classType.properties.set(propertyName, fn);\n\n  if (propertyName === _constants.CONSTRUCTABLE) {\n    const type = // For Function Variable Scope type can't be an ObjectType\n    fn.type instanceof _genericType.GenericType ? fn.type.subordinateType : fn.type;\n    const returnType = (type.returnType instanceof _objectType.ObjectType || type.returnType instanceof _collectionType.CollectionType) && _objectType.ObjectType.Object.isPrincipalTypeFor(type.returnType) ? type.returnType : self.type;\n    const fnName = `${String(self.type.name)} constructor`;\n\n    let constructorType = _functionType.FunctionType.term(fnName, {}, type.argumentsTypes, returnType);\n\n    if (self.type instanceof _bottomType.$BottomType) {\n      const fnType = fn.type;\n      const additionalArray = fnType instanceof _genericType.GenericType ? fnType.genericArguments.filter(a => a !== fnType.subordinateType.returnType) : [];\n      const genericArguments = Array.from(new Set([...self.type.genericArguments, ...additionalArray]));\n      const localTypeScope = fn.type instanceof _genericType.GenericType ? fn.type.localTypeScope : self.type.subordinateMagicType.localTypeScope;\n      constructorType = _genericType.GenericType.new(fnName, {}, genericArguments, localTypeScope, constructorType);\n    } else if (fn.type instanceof _genericType.GenericType) {\n      constructorType = _genericType.GenericType.new(fnName, {}, fn.type.genericArguments, fn.type.localTypeScope, constructorType);\n    }\n\n    fn.type = constructorType;\n  }\n\n  if (moduleScope instanceof _moduleScope.PositionedModuleScope) {\n    // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n    moduleScope.addPosition(currentNode, fn);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// flow\nconst THIS_TYPE = exports.THIS_TYPE = \"[[This]]\";\nconst CALLABLE = exports.CALLABLE = \"[[Callable]]\";\nconst CONSTRUCTABLE = exports.CONSTRUCTABLE = \"[[Constructable]]\";\nconst INDEXABLE = exports.INDEXABLE = \"[[Indexable]]\";","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallMeta = undefined;\n\nvar _meta = require(\"./meta\");\n\nvar _type = require(\"../types/type\");\n\nvar _genericType = require(\"../types/generic-type\");\n\nvar _functionType = require(\"../types/function-type\");\n\nvar _variableInfo = require(\"../variable-info\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass CallMeta extends _meta.Meta {\n  constructor(target, args, loc, targetName, typeScope, inferenced = false, isFinal = false, argumentsLocations = []) {\n    super(loc);\n\n    _defineProperty(this, \"target\", void 0);\n\n    _defineProperty(this, \"targetName\", void 0);\n\n    _defineProperty(this, \"arguments\", void 0);\n\n    _defineProperty(this, \"argumentsLocations\", void 0);\n\n    _defineProperty(this, \"inferenced\", void 0);\n\n    _defineProperty(this, \"isFinal\", void 0);\n\n    _defineProperty(this, \"typeScope\", void 0);\n\n    this.target = target;\n    this.targetName = targetName;\n    this.arguments = args;\n    this.typeScope = typeScope;\n    this.inferenced = inferenced;\n    this.isFinal = isFinal;\n    this.argumentsLocations = argumentsLocations;\n  }\n\n}\n\nexports.CallMeta = CallMeta;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst ZeroLocation = {\n  start: {\n    column: -1,\n    line: -1\n  },\n  end: {\n    column: -1,\n    line: -1\n  }\n};\n\nclass Meta {\n  constructor(loc = ZeroLocation) {\n    _defineProperty(this, \"loc\", void 0);\n\n    _defineProperty(this, \"changed\", void 0);\n\n    this.loc = loc;\n    this.changed = false;\n  }\n\n}\n\nexports.Meta = Meta;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PositionedModuleScope = exports.ModuleScope = undefined;\n\nvar _scope = require(\"./scope\");\n\nvar _typeScope = require(\"./type-scope\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// $FlowIssue\nclass ModuleScope extends _scope.Scope {\n  constructor(path, body = new Map(), parent = null, typeScope = new _typeScope.TypeScope()) {\n    // $FlowIssue\n    super(parent);\n\n    _defineProperty(this, \"typeScope\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"calls\", []);\n\n    _defineProperty(this, \"exports\", void 0);\n\n    _defineProperty(this, \"exportsTypes\", void 0);\n\n    _defineProperty(this, \"scopes\", void 0);\n\n    _defineProperty(this, \"path\", void 0);\n\n    this.parent = parent;\n    this.path = path;\n    this.body = body;\n    this.typeScope = typeScope;\n    this.exports = new Map();\n    this.exportsTypes = new Map();\n    this.scopes = new Map();\n  }\n\n}\n\nexports.ModuleScope = ModuleScope;\n\nclass PositionedModuleScope extends ModuleScope {\n  constructor(path, body = new Map(), parent, typeScope = new _typeScope.TypeScope()) {\n    super(path, body, parent, typeScope);\n\n    _defineProperty(this, \"positions\", void 0);\n\n    this.positions = new Map();\n  }\n\n  addPosition(node, variableInfoOrType) {\n    const line = this.positions.get(node.loc.start.line) || new Map();\n    line.set(`${node.loc.start.column},${node.loc.end.column}`, variableInfoOrType);\n    this.positions.set(node.loc.start.line, line);\n  }\n\n  getVarAtPosition(loc, typeGraph) {\n    const line = this.positions.get(loc.line);\n\n    if (line === undefined) {\n      return;\n    }\n\n    let varInfo = undefined;\n\n    for (const [startEnd, vi] of line.entries()) {\n      let [start, end] = startEnd.split(\",\");\n      start = Number(start);\n      end = Number(end);\n\n      if (loc.column >= start && loc.column <= end) {\n        varInfo = vi;\n        break;\n      }\n    }\n\n    return varInfo;\n  }\n\n}\n\nexports.PositionedModuleScope = PositionedModuleScope;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Scope = undefined;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _traverse = require(\"../utils/traverse\");\n\nvar _traverse2 = _interopRequireDefault(_traverse);\n\nvar _variableInfo = require(\"./variable-info\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass Scope {\n  static canTraverseFunction(rest) {\n    return rest.length === 5;\n  }\n\n  static getName(node) {\n    return `[[Scope${node.loc.start.line}-${node.loc.start.column}]]`;\n  }\n\n  static addAndTraverseNodeWithType(definedType, currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute) {\n    currentNode.expected = definedType != undefined && \"variants\" in definedType ? // $FlowIssue\n    definedType.variants.find(a => \"argumentsTypes\" in a) : definedType;\n    const scopeName = this.getName(currentNode);\n    const errors = [];\n    (0, _traverse2.default)(currentNode, precompute, middlecompute, postcompute, _nodes2.default.isFunction(currentNode) ? parentNode : parentNode.parentNode || parentNode, {\n      errors\n    });\n\n    if (errors.length !== 0) {\n      throw errors;\n    }\n\n    const scope = typeGraph.scopes.get(scopeName);\n\n    if (scope === undefined || scope.type !== \"function\") {\n      return;\n    }\n\n    const declaration = scope.declaration;\n\n    if (!(declaration instanceof _variableInfo.VariableInfo)) {\n      throw new Error(\"Never!!!\");\n    }\n\n    return declaration;\n  }\n\n  constructor(parent) {\n    _defineProperty(this, \"body\", new Map());\n\n    _defineProperty(this, \"parent\", void 0);\n\n    this.parent = parent;\n  }\n\n  findVariable({\n    name,\n    loc\n  }, ...rest) {\n    let parent = this;\n\n    do {\n      const variableInfo = parent.body.get(name);\n\n      if (variableInfo !== undefined) {\n        if (variableInfo instanceof _variableInfo.VariableInfo) {\n          return variableInfo;\n        }\n\n        if (!(variableInfo instanceof Scope) && Scope.canTraverseFunction(rest)) {\n          // $FlowIssue\n          let result = Scope.addAndTraverseNodeWithType( // $FlowIssue\n          undefined, variableInfo, ...rest);\n\n          if (result === undefined) {\n            result = this.findVariable({\n              name,\n              loc\n            });\n          }\n\n          if (result !== undefined) {\n            return result;\n          }\n        }\n      }\n\n      parent = parent.parent;\n    } while (parent);\n\n    throw new _errors2.default(`Variable \"${name}\" is not defined!`, loc);\n  }\n\n  findRecord({\n    name,\n    loc\n  }) {\n    let parent = this;\n\n    do {\n      const recordInfo = parent.body.get(name);\n\n      if (recordInfo && !(recordInfo instanceof Scope)) {\n        return recordInfo;\n      }\n\n      parent = parent.parent;\n    } while (parent);\n\n    throw new _errors2.default(`Record \"${name}\" is not defined!`, loc);\n  }\n\n  isParentFor(scope) {\n    let parent = scope;\n\n    do {\n      if (parent === this) {\n        return true;\n      }\n\n      parent = parent.parent;\n    } while (parent != null);\n  }\n\n  getParentsUntil(parent) {\n    const parents = [];\n    let currentScope = this;\n\n    do {\n      parents.push(currentScope);\n      currentScope = currentScope.parent;\n    } while (currentScope !== null && currentScope !== parent);\n\n    return parents;\n  }\n\n  getAllChildScopes(module) {\n    const children = [];\n\n    for (const [_, scope] of module.scopes) {\n      if (this.isParentFor(scope)) {\n        children.push(scope);\n      }\n    }\n\n    return children;\n  }\n\n}\n\nexports.Scope = Scope;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createModuleScope = createModuleScope;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _checking = require(\"../checking\");\n\nvar _checking2 = _interopRequireDefault(_checking);\n\nvar _traverse = require(\"../utils/traverse\");\n\nvar _traverse2 = _interopRequireDefault(_traverse);\n\nvar _globals = require(\"../utils/globals\");\n\nvar _globals2 = _interopRequireDefault(_globals);\n\nvar _utilityTypes = require(\"../utils/utility-types\");\n\nvar _utilityTypes2 = _interopRequireDefault(_utilityTypes);\n\nvar _operators = require(\"../utils/operators\");\n\nvar _operators2 = _interopRequireDefault(_operators);\n\nvar _imports = require(\"../utils/imports\");\n\nvar _imports2 = _interopRequireDefault(_imports);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./types/type\");\n\nvar _meta = require(\"./meta/meta\");\n\nvar _typeVar = require(\"./types/type-var\");\n\nvar _typeScope = require(\"./type-scope\");\n\nvar _refinement = require(\"../inference/refinement\");\n\nvar _unionType = require(\"./types/union-type\");\n\nvar _ignore = require(\"../utils/ignore\");\n\nvar _objectType = require(\"./types/object-type\");\n\nvar _genericType = require(\"./types/generic-type\");\n\nvar _functionType = require(\"./types/function-type\");\n\nvar _variableInfo = require(\"./variable-info\");\n\nvar _variableScope = require(\"./variable-scope\");\n\nvar _variableUtils = require(\"../utils/variable-utils\");\n\nvar _switchRefinement = require(\"../inference/switch-refinement\");\n\nvar _errorType = require(\"../inference/error-type\");\n\nvar _scopeUtils = require(\"../utils/scope-utils\");\n\nvar _moduleScope = require(\"./module-scope\");\n\nvar _call = require(\"./call\");\n\nvar _hierarchy = require(\"../utils/hierarchy\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _functionUtils = require(\"../utils/function-utils\");\n\nvar _classUtils = require(\"../utils/class-utils\");\n\nvar _functionType2 = require(\"../inference/function-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hasTypeParams = node => node.typeParameters && (node.typeParameters.type === _nodes2.default.TYPE_PARAMETER_DECLARATION || node.typeParameters.type === _nodes2.default.TS_TYPE_PARAMETER_DECLARATION) && Array.isArray(node.typeParameters.params) && node.typeParameters.params.length !== 0;\n\nconst getAliasBody = node => {\n  switch (node.type) {\n    case _nodes2.default.TYPE_ALIAS:\n      return {\n        typeAnnotation: node.right\n      };\n\n    case _nodes2.default.TS_INTERFACE_DECLARATION:\n      return {\n        typeAnnotation: node\n      };\n\n    case _nodes2.default.TS_TYPE_ALIAS:\n      return node;\n  }\n\n  throw new Error(node.type);\n};\n\nconst addTypeAlias = (node, parentNode, typeGraph, precompute, middlecompute, postcompute) => {\n  const typeScope = typeGraph.typeScope;\n  const localTypeScope = new _typeScope.TypeScope(typeScope);\n  const typeName = node.id.name;\n\n  const self = _typeVar.TypeVar.createSelf(typeName, typeScope);\n\n  typeScope.body.set(typeName, self);\n  const genericArguments = node.typeParameters && node.typeParameters.params.map(typeAnnotation => (0, _typeUtils.getTypeFromTypeAnnotation)({\n    typeAnnotation\n  }, localTypeScope, typeGraph, true, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n  const name = genericArguments != undefined ? _genericType.GenericType.getName(typeName, genericArguments) : undefined;\n  const type = (0, _typeUtils.getTypeFromTypeAnnotation)(getAliasBody(node), localTypeScope, typeGraph, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute, name);\n  const typeAlias = genericArguments ? _genericType.GenericType.new(typeName, {\n    parent: typeScope\n  }, genericArguments, localTypeScope, type) : type;\n  self.root = typeAlias;\n  self.name = typeAlias.name;\n\n  if (genericArguments != null) {\n    typeAlias.shouldBeUsedAsGeneric = true;\n    self.shouldBeUsedAsGeneric = true;\n  }\n\n  typeScope.body.set(typeName, typeAlias);\n\n  if (node.exportAs) {\n    typeGraph.exportsTypes.set(node.exportAs, typeAlias);\n  }\n\n  if (typeGraph instanceof _moduleScope.PositionedModuleScope) {\n    typeGraph.addPosition(node.id, type);\n  }\n};\n\nconst fillModuleScope = (typeGraph, errors, isTypeDefinitions) => {\n  const typeScope = typeGraph.typeScope;\n  return (currentNode, parentNode, precompute, middlecompute, postcompute, meta = {}) => {\n    if (currentNode.type === _nodes2.default.EXPORT_NAMED_DECLARATION || currentNode.type === _nodes2.default.EXPORT_DEFAULT_DECLARATION) {\n      currentNode = currentNode.declaration;\n    }\n\n    switch (currentNode.type) {\n      case _nodes2.default.VARIABLE_DECLARATION:\n        if (currentNode.init != undefined) {\n          currentNode.declarations.forEach(a => Object.assign(a, {\n            init: currentNode.init\n          }));\n        }\n\n        break;\n\n      case _nodes2.default.VARIABLE_DECLARATOR:\n        const variableInfo = (0, _variableUtils.addVariableToGraph)(Object.assign(currentNode, meta), parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n        if (currentNode.init != undefined && variableInfo.type !== _type.Type.Unknown) {\n          currentNode.init.expected = variableInfo.type;\n        }\n\n        break;\n\n      case _nodes2.default.TYPE_ALIAS:\n      case _nodes2.default.TS_TYPE_ALIAS:\n      case _nodes2.default.TS_INTERFACE_DECLARATION:\n        addTypeAlias(currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute);\n        break;\n\n      case _nodes2.default.CLASS_DECLARATION:\n      case _nodes2.default.CLASS_EXPRESSION:\n      case _nodes2.default.OBJECT_EXPRESSION:\n        (0, _classUtils.addClassScopeToTypeGraph)(currentNode, parentNode, typeGraph);\n        break;\n\n      case _nodes2.default.LOGICAL_EXPRESSION:\n      case _nodes2.default.CONDITIONAL_EXPRESSION:\n      case _nodes2.default.SWITCH_CASE:\n        (0, _refinement.refinement)(currentNode, (0, _scopeUtils.getParentForNode)(currentNode, parentNode, typeGraph), typeScope, typeGraph, errors);\n        break;\n\n      case _nodes2.default.IF_STATEMENT:\n      case _nodes2.default.WHILE_STATEMENT:\n      case _nodes2.default.DO_WHILE_STATEMENT:\n      case _nodes2.default.FOR_STATEMENT:\n      case _nodes2.default.FOR_OF_STATEMENT:\n      case _nodes2.default.FOR_IN_STATEMENT:\n      case _nodes2.default.FOR_IN_STATEMENT:\n        const block = currentNode.body || currentNode.consequent;\n        (0, _scopeUtils.addScopeToTypeGraph)(block, parentNode, typeGraph, currentNode);\n\n        if (currentNode.alternate) {\n          (0, _scopeUtils.addScopeToTypeGraph)(currentNode.alternate, parentNode, typeGraph, currentNode.alternate);\n        }\n\n        if (![_nodes2.default.FOR_OF_STATEMENT, _nodes2.default.FOR_IN_STATEMENT].includes(currentNode.type)) {\n          (0, _refinement.refinement)(currentNode, (0, _scopeUtils.getParentForNode)(block, parentNode, typeGraph), typeScope, typeGraph, errors);\n        }\n\n        if (currentNode.test != undefined) {\n          currentNode.test.isRefinemented = true;\n        }\n\n        break;\n\n      case _nodes2.default.FUNCTION_DECLARATION:\n      case _nodes2.default.TS_FUNCTION_DECLARATION:\n        const existedRecord = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, typeGraph).findRecord(currentNode.id);\n\n        if (existedRecord instanceof _variableInfo.VariableInfo) {\n          return false;\n        }\n\n      case _nodes2.default.FUNCTION_EXPRESSION:\n      case _nodes2.default.ARROW_FUNCTION_EXPRESSION:\n        const functionVariable = (0, _functionUtils.addFunctionToTypeGraph)(currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute, isTypeDefinitions);\n\n        if (currentNode.exportAs) {\n          // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n          typeGraph.exports.set(currentNode.exportAs, functionVariable);\n        }\n\n        break;\n\n      case _nodes2.default.BLOCK_STATEMENT:\n        if (_nodes2.default.isFunction(parentNode) && parentNode.body === currentNode) {\n          break;\n        }\n\n        (0, _scopeUtils.addScopeToTypeGraph)(currentNode, parentNode, typeGraph, currentNode);\n        break;\n\n      case _nodes2.default.OBJECT_METHOD:\n      case _nodes2.default.CLASS_METHOD:\n      case _nodes2.default.CLASS_PRIVATE_METHOD:\n      case _nodes2.default.TS_DECLARE_METHOD:\n        (0, _call.addMethodToThis)(currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute, isTypeDefinitions);\n        break;\n\n      case _nodes2.default.TRY_STATEMENT:\n        currentNode.block.skipCalls = true;\n        const tryBlock = (0, _scopeUtils.getScopeFromNode)(currentNode.block, parentNode, typeGraph, undefined, \"try\");\n        tryBlock.throwable = [];\n        typeGraph.scopes.set(_variableScope.VariableScope.getName(currentNode.block), tryBlock);\n\n        if (!currentNode.handler) {\n          return true;\n        }\n\n        const handlerScopeKey = _variableScope.VariableScope.getName(currentNode.handler.body);\n\n        typeGraph.scopes.set(handlerScopeKey, (0, _scopeUtils.getScopeFromNode)(currentNode.handler.body, parentNode, typeGraph, undefined, \"catch\"));\n\n        if (!currentNode.handler.param) {\n          return true;\n        }\n\n        (0, _variableUtils.addVariableToGraph)(currentNode.handler.param, currentNode.handler.body, typeGraph, precompute, middlecompute, postcompute, currentNode.handler.param.name);\n        break;\n    }\n\n    return true;\n  };\n};\n\nconst middlefillModuleScope = (typeGraph, errors, isTypeDefinitions) => {\n  const typeScope = typeGraph.typeScope;\n  return (currentNode, parentNode, precompute, middlecompute, postcompute, meta = {}) => {\n    if (currentNode.type === _nodes2.default.EXPORT_NAMED_DECLARATION || currentNode.type === _nodes2.default.EXPORT_DEFAULT_DECLARATION) {\n      currentNode = currentNode.declaration || currentNode;\n    }\n\n    switch (currentNode.type) {\n      case _nodes2.default.IMPORT_DECLARATION:\n        errors.push(new _errors2.default(\"All imports should be placed at the top of text document without any statements between.\", currentNode.loc, typeGraph.path));\n        break;\n\n      case _nodes2.default.INTERFACE_DECLARATION:\n        if (isTypeDefinitions) {\n          return;\n        }\n\n        errors.push(new _errors2.default(\"Interfaces do not exist in Hegel. Use 'type alias' instead.\", currentNode.loc, typeGraph.path));\n        break;\n\n      case _nodes2.default.THIS_TYPE_DEFINITION:\n        (0, _classUtils.addThisToClassScope)(currentNode, parentNode, typeScope, typeGraph, precompute, middlecompute, postcompute);\n        break;\n\n      case _nodes2.default.OBJECT_PROPERTY:\n      case _nodes2.default.OBJECT_METHOD:\n      case _nodes2.default.CLASS_PROPERTY:\n      case _nodes2.default.CLASS_METHOD:\n      case _nodes2.default.CLASS_PRIVATE_METHOD:\n      case _nodes2.default.CLASS_PRIVATE_PROPERTY:\n        (0, _classUtils.addPropertyNodeToThis)(currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute);\n        break;\n\n      case _nodes2.default.FUNCTION_DECLARATION:\n      case _nodes2.default.TS_FUNCTION_DECLARATION:\n        (0, _functionUtils.addFunctionNodeToTypeGraph)(currentNode, parentNode, typeGraph);\n        break;\n\n      case _nodes2.default.TS_INTERFACE_DECLARATION:\n      case _nodes2.default.CLASS_DECLARATION:\n      case _nodes2.default.TS_TYPE_ALIAS:\n        if (currentNode.type === _nodes2.default.CLASS_DECLARATION && !isTypeDefinitions) {\n          return;\n        }\n\n        (0, _typeUtils.addTypeNodeToTypeGraph)(currentNode, typeGraph);\n        break;\n    }\n  };\n};\n\nconst afterFillierActions = (moduleScope, errors, isTypeDefinitions) => {\n  return (currentNode, parentNode, precompute, middlecompute, postcompute, meta = {}) => {\n    if (currentNode.type === _nodes2.default.EXPORT_NAMED_DECLARATION || currentNode.type === _nodes2.default.EXPORT_DEFAULT_DECLARATION) {\n      currentNode = currentNode.declaration;\n    }\n\n    const currentScope = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, moduleScope);\n    const typeScope = (0, _scopeUtils.findNearestTypeScope)(currentScope, moduleScope);\n\n    switch (currentNode.type) {\n      case _nodes2.default.OBJECT_EXPRESSION:\n        const obj = (0, _classUtils.addObjectToTypeGraph)(currentNode, moduleScope);\n\n        if (currentNode.exportAs) {\n          moduleScope.exports.set(currentNode.exportAs, obj);\n        }\n\n        break;\n\n      case _nodes2.default.CLASS_PROPERTY:\n      case _nodes2.default.OBJECT_PROPERTY:\n      case _nodes2.default.CLASS_PRIVATE_PROPERTY:\n        (0, _call.addPropertyToThis)(currentNode, parentNode, typeScope, moduleScope, precompute, middlecompute, postcompute);\n        break;\n\n      case _nodes2.default.SWITCH_STATEMENT:\n        (0, _switchRefinement.findUnhandledCases)(currentNode, errors, moduleScope, currentScope, parentNode, precompute, middlecompute, postcompute);\n        break;\n\n      case _nodes2.default.CLASS_DECLARATION:\n      case _nodes2.default.CLASS_EXPRESSION:\n        const classConstructor = (0, _classUtils.addClassToTypeGraph)(currentNode, typeScope, moduleScope, parentNode, precompute, middlecompute, postcompute, isTypeDefinitions);\n\n        if (currentNode.exportAs) {\n          // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n          moduleScope.exports.set(currentNode.exportAs, classConstructor);\n          moduleScope.exportsTypes.set(currentNode.exportAs, // $FlowIssue\n          classConstructor.type.instanceType);\n        }\n\n        break;\n\n      case _nodes2.default.TYPE_ALIAS:\n      case _nodes2.default.TS_TYPE_ALIAS:\n      case _nodes2.default.TS_INTERFACE_DECLARATION:\n        const type = _type.Type.find(currentNode.id.name, {\n          parent: typeScope\n        }, parentNode, moduleScope, precompute, middlecompute, postcompute);\n\n        if (currentNode.exportAs && !moduleScope.exportsTypes.has(currentNode.exportAs)) {\n          moduleScope.exportsTypes.set(currentNode.exportAs, type);\n        }\n\n        break;\n\n      case _nodes2.default.VARIABLE_DECLARATION:\n        break;\n\n      case _nodes2.default.EXPORT_LIST:\n        const isTypeExport = currentNode.exportKind === \"type\";\n        const specifiersSource = isTypeExport ? moduleScope.typeScope : moduleScope;\n        const specifiersTarget = isTypeExport ? moduleScope.exportsTypes : moduleScope.exports;\n        currentNode.specifiers.forEach(({\n          local,\n          exported\n        }) => {\n          const existedVariableOrType = specifiersSource instanceof _moduleScope.ModuleScope ? specifiersSource.findVariable(local, parentNode, moduleScope, precompute, middlecompute, postcompute) : specifiersSource.findTypeWithName(local.name, parentNode, moduleScope, precompute, middlecompute, postcompute); // $FlowIssue\n\n          specifiersTarget.set(exported.name, existedVariableOrType);\n        });\n        break;\n\n      case _nodes2.default.VARIABLE_DECLARATOR:\n        const variableInfo = currentScope.findVariable(currentNode.id);\n        const newTypeOrVar = isTypeDefinitions && currentNode.init === null ? _type.Type.Unknown : (0, _call.addCallToTypeGraph)(currentNode, moduleScope, currentScope, parentNode, precompute, middlecompute, postcompute);\n\n        if (currentNode.id != null && currentNode.id.typeAnnotation == undefined && currentNode.init !== null) {\n          const newType = newTypeOrVar.result instanceof _variableInfo.VariableInfo ? newTypeOrVar.result.type : newTypeOrVar.result;\n          variableInfo.type = (0, _variableUtils.getVariableType)(variableInfo, newType, typeScope, newTypeOrVar.inferenced);\n        }\n\n        if (currentNode.exportAs) {\n          moduleScope.exports.set(currentNode.exportAs, variableInfo);\n        }\n\n        break;\n\n      case _nodes2.default.BLOCK_STATEMENT:\n        if (!currentNode.catchBlock || !currentNode.catchBlock.param) {\n          return;\n        }\n\n        if (currentNode.catchBlock.param.type !== _nodes2.default.IDENTIFIER) {\n          throw new Error(\"Unsupported yet\");\n        }\n\n        const errorVariable = (0, _scopeUtils.getParentForNode)(currentNode.catchBlock.param, currentNode.catchBlock.body, moduleScope).findVariable(currentNode.catchBlock.param, parentNode, moduleScope, precompute, middlecompute, postcompute);\n        errorVariable.type = (0, _errorType.inferenceErrorType)(currentNode, moduleScope);\n        errorVariable.type = _unionType.UnionType.term(null, {}, [_type.Type.Unknown, errorVariable.type]);\n\n        if (moduleScope instanceof _moduleScope.PositionedModuleScope) {\n          moduleScope.addPosition(currentNode.catchBlock.param, errorVariable);\n        }\n\n        break;\n\n      case _nodes2.default.IF_STATEMENT:\n      case _nodes2.default.RETURN_STATEMENT:\n      case _nodes2.default.EXPRESSION_STATEMENT:\n      case _nodes2.default.WHILE_STATEMENT:\n      case _nodes2.default.DO_WHILE_STATEMENT:\n      case _nodes2.default.FOR_STATEMENT:\n      case _nodes2.default.THROW_STATEMENT:\n      case _nodes2.default.NEW_EXPRESSION:\n        const resultOfCall = (0, _call.addCallToTypeGraph)(currentNode, moduleScope, currentScope, parentNode, precompute, middlecompute, postcompute, {\n          isForInit: parentNode.kind === \"constructor\"\n        }).result;\n        const invocationResultType = resultOfCall instanceof _variableInfo.VariableInfo ? resultOfCall.type : resultOfCall;\n\n        if ((0, _functionUtils.isSideEffectCall)(currentNode, invocationResultType)) {\n          const functionName = currentNode.expression.callee.name || \"Anonymous Function\";\n          errors.push(new _errors2.default(`You use function \"${functionName}\" as side effect function, but it returns a ${String(invocationResultType.name)} type`, currentNode.loc, moduleScope.path));\n        }\n\n        if (currentNode.exportAs) {\n          const exportVar = resultOfCall instanceof _variableInfo.VariableInfo ? resultOfCall : new _variableInfo.VariableInfo(resultOfCall, moduleScope);\n          moduleScope.exports.set(currentNode.exportAs, exportVar);\n        }\n\n        break;\n\n      case _nodes2.default.OBJECT_METHOD:\n      case _nodes2.default.CLASS_METHOD:\n      case _nodes2.default.CLASS_PRIVATE_METHOD:\n      case _nodes2.default.FUNCTION_EXPRESSION:\n      case _nodes2.default.ARROW_FUNCTION_EXPRESSION:\n      case _nodes2.default.FUNCTION_DECLARATION:\n        const functionScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n        if (functionScope === undefined) {\n          throw new Error(\"Never!!!\");\n        }\n\n        const {\n          declaration\n        } = functionScope;\n\n        if (declaration === undefined) {\n          throw new Error(\"Never!!!\");\n        }\n\n        const declarationType = declaration.type instanceof _genericType.GenericType ? declaration.type.subordinateType : declaration.type;\n\n        if (declarationType instanceof _objectType.ObjectType) {\n          throw new Error(\"Never!!!\");\n        }\n\n        if (!isTypeDefinitions && (functionScope.throwable == undefined || functionScope.throwable.length === 0) && declarationType.throwable !== undefined) {\n          throw new _errors2.default(`Function should throw \"${String(declarationType.throwable.name)}\" but throws nothing`, currentNode.returnType ? currentNode.returnType.loc : currentNode.loc);\n        }\n\n        if (functionScope.throwable != undefined && functionScope.throwable.length !== 0 && declarationType.throwable === undefined) {\n          const throwableType = (0, _errorType.inferenceErrorType)(currentNode, moduleScope);\n\n          const fnName = _functionType.FunctionType.getName(declarationType.argumentsTypes, declarationType.returnType, declaration.type instanceof _genericType.GenericType ? declaration.type.genericArguments : [], declarationType.isAsync, throwableType);\n\n          let newFunctionType = _functionType.FunctionType.term(fnName, {}, declarationType.argumentsTypes, declarationType.returnType, declarationType.isAsync);\n\n          newFunctionType.throwable = throwableType;\n\n          if (declaration.type instanceof _genericType.GenericType && newFunctionType instanceof _functionType.FunctionType) {\n            newFunctionType = _genericType.GenericType.new(fnName, {}, declaration.type.genericArguments, declaration.type.localTypeScope, newFunctionType);\n          }\n\n          declaration.type = newFunctionType;\n        }\n\n        const fnType = functionScope.declaration && functionScope.declaration.type;\n\n        if (fnType instanceof _genericType.GenericType && functionScope.type === _variableScope.VariableScope.FUNCTION_TYPE && fnType.subordinateType instanceof _functionType.FunctionType) {\n          // $FlowIssue - Type refinements\n          (0, _functionType2.prepareGenericFunctionType)(functionScope);\n\n          if (fnType.genericArguments.some(a => !a.isUserDefined)) {\n            (0, _functionType2.inferenceFunctionTypeByScope)( // $FlowIssue - Type refinements\n            functionScope, typeScope, moduleScope);\n          }\n        }\n\n        if (currentNode.exportAs) {\n          // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n          moduleScope.exports.set(currentNode.exportAs, declaration);\n        }\n\n        break;\n\n      case _nodes2.default.TS_EXPORT_ASSIGNMENT:\n        let whatWillBeExported = (0, _call.addCallToTypeGraph)(currentNode.expression, moduleScope, currentScope, parentNode, precompute, middlecompute, postcompute).result;\n\n        if (whatWillBeExported instanceof _type.Type) {\n          whatWillBeExported = new _variableInfo.VariableInfo(whatWillBeExported, moduleScope);\n        }\n\n        moduleScope.exports.set(\"default\", whatWillBeExported);\n        const exportedType = whatWillBeExported.type;\n\n        if (exportedType instanceof _objectType.ObjectType) {\n          exportedType.properties.forEach((value, key) => {\n            moduleScope.exports.set(key, value);\n          });\n        }\n\n        break;\n\n      default:\n        if (currentNode.exportAs) {\n          const value = (0, _call.addCallToTypeGraph)(currentNode, moduleScope, currentScope, parentNode, precompute, middlecompute, postcompute, {\n            isTypeDefinitions\n          }).result;\n          moduleScope.exports.set(currentNode.exportAs, value instanceof _variableInfo.VariableInfo ? value : new _variableInfo.VariableInfo(value, currentScope, new _meta.Meta(currentNode.loc)));\n        }\n\n        break;\n    }\n\n    if (currentNode.type === _nodes2.default.THROW_STATEMENT || currentNode.type === _nodes2.default.RETURN_STATEMENT) {\n      throw new _errors.UnreachableError(currentNode.loc);\n    }\n  };\n};\n\nasync function createModuleScope(file, globalErrors, getModuleTypeGraph, globalModule, isTypeDefinitions, withPositions = true) {\n  const errors = _ignore.IgnorableArray.withIgnoring(file.comments, file.path);\n\n  const ast = file.program;\n  const typeScope = new _typeScope.TypeScope(globalModule.typeScope);\n  const module = new (withPositions ? _moduleScope.PositionedModuleScope : _moduleScope.ModuleScope)(file.path, new Map(), globalModule, typeScope);\n  await (0, _imports2.default)(ast, file.path, errors, module, typeScope, getModuleTypeGraph, isTypeDefinitions);\n  (0, _traverse2.default)(ast, fillModuleScope(module, errors, isTypeDefinitions), middlefillModuleScope(module, errors, isTypeDefinitions), afterFillierActions(module, errors, isTypeDefinitions), null, {\n    errors\n  });\n  module.scopes.forEach(scope => (0, _checking2.default)(file.path, scope, typeScope, errors));\n  (0, _checking2.default)(file.path, module, typeScope, errors);\n  globalErrors.push(...errors);\n  return module;\n}\n\nasync function createGlobalScope(files, getModuleTypeGraph, isTypeDefinitions = false, mixTypeDefinitions = a => {}, withPositions = false) {\n  const errors = [];\n  const globalModule = new _moduleScope.ModuleScope(\"#global\");\n  _type.Type.prettyMode = withPositions;\n  (0, _hierarchy.setupBaseHierarchy)(globalModule.typeScope);\n  (0, _globals2.default)(globalModule);\n  (0, _utilityTypes2.default)(globalModule);\n  await mixTypeDefinitions(globalModule);\n  (0, _hierarchy.setupFullHierarchy)(globalModule.typeScope);\n  (0, _operators2.default)(globalModule);\n\n  const createDependencyModuleScope = (file, isTypeDefinitions) => createModuleScope(file, errors, getModuleFromString, globalModule, isTypeDefinitions);\n\n  const getModuleFromString = (path, currentPath, loc) => getModuleTypeGraph(path, currentPath, loc, createDependencyModuleScope);\n\n  const modules = await Promise.all(files.map(module => createModuleScope(module, errors, getModuleFromString, globalModule, isTypeDefinitions, withPositions)));\n  (0, _hierarchy.dropAllGlobals)();\n  return [modules, errors, globalModule];\n}\n\nexports.default = createGlobalScope;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeScope = undefined;\n\nvar _type = require(\"./types/type\");\n\nvar _scope = require(\"./scope\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass TypeScope {\n  constructor(parent, priority = parent === undefined ? TypeScope.GLOBAL_SCOPE_PRIORITY : parent.priority + 1) {\n    _defineProperty(this, \"priority\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"body\", new Map());\n\n    this.parent = parent === undefined ? null : parent;\n    this.priority = priority;\n  }\n\n  makeCustom() {\n    this.priority += 100;\n  }\n\n  findTypeWithName(name, ...rest) {\n    let currentTypeScope = this;\n    let existedType = undefined;\n\n    while (currentTypeScope !== null) {\n      existedType = currentTypeScope.body.get(name);\n\n      if (existedType !== undefined) {\n        if (existedType instanceof _type.Type) {\n          return _type.Type.getTypeRoot(existedType);\n        }\n\n        if (_scope.Scope.canTraverseFunction(rest)) {\n          // $FlowIssue\n          let result = _scope.Scope.addAndTraverseNodeWithType( // $FlowIssue\n          undefined, existedType, ...rest);\n\n          result = result === undefined ? this.findTypeWithName(name) : result.type;\n\n          if (result !== undefined) {\n            return _type.Type.getTypeRoot(result);\n          }\n        }\n      }\n\n      currentTypeScope = currentTypeScope.parent;\n    }\n\n    return undefined;\n  }\n\n}\n\nexports.TypeScope = TypeScope;\n\n_defineProperty(TypeScope, \"GLOBAL_SCOPE_PRIORITY\", 0);\n\n_defineProperty(TypeScope, \"MODULE_SCOPE_PRIORITY\", 1);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$BottomType = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _functionType = require(\"./function-type\");\n\nclass $BottomType extends _type.Type {\n  static get name() {\n    return \"$BottomType\";\n  }\n\n  static getParent(meta, _, genericArguments = []) {\n    return genericArguments.reduce((parent, type) => parent.priority < type.parent.priority ? type.parent : parent, meta.parent || _type.Type.GlobalTypeScope);\n  }\n\n  static new(name, meta = {}, ...args) {\n    const parent = this.getParent(meta, ...args);\n    const newMeta = { ...meta,\n      parent\n    };\n    const newType = new this(newMeta, ...args);\n    parent.body.set(name, newType);\n    return newType;\n  }\n\n  static getName(name, parameters) {\n    name = name.replace(/<.+>/g, \"\");\n\n    if (parameters.length === 0) {\n      return String(name);\n    }\n\n    return `${String(name)}<${parameters.reduce((res, t) => `${res}${res ? \", \" : \"\"}${String(_type.Type.getTypeRoot(t).name)}`, \"\")}>`;\n  }\n\n  constructor(meta, subordinateMagicType, genericArguments = [], loc) {\n    meta = { ...meta,\n      parent: $BottomType.getParent(meta, subordinateMagicType, genericArguments)\n    };\n    super($BottomType.getName(subordinateMagicType.name, genericArguments), meta);\n    this.subordinateMagicType = subordinateMagicType;\n    this.genericArguments = genericArguments;\n    this.loc = loc;\n    this.priority = subordinateMagicType.priority + 1;\n    this.isForAssign = meta.isForAssign;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n    let includedUndefined = false;\n    let includedBottom = false;\n    let includedTypeVar = false;\n    const includedSelfIndex = sourceTypes.findIndex(t => this.equalsTo(t));\n\n    if (includedSelfIndex !== -1) {\n      return this.endChanges(targetTypes[includedSelfIndex]);\n    }\n\n    const mapper = argument => {\n      if (argument instanceof $BottomType) {\n        const newType = argument.changeAll(sourceTypes, targetTypes, typeScope);\n        includedBottom = true;\n        return newType !== argument ? newType : undefined;\n      }\n\n      if (argument instanceof _typeVar.TypeVar) {\n        const argumentIndex = sourceTypes.findIndex(a => argument instanceof $BottomType ? argument.subordinateType === a : a.equalsTo(argument));\n        const result = argumentIndex === -1 ? undefined : targetTypes[argumentIndex];\n\n        if (result === undefined) {\n          includedUndefined = true;\n        }\n\n        if (result instanceof _typeVar.TypeVar && !_typeVar.TypeVar.isSelf(result)) {\n          includedTypeVar = true;\n        }\n\n        return result;\n      }\n\n      if (argument instanceof _unionType.UnionType) {\n        const newType = argument.changeAll(sourceTypes, targetTypes, typeScope);\n\n        if (newType.parent.priority > _typeScope.TypeScope.MODULE_SCOPE_PRIORITY) {\n          includedTypeVar = true;\n        }\n\n        return newType;\n      }\n\n      return argument;\n    };\n\n    try {\n      const appliedParameters = this.genericArguments.map(mapper);\n\n      if (appliedParameters.every(a => a === undefined)) {\n        return this.endChanges(this);\n      }\n\n      if (includedUndefined) {\n        const type = this.subordinateMagicType.changeAll(sourceTypes, targetTypes, typeScope);\n        return this.endChanges(new $BottomType({}, type, type.genericArguments, this.loc));\n      }\n\n      if (includedBottom || includedTypeVar) {\n        return this.endChanges(new $BottomType({}, this.subordinateMagicType, appliedParameters, this.loc));\n      }\n\n      const target = this.subordinateMagicType instanceof _typeVar.TypeVar && this.subordinateMagicType.root != undefined ? this.subordinateMagicType.root : this.subordinateMagicType;\n      return this.endChanges(target.applyGeneric(appliedParameters, this.loc, false, false, this.isForASsign));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  unpack(loc = this.loc) {\n    const target = this.subordinateMagicType instanceof _typeVar.TypeVar && this.subordinateMagicType.root != undefined ? _type.Type.getTypeRoot(this.subordinateMagicType) : this.subordinateMagicType;\n\n    if (\"subordinateType\" in target) {\n      const parameters = this.genericArguments.map(t => {\n        if (t instanceof $BottomType) {\n          t = t.unpack(loc);\n        }\n\n        if (t instanceof _typeVar.TypeVar && t.root !== undefined) {\n          t = _type.Type.getTypeRoot(t);\n        }\n\n        return t;\n      });\n      return target.applyGeneric(parameters, loc, true, true, this.isForAssign);\n    }\n\n    throw new Error(`Never!!! ${target.constructor.name}`);\n  }\n\n  isPrincipalTypeFor(other) {\n    if (this._alreadyProcessedWith === other || this.equalsTo(other)) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = other;\n    const self = this.unpack();\n\n    if (self instanceof $BottomType) {\n      return super.isPrincipalTypeFor(other);\n    }\n\n    const result = self.isPrincipalTypeFor(other);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize, isCalledAsBottom, ...args) {\n    const returnType = parameters.some(p => p instanceof _typeVar.TypeVar && p.isUserDefined) ? new $BottomType({}, this.subordinateMagicType, parameters, loc) : this.subordinateMagicType.applyGeneric(parameters, loc, shouldBeMemoize, true, this.isForAssign);\n    return _functionType.FunctionType.term(_functionType.FunctionType.getName(parameters, returnType), {}, parameters, returnType);\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    if (type instanceof _typeVar.TypeVar) {\n      return [{\n        root: this,\n        variable: type\n      }];\n    }\n\n    if (type instanceof $BottomType) {\n      type = type.subordinateMagicType;\n    }\n\n    const subordinate = this.getOponentType(this.subordinateMagicType);\n    this._alreadyProcessedWith = type;\n    const diff = subordinate.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return \"genericArguments\" in subordinate ? diff.map(diff => {\n      const index = subordinate.genericArguments.indexOf(diff.variable);\n\n      if (index === -1) {\n        return diff;\n      }\n\n      return {\n        variable: this.genericArguments[index],\n        root: diff.root\n      };\n    }) : diff;\n  }\n\n  getRootedSubordinateType() {\n    const {\n      subordinateMagicType\n    } = this;\n\n    if (\"subordinateType\" in subordinateMagicType) {\n      subordinateMagicType.genericArguments.forEach((arg, index) => {\n        arg.root = this.genericArguments[index];\n      });\n    }\n\n    return subordinateMagicType;\n  }\n\n  unrootSubordinateType() {\n    const {\n      subordinateMagicType\n    } = this;\n\n    if (\"subordinateType\" in subordinateMagicType) {\n      subordinateMagicType.genericArguments.forEach((arg, index) => {\n        arg.root = undefined;\n      });\n    }\n  }\n\n  equalsTo(type) {\n    if (this.referenceEqualsTo(type)) {\n      return true;\n    }\n\n    if (this._alreadyProcessedWith === type) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = type;\n\n    const result = type instanceof $BottomType && this.canContain(type) && this.genericArguments.length === type.genericArguments.length && this.genericArguments.every((arg, i) => arg.equalsTo(type.genericArguments[i])) && _type.Type.getTypeRoot(this.subordinateMagicType) === _type.Type.getTypeRoot(type.subordinateMagicType);\n\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = this.genericArguments.some(a => a.contains(type)) || this.subordinateMagicType.contains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = this.genericArguments.some(a => a.weakContains(type)) || this.subordinateMagicType.weakContains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  makeNominal() {\n    this.subordinateMagicType.makeNominal();\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = [...this.genericArguments].map(a => a.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.$BottomType = $BottomType;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Class = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Class extends _genericType.GenericType {\n  static get name() {\n    return \"$Class\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Class\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType && realTarget.classType !== null)) {\n      throw new _errors2.default(\"Cannot apply $Class to non-class instance type\", loc);\n    }\n\n    return realTarget.classType;\n  }\n\n}\n\nexports.$Class = $Class;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Collection = exports.CollectionType = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass CollectionType extends _type.Type {\n  static get name() {\n    return \"CollectionType\";\n  }\n\n  static term(name, meta = {}, keyType, valueType, ...args) {\n    let parent = meta.parent;\n\n    if (parent === undefined || keyType.parent.priority > parent.priority) {\n      parent = keyType.parent;\n    }\n\n    if (parent === undefined || valueType.parent.priority > parent.priority) {\n      parent = valueType.parent;\n    }\n\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, keyType, valueType, ...args);\n  }\n\n  static getName(keyType, valueType) {\n    return `{ [key: ${String(_type.Type.getTypeRoot(keyType).name)}]: ${String(_type.Type.getTypeRoot(valueType).name)} }`;\n  }\n\n  constructor(name, meta = {}, keyType, valueType) {\n    super(name, meta);\n\n    _defineProperty(this, \"keyType\", void 0);\n\n    _defineProperty(this, \"valueType\", void 0);\n\n    _defineProperty(this, \"priority\", 2);\n\n    this.keyType = keyType;\n    this.valueType = valueType;\n    this.onlyLiteral = true;\n  }\n\n  getPropertyType(propertyName, isForAssign = false) {\n    const result = super.getPropertyType(propertyName);\n\n    if (result !== null) {\n      return result;\n    }\n\n    if (typeof propertyName === this.keyType.name || propertyName === this.keyType.name) {\n      if (isForAssign) {\n        return this.valueType;\n      }\n\n      const result = this.valueType instanceof _unionType.UnionType && this.valueType.variants.some(a => a.equalsTo(_type.Type.Undefined)) ? this.valueType : _unionType.UnionType.term(null, {}, [this.valueType, _type.Type.Undefined]);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  equalsTo(anotherType) {\n    anotherType = this.getOponentType(anotherType, true, false);\n\n    if (this.referenceEqualsTo(anotherType)) {\n      return true;\n    }\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    if (\"readonly\" in anotherType && this.equalsTo( // $FlowIssue ReadonlyArray is always GenericType\n    _tupleType.TupleType.ReadonlyArray.root.applyGeneric([this.valueType]).readonly) && this === anotherType.readonly) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const result = anotherType instanceof CollectionType && super.equalsTo(anotherType) && this.canContain(anotherType) && this.keyType.equalsTo(anotherType.keyType) && this.valueType.equalsTo(anotherType.valueType);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  isSuperTypeFor(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    const selfNameWithoutApplying = _genericType.GenericType.getNameWithoutApplying(this.name);\n\n    const otherfNameWithoutApplying = _genericType.GenericType.getNameWithoutApplying(anotherType.name);\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const result = anotherType instanceof CollectionType && selfNameWithoutApplying === otherfNameWithoutApplying && this.keyType.equalsTo(anotherType.keyType) && this.valueType.isPrincipalTypeFor(anotherType.valueType) || anotherType instanceof _tupleType.TupleType && (this.equalsTo( // $FlowIssue Array is always GenericType\n    CollectionType.Array.root.applyGeneric([this.valueType])) || this.equalsTo( // $FlowIssue ReadonlyArray is always GenericType\n    _tupleType.TupleType.ReadonlyArray.root.applyGeneric([this.valueType]))) && anotherType.items.every(t => this.valueType.isPrincipalTypeFor(t));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n\n    try {\n      const newValueType = this.valueType.changeAll(sourceTypes, targetTypes, typeScope);\n      const isSubtypeOf = this.isSubtypeOf && this.isSubtypeOf.changeAll(sourceTypes, targetTypes, typeScope);\n      return this.endChanges(newValueType === this.valueType && isSubtypeOf === this.isSubtypeOf ? this : CollectionType.term(this.getChangedName(sourceTypes, targetTypes), {\n        isSubtypeOf\n      }, this.keyType, newValueType));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    type = this.getOponentType(type);\n\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (type instanceof _tupleType.TupleType) {\n      // $FlowIssue\n      type = type.isSubtypeOf;\n    }\n\n    if (type instanceof CollectionType) {\n      const keyDiff = this.keyType.getDifference(type.keyType, withReverseUnion);\n      const valueDiff = this.valueType.getDifference(type.valueType, withReverseUnion);\n      this._alreadyProcessedWith = null;\n      return keyDiff.concat(valueDiff);\n    }\n\n    const result = super.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.keyType.contains(type) || this.valueType.contains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.keyType.weakContains(type) || this.valueType.weakContains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  makeNominal() {\n    // $FlowIssue\n    this.isSubtypeOf.makeNominal();\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = [this.keyType, this.valueType].map(a => a.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.CollectionType = CollectionType;\n\n_defineProperty(CollectionType, \"Array\", new _typeVar.TypeVar(\"Array\"));\n\nclass $Collection extends _genericType.GenericType {\n  static get name() {\n    return \"$Collection\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Collection\", meta, [_typeVar.TypeVar.term(\"key\", {\n      parent\n    }), _typeVar.TypeVar.term(\"value\", {\n      parent\n    })], parent, // $FlowIssue\n    null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [key, value] = parameters;\n    return CollectionType.term(`$Collection<${String(key.name)}, ${String(value.name)}>`, {}, key, value);\n  }\n\n}\n\nexports.$Collection = $Collection;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Entries = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _collectionType = require(\"./collection-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Entries extends _genericType.GenericType {\n  static get name() {\n    return \"$Entries\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Entries\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc) {\n    super.assertParameters(parameters, loc);\n    const [currentTarget] = parameters;\n    const realTarget = this.getOponentType(currentTarget);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType) && !(realTarget instanceof _collectionType.CollectionType)) {\n      throw new _errors2.default(\"First parameter should be an object or collection type\", loc);\n    }\n\n    if (realTarget instanceof _collectionType.CollectionType) {\n      return _tupleType.TupleType.term(null, {}, [realTarget.keyType, realTarget.valueType]);\n    }\n\n    const values = [...realTarget.properties.entries()];\n    const variants = values.map(([key, value]) => _tupleType.TupleType.term(null, {}, [_type.Type.term(`'${key}'`, {\n      isSubtypeOf: _type.Type.String\n    }), value.type]));\n\n    if (!realTarget.isStrict) {\n      variants.push(_type.Type.Unknown);\n    }\n\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n}\n\nexports.$Entries = $Entries;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Exclude = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Exclude extends _genericType.GenericType {\n  static get name() {\n    return \"$Exclude\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Exclude\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    }), _typeVar.TypeVar.term(\"properties\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target, whichShouldBeExclude] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _unionType.UnionType)) {\n      throw new _errors2.default(\"First parameter should be an union type\", loc);\n    }\n\n    const picks = whichShouldBeExclude instanceof _unionType.UnionType ? whichShouldBeExclude.variants : [whichShouldBeExclude];\n    const pickedVariants = target.variants.filter(variant => picks.find(pick => pick.equalsTo(variant)) === undefined);\n    return _unionType.UnionType.term(null, {}, pickedVariants);\n  }\n\n}\n\nexports.$Exclude = $Exclude;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FunctionType = exports.RestArgument = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _constants = require(\"../constants\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass RestArgument extends _type.Type {\n  static get name() {\n    return \"RestArgument\";\n  }\n\n  static term(name, meta = {}, type, ...args) {\n    name = name == null ? this.getName(type) : name;\n    const newMeta = { ...meta,\n      parent: meta.parent === undefined || type.parent.priority > meta.parent.priority ? type.parent : meta.parent\n    };\n    return super.term(name, newMeta, type, ...args);\n  }\n\n  static getName(type) {\n    return `...${String(type.name)}`;\n  }\n\n  static getValueType(type) {\n    type = type.getOponentType(type);\n\n    if (\"valueType\" in type) {\n      // $FlowIssue\n      return type.valueType;\n    }\n\n    if (\"items\" in type) {\n      // $FlowIssue TupleType always has isSubtypeOf\n      return this.getValueType(type.isSubtypeOf);\n    }\n\n    if (type instanceof _unionType.UnionType) {\n      const variants = type.variants.map(this.getValueType);\n      return variants.includes(undefined) ? undefined : _unionType.UnionType.term(null, {}, variants);\n    }\n  }\n\n  constructor(name, meta = {}, type) {\n    name = name == null ? RestArgument.getName(type) : name;\n    super(name, meta);\n\n    _defineProperty(this, \"type\", void 0);\n\n    this.type = type;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.name, this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n\n    try {\n      const newType = this.type.changeAll(sourceTypes, targetTypes, typeScope);\n      return this.endChanges(this.type === newType ? this : RestArgument.term(null, {}, newType));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  isType(action, anotherType) {\n    const innerType = anotherType instanceof RestArgument ? anotherType.type : anotherType;\n    const selfType = this.getOponentType(this.type, false);\n    const otherType = this.getOponentType(innerType, false);\n    const selfValueType = RestArgument.getValueType(selfType);\n    const otherValueType = RestArgument.getValueType(otherType);\n    return selfValueType !== undefined && otherValueType !== undefined && selfValueType[action](otherValueType);\n  }\n\n  equalsTo(anotherType) {\n    return anotherType instanceof RestArgument && this.isType(\"equalsTo\", anotherType);\n  }\n\n  isSuperTypeFor(anotherType) {\n    return this.isType(\"isSuperTypeFor\", anotherType);\n  }\n\n  contains(type) {\n    return this.type.contains(type);\n  }\n\n  weakContains(type) {\n    return this.type.weakContains(type);\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    // $FlowIssue\n    return this.getOponentType(this.type).getDifference(type, withReverseUnion);\n  }\n\n}\n\nexports.RestArgument = RestArgument;\n\nclass FunctionType extends _type.Type {\n  static get name() {\n    return \"FunctionType\";\n  }\n\n  static term(name, meta = {}, argumentsTypes, returnType, ...args) {\n    let parent = meta.parent;\n    const searchingItems = argumentsTypes.concat([returnType]);\n    const length = searchingItems.length;\n\n    for (let i = 0; i < length; i++) {\n      const item = searchingItems[i];\n\n      if (item instanceof _type.Type && (parent === undefined || parent.priority < item.parent.priority)) {\n        parent = item.parent;\n      }\n    }\n\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, argumentsTypes, returnType, ...args);\n  }\n\n  static getName(params, returnType, genericParams = [], isAsync = false, throws) {\n    const asyncPart = this.getAsyncPart(isAsync);\n    const genericPart = this.getGenericPart(genericParams, this.prettyMode && genericParams.length >= 4);\n    const argsPart = this.getArgumentsPart(params, this.prettyMode && (params.length >= 4 || params.some(param => String(param.name).includes(\"\\n\")) && params.length !== 1));\n    const throwsPart = this.getThrowsPart(throws);\n    const returnPart = this.getReturnPart(returnType);\n    return this.prettyMode ? this.multyLine(asyncPart, genericPart, argsPart, throwsPart, returnPart) : this.oneLine(asyncPart, genericPart, argsPart, throwsPart, returnPart);\n  }\n\n  static oneLine(asyncPart, genericPart, argsPart, throwsPart, returnPart) {\n    return `${asyncPart}${genericPart}${argsPart} => ${returnPart}${throwsPart}`;\n  }\n\n  static multyLine(asyncPart, genericPart, argsPart, throwsPart, returnPart) {\n    return `${asyncPart}${genericPart}${argsPart} => ${returnPart.replace(/\\n/g, \"\\n\\t\")}${throwsPart}`;\n  }\n\n  static getAsyncPart(isAsync) {\n    return isAsync ? \"async \" : \"\";\n  }\n\n  static getGenericPart(genericParams = [], isMultyLine = false) {\n    return genericParams.length === 0 ? \"\" : `<${genericParams.reduce((res, t) => `${res}${res ? `,${isMultyLine ? \"\\n\\t\" : \" \"}` : \"\"}${String(t.name)}${t.constraint ? `: ${String(t.constraint.name)}` : \"\"}`, \"\")}>`;\n  }\n\n  static getArgumentsPart(args = [], isMultyLine = false) {\n    return `(${isMultyLine ? \"\\n\\t\" : \"\"}${args.map(param => {\n      const isRest = param instanceof RestArgument; // $FlowIssue\n\n      param = _type.Type.getTypeRoot(isRest ? param.type : param);\n      const t = String(param.name);\n      const name = isRest ? `...${t}` : t;\n      return isMultyLine ? name.replace(/\\n/g, \"\\n\\t\") : name;\n    }).join(isMultyLine ? \",\\n\\t\" : \", \")}${isMultyLine ? \"\\n\" : \"\"})`;\n  }\n\n  static getThrowsPart(throws) {\n    return throws !== undefined ? ` throws ${String(throws.name)}` : \"\";\n  }\n\n  static getReturnPart(returnType) {\n    return String(returnType.name);\n  }\n\n  constructor(name, typeMeta = {}, argumentsTypes, returnType, isAsync = false) {\n    super(name, {\n      isSubtypeOf: FunctionType.Function,\n      ...typeMeta\n    });\n\n    _defineProperty(this, \"argumentsTypes\", void 0);\n\n    _defineProperty(this, \"returnType\", void 0);\n\n    _defineProperty(this, \"throwable\", void 0);\n\n    _defineProperty(this, \"isAsync\", void 0);\n\n    _defineProperty(this, \"priority\", 2);\n\n    this.argumentsTypes = argumentsTypes;\n    this.returnType = returnType;\n    this.isAsync = isAsync;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n    let isArgumentsChanged = false;\n\n    try {\n      const newArguments = this.argumentsTypes.map(t => {\n        const newT = t.changeAll(sourceTypes, targetTypes, typeScope);\n\n        if (newT === t) {\n          return t;\n        }\n\n        isArgumentsChanged = true;\n        return newT;\n      });\n      const newReturn = this.returnType.changeAll(sourceTypes, targetTypes, typeScope);\n\n      if (newReturn === this.returnType && !isArgumentsChanged) {\n        return this.endChanges(this);\n      }\n\n      const result = FunctionType.term(FunctionType.getName(newArguments, newReturn, undefined, this.isAsync), {}, newArguments, newReturn);\n      result.isAsync = this.isAsync;\n      return this.endChanges(result);\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  equalsTo(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this.referenceEqualsTo(anotherType)) {\n      return true;\n    }\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const result = anotherType instanceof FunctionType && super.equalsTo(anotherType) && this.canContain(anotherType) && this.returnType.equalsTo(anotherType.returnType) && (this.throwable === anotherType.throwable || this.throwable !== undefined && anotherType.throwable !== undefined && this.throwable.equalsTo(anotherType.throwable)) && this.argumentsTypes.length === anotherType.argumentsTypes.length && this.argumentsTypes.every((arg, i) => // $FlowIssue\n    arg.equalsTo(anotherType.argumentsTypes[i]));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  isSuperTypeFor(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n\n    if (!(anotherType instanceof FunctionType)) {\n      anotherType = anotherType.getPropertyType(_constants.CALLABLE);\n\n      if (anotherType === null) {\n        this._alreadyProcessedWith = null;\n        return false;\n      }\n    }\n\n    const anotherTypeRequiredArguments = anotherType.argumentsTypes.filter(a => !a.isPrincipalTypeFor(_type.Type.Undefined));\n    const result = this.returnType.isPrincipalTypeFor(anotherType.returnType) && (this.throwable === undefined || anotherType.throwable !== undefined && this.throwable.isPrincipalTypeFor(anotherType.throwable)) && this.argumentsTypes.length >= anotherTypeRequiredArguments.length && anotherType.argumentsTypes.every((arg, i) => {\n      const anotherArgument = this.argumentsTypes[i] || _type.Type.Undefined;\n      return arg.onlyLiteral ? arg.equalsTo(anotherArgument) : arg.isPrincipalTypeFor(anotherArgument);\n    });\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (\"subordinateType\" in type && // $FlowIssue\n    type.subordinateType instanceof FunctionType) {\n      type = type.subordinateType;\n    }\n\n    if (type instanceof FunctionType) {\n      const {\n        argumentsTypes,\n        returnType\n      } = type; // $FlowIssue\n\n      const argumentsDiff = this.argumentsTypes.flatMap((arg, i) => argumentsTypes[i] ? arg.getDifference(argumentsTypes[i], withReverseUnion) : []);\n      const returnDiff = this.returnType.getDifference(returnType, withReverseUnion);\n      this._alreadyProcessedWith = null;\n      return argumentsDiff.concat(returnDiff);\n    }\n\n    const result = super.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.argumentsTypes.some(a => a.contains(type)) || this.returnType.contains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.weakContains(type) || this.argumentsTypes.some(a => a.weakContains(type)) || this.returnType.weakContains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  generalize(types, typeScope) {\n    const localTypeScope = new _typeScope.TypeScope(typeScope);\n    const newArguments = this.argumentsTypes.map(arg => arg.generalize(types, localTypeScope));\n    const newReturnType = this.returnType.generalize(types, localTypeScope);\n    const maybeGenericTypes = newArguments.concat(newReturnType);\n    const newGenericArguments = types.filter(type => maybeGenericTypes.some(arg => arg.weakContains(type) && !arg.containsAsGeneric(type)));\n\n    if (this.argumentsTypes.every((arg, i) => arg === newArguments[i]) && this.returnType === newReturnType && newGenericArguments.length === 0) {\n      return this;\n    }\n\n    const fnName = FunctionType.getName(newArguments, newReturnType, newGenericArguments);\n    const newFnType = FunctionType.term(fnName, {}, newArguments, newReturnType);\n\n    if (newGenericArguments.length === 0) {\n      return newFnType;\n    }\n\n    return _genericType.GenericType.new(fnName, {\n      parent: typeScope\n    }, newGenericArguments, localTypeScope, newFnType);\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = this.argumentsTypes.concat([this.returnType]).map(a => a.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.FunctionType = FunctionType;\n\n_defineProperty(FunctionType, \"Function\", new _typeVar.TypeVar(\"Function\"));","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GenericType = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _bottomType = require(\"./bottom-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass GenericType extends _type.Type {\n  static get name() {\n    return \"GenericType\";\n  }\n\n  static new(name, meta = {}, ...args) {\n    const [, localTypeScope, subordinateType] = args;\n    const declaratedParent = meta.parent || _type.Type.GlobalTypeScope;\n    const subordinateParent = subordinateType.getNextParent(localTypeScope);\n    const parent = declaratedParent.priority > subordinateParent.priority ? declaratedParent : subordinateParent;\n    return super.new(name, { ...meta,\n      parent\n    }, ...args);\n  }\n\n  static term(name, meta = {}, ...args) {\n    const [, localTypeScope, subordinateType] = args;\n    const declaratedParent = meta.parent || _type.Type.GlobalTypeScope;\n    const subordinateParent = subordinateType.getNextParent(localTypeScope.priority);\n    const parent = declaratedParent.priority > subordinateParent.priority ? declaratedParent : subordinateParent;\n    return super.term(name, { ...meta,\n      parent\n    }, ...args);\n  }\n\n  static getNameWithoutApplying(name) {\n    const match = /^(\\$Immutable<)?([\\w_$]+)</gi.exec(String(name));\n    const matchedName = match !== null ? match[2] : name;\n    return matchedName || name;\n  }\n\n  static getName(name, parameters) {\n    if (parameters.length === 0) {\n      return String(name);\n    }\n\n    const isMultyLine = this.prettyMode && parameters.length >= 4;\n    const isSplitterPresented = isMultyLine || parameters.some(a => a instanceof _unionType.UnionType && a.variants.length >= 4);\n    return `${String(name)}<${isSplitterPresented ? \"\\n\\t\" : \"\"}${this.getParametersPart(parameters, isMultyLine)}${isSplitterPresented ? \"\\n\" : \"\"}>`;\n  }\n\n  static getParametersPart(parameters, isMultyLine = false) {\n    return parameters.reduce((res, t) => `${res}${res ? `,${isMultyLine ? \"\\n\\t\" : \" \"}` : \"\"}${String(t.name).replace(/\\n/g, \"\\n\\t\")}`, \"\");\n  }\n\n  constructor(name, meta = {}, genericArguments, typeScope, type) {\n    super(name, meta);\n\n    _defineProperty(this, \"genericArguments\", void 0);\n\n    _defineProperty(this, \"subordinateType\", void 0);\n\n    _defineProperty(this, \"localTypeScope\", void 0);\n\n    this.subordinateType = type;\n    this.localTypeScope = typeScope;\n    this.genericArguments = genericArguments;\n  }\n\n  isSuperTypeFor(anotherType) {\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const otherType = anotherType instanceof GenericType ? anotherType.subordinateType : anotherType;\n    const result = this.subordinateType.isSuperTypeFor(otherType);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  assertParameters(parameters, loc, ignoreLength = false) {\n    const requiredParams = this.genericArguments.filter(t => t.defaultType === undefined);\n\n    if (parameters.length < requiredParams.length) {\n      throw new _errors2.default(`Generic \"${String(this.name)}\" called with wrong number of arguments. Expect: ${requiredParams.length}, Actual: ${parameters.length}`, loc);\n    }\n\n    const genericArguments = this.genericArguments.map(a => a.constraint !== undefined ? new _typeVar.TypeVar(String(a.name), {\n      isSubtypeOf: a.isSubtypeOf,\n      parent: a.parent\n    }, // $FlowIssue\n    a.constraint.changeAll(this.genericArguments, parameters), a.defaultType, a.isUserDefined) : a);\n    const wrongArgumentIndex = genericArguments.findIndex((arg, i) => {\n      const parameter = parameters[i];\n      return parameter === undefined && arg.defaultType === undefined || (parameter instanceof _typeVar.TypeVar ? !arg.isPrincipalTypeFor(parameter) : arg.constraint !== undefined && !arg.constraint.isPrincipalTypeFor(parameter));\n    });\n\n    if (wrongArgumentIndex !== -1) {\n      const parameter = parameters[wrongArgumentIndex];\n      const typeVar = genericArguments[wrongArgumentIndex];\n      throw new _errors2.default(`Parameter \"${String(parameter.name)}\" is incompatible with restriction ${typeVar.constraint ? `\"${String(typeVar.constraint.name)}` : `of type \"${String(typeVar.name)}\"`}\"`, loc);\n    }\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    [sourceTypes, targetTypes] = sourceTypes.reduce(([newSourceTypes, newTargetTypes], sourceType, index) => this.genericArguments.find(a => sourceType.contains(a)) !== undefined ? [newSourceTypes, newTargetTypes] : [[...newSourceTypes, sourceType], [...newTargetTypes, targetTypes[index]]], [[], []]);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n\n    try {\n      const newSubordinateType = this.subordinateType.changeAll(sourceTypes, targetTypes, typeScope);\n\n      if (newSubordinateType === this.subordinateType) {\n        return this.endChanges(this);\n      }\n\n      const newGenericArguments = this.genericArguments.filter(arg => newSubordinateType.contains(arg));\n\n      if (newGenericArguments.length === 0) {\n        return this.endChanges(newSubordinateType);\n      }\n\n      const newName = \"argumentsTypes\" in newSubordinateType ? newSubordinateType.constructor.getName(newSubordinateType.argumentsTypes, newSubordinateType.returnType, newGenericArguments) : GenericType.getName(newSubordinateType.name, newGenericArguments);\n      const theMostCloseParent = targetTypes.reduce((parent, type) => newSubordinateType.contains(type) && (parent === undefined || parent.priority <= type.parent.priority) ? type.parent : parent, undefined);\n      return this.endChanges(GenericType.term(newName, {\n        parent: theMostCloseParent\n      }, newGenericArguments, this.localTypeScope, newSubordinateType));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  bottomizeWith(parameters, parent, loc) {\n    return new _bottomType.$BottomType({\n      parent\n    }, this, parameters, loc);\n  }\n\n  applyGeneric(appliedParameters, loc, shouldBeMemoize = true) {\n    this.assertParameters(appliedParameters, loc);\n    let isBottomPresented = false;\n    const parameters = this.genericArguments.map((t, i) => {\n      const appliedType = appliedParameters[i];\n\n      if (appliedType instanceof _bottomType.$BottomType) {\n        isBottomPresented = true;\n      }\n\n      if (appliedType === undefined) {\n        if (t.defaultType === undefined) {\n          throw new Error(\"Never!\");\n        }\n\n        return t.defaultType;\n      } // Needed for type inferencing\n\n\n      if (appliedType instanceof _typeVar.TypeVar && !appliedType.isUserDefined && t.isUserDefined && appliedType.constraint !== t.constraint) {\n        return t;\n      }\n\n      if (t.constraint instanceof _unionType.UnionType && appliedType instanceof _unionType.UnionType && appliedType.equalsTo(t.constraint)) {\n        return appliedType;\n      }\n\n      if (t.constraint instanceof _unionType.UnionType) {\n        const variant = t.constraint.variants.find(v => v.isPrincipalTypeFor(appliedType));\n\n        if (variant !== undefined) {\n          return variant;\n        }\n      }\n\n      return appliedType;\n    });\n    let appliedTypeName = this.getChangedName(this.genericArguments, parameters);\n\n    if (appliedTypeName === this.name) {\n      appliedTypeName = GenericType.getName(this.name, parameters);\n    }\n\n    const oldAppliedSelf = new _bottomType.$BottomType({\n      parent: this.subordinateType.parent\n    }, this, this.genericArguments);\n    const theMostPriorityParent = parameters.reduce((parent, type) => parent === undefined || parent.priority < type.parent.priority ? type.parent : parent, this.parent);\n\n    const appliedSelf = _typeVar.TypeVar.term(appliedTypeName, {\n      parent: theMostPriorityParent,\n      isSubtypeOf: _typeVar.TypeVar.Self\n    }, undefined, undefined, true);\n\n    if (!(appliedSelf instanceof _typeVar.TypeVar)) {\n      return appliedSelf;\n    }\n\n    if (isBottomPresented) {\n      return this.bottomizeWith(parameters, theMostPriorityParent, loc);\n    }\n\n    try {\n      const result = this.subordinateType.changeAll([...this.genericArguments, oldAppliedSelf], [...parameters, appliedSelf], theMostPriorityParent);\n      result.name = result.name === undefined ? appliedTypeName : result.name;\n      appliedSelf.root = result;\n      result.priority = this.subordinateType.priority + 1;\n      return result.save();\n    } catch (e) {\n      e.loc = loc;\n      throw e;\n    }\n  }\n\n  getPropertyType(propertyName) {\n    const result = this.subordinateType.getPropertyType(propertyName);\n\n    if (result === null && this.isSubtypeOf != null) {\n      return this.isSubtypeOf.getPropertyType(propertyName);\n    }\n\n    return result;\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    if (this.subordinateType === null) {\n      return type instanceof _typeVar.TypeVar ? [{\n        root: this,\n        variable: type\n      }] : [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (type instanceof GenericType) {\n      const result = this.subordinateType.getDifference(type.subordinateType, withReverseUnion) // $FlowIssue\n      .filter(a => !type.genericArguments.includes(a.variable));\n      this._alreadyProcessedWith = null;\n      return result;\n    }\n\n    if (type instanceof _typeVar.TypeVar) {\n      const result = super.getDifference(type, withReverseUnion);\n      this._alreadyProcessedWith = null;\n      return result;\n    }\n\n    const result = this.subordinateType.getDifference(type, withReverseUnion).filter(a => !this.genericArguments.includes(a.variable));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.subordinateType.contains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.subordinateType.weakContains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  makeNominal() {\n    this.subordinateType.makeNominal();\n  }\n\n  containsAsGeneric(type) {\n    return this.genericArguments.includes(type);\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null || this.subordinateType == null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const result = this.subordinateType.getNextParent(typeScope);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  canContain(type) {\n    return this.subordinateType !== null && this.subordinateType.canContain(type);\n  }\n\n  asUserDefined() {\n    this.genericArguments.forEach(t => {\n      t._isUserDefined = true;\n      t.root = undefined;\n    });\n    return this;\n  }\n\n  asNotUserDefined() {\n    this.genericArguments.forEach(t => t._isUserDefined = false);\n    return this;\n  }\n\n}\n\nexports.GenericType = GenericType;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Immutable = exports.$AppliedImmutable = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _collectionType = require(\"./collection-type\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass $AppliedImmutable extends _type.Type {\n  static get name() {\n    return \"$AppliedImmutable\";\n  }\n\n  static term(name, meta = {}, readonly, ...args) {\n    name = name || this.getName(readonly);\n    let parent = meta.parent;\n\n    if (parent === undefined || readonly.parent.priority > parent.priority) {\n      parent = readonly.parent;\n    }\n\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, readonly, ...args);\n  }\n\n  static getName(type) {\n    return `$Immutable<${String(type.name)}>`;\n  }\n\n  constructor(name, meta = {}, type) {\n    name = name || this.getName(type);\n\n    if (type instanceof _collectionType.CollectionType && _collectionType.CollectionType.Array.root !== undefined && type.equalsTo(_collectionType.CollectionType.Array.root.applyGeneric([type.valueType]))) {\n      type = _tupleType.TupleType.ReadonlyArray.root.applyGeneric([type.valueType]);\n    }\n\n    if (type.isSimpleType()) {\n      meta = { ...meta,\n        isSubtypeOf: type\n      };\n    }\n\n    super(name, meta);\n\n    _defineProperty(this, \"readonly\", void 0);\n\n    this.readonly = type;\n  }\n\n  equalsTo(type) {\n    if (type.referenceEqualsTo(this) || type instanceof _collectionType.CollectionType && type.equalsTo(_tupleType.TupleType.ReadonlyArray.root.applyGeneric([type.valueType]))) {\n      return true;\n    }\n\n    if (type instanceof $AppliedImmutable) {\n      return type instanceof $AppliedImmutable && this.readonly.equalsTo(type.readonly);\n    }\n\n    return this.readonly.isPrincipalTypeFor(type);\n  }\n\n  isSuperTypeFor(type) {\n    if (type.onlyLiteral || type instanceof $AppliedImmutable) {\n      return type instanceof $AppliedImmutable && this.readonly.isSuperTypeFor(type.readonly);\n    }\n\n    return this.readonly.isSuperTypeFor(type);\n  }\n\n  contains(type) {\n    return this.readonly.contains(type);\n  }\n\n  weakContains(type) {\n    return this.readonly.contains(type);\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    return this.readonly.getDifference(type, withReverseUnion);\n  }\n\n  changeAll(...args) {\n    const changed = this.readonly.changeAll(...args);\n\n    if (changed === this.readonly) {\n      return this;\n    }\n\n    return $AppliedImmutable.term(null, {}, changed);\n  }\n\n  getPropertyType(propertyName) {\n    const propertyType = this.readonly.getPropertyType(propertyName);\n\n    if (propertyType === null || propertyType instanceof $AppliedImmutable) {\n      return propertyType;\n    }\n\n    return $AppliedImmutable.term(null, {}, propertyType);\n  }\n\n}\n\nexports.$AppliedImmutable = $AppliedImmutable;\n\nclass $Immutable extends _genericType.GenericType {\n  static get name() {\n    return \"$Immutable\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Immutable\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo(type) {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    return $AppliedImmutable.term(null, {\n      parent: target.parent\n    }, target);\n  }\n\n}\n\nexports.$Immutable = $Immutable;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$InstanceOf = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _bottomType = require(\"./bottom-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $InstanceOf extends _genericType.GenericType {\n  static get name() {\n    return \"$InstanceOf\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$InstanceOf\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc) {\n    let [target, ...genericParameters] = parameters;\n    target = this.getOponentType(target);\n\n    if (target instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, target.parent, loc);\n    }\n\n    const oldGenericArguments = this.genericArguments;\n\n    if (!(target instanceof _objectType.ObjectType && target.instanceType !== null)) {\n      throw new _errors2.default(\"Cannot apply $InstanceOf to non-class type\", loc);\n    }\n\n    let instanceType = target.instanceType;\n\n    if (instanceType instanceof _bottomType.$BottomType) {\n      this.genericArguments = this.genericArguments.concat(instanceType.genericArguments);\n      instanceType = instanceType.subordinateMagicType.applyGeneric(genericParameters, loc);\n    }\n\n    try {\n      super.assertParameters(parameters, loc);\n      return instanceType;\n    } finally {\n      this.genericArguments = oldGenericArguments;\n    }\n  }\n\n}\n\nexports.$InstanceOf = $InstanceOf;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Intersection = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _bottomType = require(\"./bottom-type\");\n\nvar _immutableType = require(\"./immutable-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Intersection extends _genericType.GenericType {\n  static get name() {\n    return \"$Intersection\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Intersection\", meta, [], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(objects, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    if (objects.length < 2) {\n      throw new _errors2.default(\"$Intersection required at minimum 2 type parameters.\", loc);\n    }\n\n    let containsVariable = false;\n    let theMostPriorityParent = objects[0].parent;\n    const objectTypes = objects.map((obj, i) => {\n      const isVar = obj instanceof _typeVar.TypeVar;\n\n      if (isVar) {\n        containsVariable = true;\n        theMostPriorityParent = theMostPriorityParent.priority < obj.parent.priority ? obj.parent : theMostPriorityParent;\n\n        if (!obj.isUserDefined) {\n          obj.constraint = _objectType.ObjectType.Object;\n        }\n      }\n\n      return i !== 0 && \"readonly\" in obj ? obj.readonly : obj;\n    });\n\n    if (containsVariable) {\n      return this.bottomizeWith(objects, theMostPriorityParent, loc);\n    }\n\n    const wrongIndex = objectTypes.findIndex(a => !(a instanceof _objectType.ObjectType));\n\n    if (wrongIndex !== -1) {\n      throw new _errors2.default(`All parameters should be an object type. Only first parameter should mutable object type. ${wrongIndex} is not.`, loc);\n    }\n\n    const [firstObject, ...restObjects] = objectTypes;\n    const newProperties = [...firstObject.properties];\n\n    for (const obj of restObjects) {\n      for (const [key, variable] of obj.properties.entries()) {\n        const existed = firstObject.properties.get(key);\n\n        if (existed !== undefined && existed.type instanceof _immutableType.$AppliedImmutable) {\n          throw new _errors2.default(`Attempt to mutate immutable property \"${key}\" in \"${String(firstObject.name)}\" type`, loc);\n        }\n\n        newProperties.push([key, variable]);\n      }\n    }\n\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(newProperties), {}, newProperties);\n  }\n\n}\n\nexports.$Intersection = $Intersection;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Keys = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _collectionType = require(\"./collection-type\");\n\nvar _constants = require(\"../constants\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Keys extends _genericType.GenericType {\n  static get name() {\n    return \"$Keys\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Keys\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [currentTarget] = parameters;\n    const realTarget = this.getOponentType(currentTarget);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, currentTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType) && !(realTarget instanceof _tupleType.TupleType) && !(realTarget instanceof _collectionType.CollectionType)) {\n      throw new _errors2.default(\"First parameter should be an object or collection type\", loc);\n    }\n\n    if (realTarget instanceof _tupleType.TupleType) {\n      return realTarget.isSubtypeOf.keyType;\n    }\n\n    if (realTarget instanceof _collectionType.CollectionType) {\n      return realTarget.keyType;\n    }\n\n    const variants = [];\n\n    for (const property of realTarget.properties.keys()) {\n      if (property !== _constants.CALLABLE && property !== _constants.CONSTRUCTABLE && property !== _constants.INDEXABLE) {\n        variants.push(_type.Type.term(`'${property}'`, {\n          isSubtypeOf: _type.Type.String\n        }));\n      }\n    }\n\n    if (!realTarget.isStrict) {\n      variants.push(_type.Type.Unknown);\n    }\n\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n}\n\nexports.$Keys = $Keys;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObjectType = undefined;\n\nvar _type = require(\"./type\");\n\nvar _common = require(\"../../utils/common\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _functionType = require(\"./function-type\");\n\nvar _variableInfo = require(\"../variable-info\");\n\nvar _constants = require(\"../constants\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass ObjectType extends _type.Type {\n  static get name() {\n    return \"ObjectType\";\n  }\n\n  static term(name, meta = {}, properties, ...args) {\n    name = name == undefined ? // $FlowIssue\n    ObjectType.getName(properties, undefined, meta.isSoft) : name;\n    let parent = meta.parent || _type.Type.GlobalTypeScope;\n    const length = properties.length;\n\n    for (let i = 0; i < length; i++) {\n      const property = properties[i][1];\n\n      if (property instanceof _variableInfo.VariableInfo) {\n        const propertyType = property.type;\n\n        if (parent === undefined || parent.priority < propertyType.parent.priority) {\n          parent = propertyType.parent;\n        }\n      }\n    }\n\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, properties, ...args);\n  }\n\n  static getName(params, type, isSoft = false) {\n    if (type !== undefined && String(type.name)[0] !== \"{\") {\n      return undefined;\n    }\n\n    const filteredProperties = params ? (0, _common.unique)(params, ([key]) => key) : [];\n    const properties = filteredProperties.sort(([name1], [name2]) => String(name1).localeCompare(String(name2)));\n    return this.prettyMode && filteredProperties.length > 2 ? this.multyLine(properties, isSoft) : this.oneLine(properties, isSoft);\n  }\n\n  static oneLine(properties, isSoft) {\n    return `{ ${properties.map(([name, type]) => `${name}: ${String(_type.Type.getTypeRoot(type instanceof _variableInfo.VariableInfo ? type.type : type).name)}`).join(\", \")}${properties.length > 0 && isSoft ? \", \" : \"\"}${isSoft ? \"...\" : \"\"} }`;\n  }\n\n  static multyLine(properties, isSoft) {\n    return `{\\n${properties.map(([name, type]) => `\\t${name}: ${String(_type.Type.getTypeRoot(type instanceof _variableInfo.VariableInfo ? type.type : type).name).replace(/\\n/g, \"\\n\\t\")}`).join(\",\\n\")}${properties.length > 0 ? \"\\n\" : \"\"}${isSoft ? \"\\t...\\n\" : \"\"}}`;\n  }\n\n  constructor(name, options = {}, properties) {\n    name = name == undefined ? // $FlowIssue\n    ObjectType.getName(properties, undefined, options.isSoft) : name;\n    super(name, {\n      isSubtypeOf: name === \"Object\" ? undefined : ObjectType.Object,\n      ...options\n    });\n\n    _defineProperty(this, \"isNominal\", void 0);\n\n    _defineProperty(this, \"properties\", void 0);\n\n    _defineProperty(this, \"instanceType\", null);\n\n    _defineProperty(this, \"classType\", null);\n\n    _defineProperty(this, \"isStrict\", true);\n\n    _defineProperty(this, \"priority\", 2);\n\n    _defineProperty(this, \"onlyLiteral\", true);\n\n    this.isNominal = Boolean(options.isNominal);\n    const filteredProperties = properties ? (0, _common.unique)(properties, ([key]) => key) : [];\n    this.properties = new Map(filteredProperties);\n    this.onlyLiteral = true;\n    this.isStrict = !options.isSoft;\n  }\n\n  getPropertyType(property, _ = false, isForInit = false) {\n    const propertyName = String(property);\n    let fieldOwner = this;\n    let field = undefined;\n\n    while (fieldOwner) {\n      // $FlowIssue\n      field = fieldOwner.properties.get(propertyName);\n\n      if (field || !(fieldOwner.isSubtypeOf && fieldOwner.isSubtypeOf instanceof ObjectType)) {\n        break;\n      }\n\n      fieldOwner = fieldOwner.isSubtypeOf;\n    }\n\n    if (field === undefined) {\n      return null;\n    }\n\n    if (isForInit && fieldOwner === this && this.properties.has(propertyName) && !field.hasInitializer) {\n      field.hasInitializer = true;\n    }\n\n    if (!(field.type instanceof _type.Type)) {\n      return field;\n    }\n\n    if (field.isPrivate && !this.properties.has(propertyName)) {\n      return null;\n    }\n\n    return field.type;\n  }\n\n  isAllProperties(predicate, anotherType) {\n    for (const [key, {\n      type\n    }] of this.properties) {\n      if (typeof type !== \"object\" || [_constants.CALLABLE, _constants.INDEXABLE, _constants.CONSTRUCTABLE].includes(key)) {\n        continue;\n      }\n\n      const existedAnotherProperty = anotherType.properties.get(key); // $FlowIssue\n\n      const maybeUnion = \"readonly\" in type ? type.readonly : type;\n\n      if (!existedAnotherProperty && !(maybeUnion instanceof _unionType.UnionType && maybeUnion.variants.some(variant => variant !== _type.Type.Undefined))) {\n        return false;\n      }\n\n      const anotherProperty = existedAnotherProperty || {\n        type: _type.Type.Undefined\n      };\n      /* $FlowIssue - flow doesn't type methods by name */\n\n      if (!type[predicate](anotherProperty.type)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      const newName = this.getChangedName(sourceTypes, targetTypes);\n      const name = String(this.name);\n      return name[0] === \"{\" || newName === name ? this : // $FlowIssue\n      Object.assign(new ObjectType(\"\", {}, this.properties), this, {\n        name: newName\n      });\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n    let isAnyPropertyChanged = false;\n\n    try {\n      const newProperties = [];\n      this.properties.forEach((vInfo, key) => {\n        if (!(vInfo instanceof _variableInfo.VariableInfo)) {\n          return;\n        }\n\n        const newType = vInfo.type.changeAll(sourceTypes, targetTypes, typeScope);\n\n        if (vInfo.type === newType) {\n          return newProperties.push([key, vInfo]);\n        }\n\n        isAnyPropertyChanged = true;\n        newProperties.push([key, new _variableInfo.VariableInfo(newType, vInfo.parent, vInfo.meta)]);\n      });\n      const isSubtypeOf = this.isSubtypeOf === null || this.isSubtypeOf === ObjectType.Object ? this.isSubtypeOf : this.isSubtypeOf.changeAll(sourceTypes, targetTypes, typeScope);\n\n      if (!isAnyPropertyChanged && this.isSubtypeOf === isSubtypeOf) {\n        return this.endChanges(this);\n      }\n\n      const isSoft = !this.isStrict;\n      const result = ObjectType.term(ObjectType.getName(newProperties, this, isSoft) || this.getChangedName(sourceTypes, targetTypes), {\n        isSubtypeOf,\n        isSoft\n      }, newProperties);\n      return this.endChanges(result);\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  equalsTo(anotherType) {\n    anotherType = this.getOponentType(anotherType, true, false);\n\n    if (this.referenceEqualsTo(anotherType)) {\n      return true;\n    }\n\n    if (!(anotherType instanceof ObjectType) || this.isStrict && anotherType.properties.size !== this.properties.size || this.isNominal && !super.equalsTo(anotherType) || !this.canContain(anotherType)) {\n      return false;\n    }\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const result = this.isAllProperties(\"equalsTo\", anotherType);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  isInHierarchyOf(anotherType) {\n    do {\n      if (this === anotherType) {\n        return true;\n      } // $FlowIssue\n\n\n      anotherType = anotherType.isSubtypeOf;\n    } while (anotherType && anotherType.isSubtypeOf);\n\n    return false;\n  }\n\n  isSuperTypeFor(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (anotherType instanceof ObjectType && this === ObjectType.Object.root || this.isInHierarchyOf(anotherType)) {\n      return true;\n    }\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const requiredProperties = [...this.properties.values()].filter(({\n      type\n    }) => {\n      type = // $FlowIssue\n      typeof type === \"object\" && \"readonly\" in type ? type.readonly : type;\n      return !(type instanceof _unionType.UnionType) || !type.variants.some(t => t.equalsTo(_type.Type.Undefined));\n    });\n    const result = anotherType instanceof ObjectType && !this.isNominal ? anotherType.properties.size >= requiredProperties.length && (!this.isStrict || this.hasTheSameKeysAs(anotherType)) && this.isAllProperties(\"isPrincipalTypeFor\", anotherType) : anotherType.isSubtypeOf != undefined && this.isPrincipalTypeFor(anotherType.isSubtypeOf);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  hasTheSameKeysAs(anotherType) {\n    for (const [key] of anotherType.properties) {\n      if (!this.properties.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (type instanceof ObjectType) {\n      let differences = [];\n      const {\n        properties\n      } = type;\n      this.properties.forEach(({\n        type\n      }, key) => {\n        const other = properties.get(key);\n\n        if (other === undefined) {\n          return;\n        }\n\n        differences = differences.concat(type.getDifference(other.type, withReverseUnion));\n      });\n      this._alreadyProcessedWith = null;\n      return differences;\n    }\n\n    if (type instanceof _functionType.FunctionType) {\n      const callable = this.properties.get(_constants.CALLABLE);\n\n      if (callable !== undefined) {\n        const result = callable.type.getDifference(type, withReverseUnion);\n        this._alreadyProcessedWith = null;\n        return result;\n      }\n    }\n\n    const result = super.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    if (super.contains(type)) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = type;\n\n    for (const [_, property] of this.properties) {\n      if (property instanceof _variableInfo.VariableInfo && property.type.contains(type)) {\n        this._alreadyProcessedWith = null;\n        return true;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return false;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.equalsTo(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = [...this.properties].filter(([_, v]) => v instanceof _variableInfo.VariableInfo).map(([_, {\n      type\n    }]) => type.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.ObjectType = ObjectType;\n\n_defineProperty(ObjectType, \"Object\", new _typeVar.TypeVar(\"Object\"));","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Omit = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Omit extends _genericType.GenericType {\n  static get name() {\n    return \"$Omit\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Omit\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    }), _typeVar.TypeVar.term(\"properties\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target, properties] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType)) {\n      throw new _errors2.default(\"First parameter should be an object type\", loc);\n    }\n\n    const picks = properties instanceof _unionType.UnionType ? properties.variants : [properties];\n    const pickedProperties = picks.map(variant => {\n      if (variant.isSubtypeOf && variant.isSubtypeOf.equalsTo(_type.Type.String)) {\n        return variant.name;\n      }\n\n      throw new _errors2.default(\"The second parameter should be an string literals type\");\n    });\n    const oldProperties = [...realTarget.properties.entries()];\n    const newProperties = oldProperties.filter(([name]) => !pickedProperties.includes(`'${name}'`));\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(newProperties), {}, newProperties);\n  }\n\n}\n\nexports.$Omit = $Omit;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Partial = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _variableInfo = require(\"../variable-info\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Partial extends _genericType.GenericType {\n  static get name() {\n    return \"$Partial\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Partial\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType)) {\n      throw new _errors2.default(\"First parameter should be an object type\", loc);\n    }\n\n    const oldProperties = [...realTarget.properties.entries()];\n    const newProperties = oldProperties.map(([name, property]) => {\n      const variants = [_type.Type.Undefined, ...(property.type instanceof _unionType.UnionType ? property.type.variants : [property.type])];\n\n      const newType = _unionType.UnionType.term(null, {}, variants);\n\n      return [name, new _variableInfo.VariableInfo(newType, property.parent, property.meta)];\n    });\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(newProperties, undefined, !realTarget.isStrict), {\n      isSoft: !realTarget.isStrict\n    }, newProperties);\n  }\n\n}\n\nexports.$Partial = $Partial;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Pick = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Pick extends _genericType.GenericType {\n  static get name() {\n    return \"$Pick\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Pick\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    }), _typeVar.TypeVar.term(\"properties\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target, properties] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType)) {\n      throw new _errors2.default(\"First parameter should be an object type\", loc);\n    }\n\n    const picks = properties instanceof _unionType.UnionType ? properties.variants : [properties];\n    const pickedProperties = picks.map(variant => {\n      if (variant.isSubtypeOf && variant.isSubtypeOf.equalsTo(_type.Type.String)) {\n        return variant.name;\n      }\n\n      throw new _errors2.default(\"The second parameter should be an string literals type\");\n    });\n    const oldProperties = [...realTarget.properties.entries()];\n    const newProperties = oldProperties.filter(([name]) => pickedProperties.includes(`'${name}'`));\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(newProperties), {}, newProperties);\n  }\n\n}\n\nexports.$Pick = $Pick;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$PropertyType = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _keysType = require(\"./keys-type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _bottomType = require(\"./bottom-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _variableInfo = require(\"../variable-info\");\n\nvar _collectionType = require(\"./collection-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $PropertyType extends _genericType.GenericType {\n  static get name() {\n    return \"$PropertyType\";\n  }\n\n  constructor(_, meta = {}, isForInit = false) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$PropertyType\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    }), _typeVar.TypeVar.term(\"property\", {\n      parent\n    })], parent, null);\n    this.isForInit = isForInit;\n  }\n\n  findRealTarget(target, loc) {\n    if (target instanceof _unionType.UnionType) {\n      return target;\n    }\n\n    let obj = target;\n\n    while (obj !== null && !(obj instanceof _objectType.ObjectType)) {\n      obj = obj.isSubtypeOf;\n    }\n\n    return obj;\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false, initializing = false) {\n    super.assertParameters(parameters, loc);\n    const [currentTarget, property] = parameters;\n    const realTarget = this.getOponentType(currentTarget);\n    const realProperty = this.getOponentType(property);\n    const propertyName = realProperty.isSubtypeOf && realProperty.isSubtypeOf.name === \"string\" ? realProperty.name.slice(1, -1) : realProperty.name;\n    const isTargetVariable = realTarget instanceof _typeVar.TypeVar;\n    const isPropertyVariable = realProperty instanceof _typeVar.TypeVar;\n\n    if (isTargetVariable && !realTarget.isUserDefined) {\n      if (realTarget.constraint === undefined) {\n        if (isPropertyVariable) {\n          realTarget.constraint = _objectType.ObjectType.Object.root;\n        } else {\n          const props = [[propertyName, new _variableInfo.VariableInfo(_typeVar.TypeVar.term(`${realTarget.name}0`, {\n            parent: realTarget.parent\n          }))]];\n          realTarget.constraint = _objectType.ObjectType.term(null, {\n            isSoft: true\n          }, props);\n        }\n      } else if (realTarget.constraint instanceof _objectType.ObjectType && !isPropertyVariable && !realTarget.constraint.properties.has(propertyName)) {\n        const props = [...realTarget.constraint.properties, [propertyName, new _variableInfo.VariableInfo(_typeVar.TypeVar.term(`${realTarget.name}${realTarget.constraint.properties.size}`, {\n          parent: realTarget.parent\n        }))]];\n        realTarget.constraint = _objectType.ObjectType.term(null, {\n          isSoft: true\n        }, props);\n      }\n    }\n\n    if (isPropertyVariable && !realProperty.isUserDefined && realProperty.constraint === undefined) {\n      let constraint = undefined;\n\n      if (realTarget instanceof _collectionType.CollectionType) {\n        constraint = realTarget.keyType;\n      } else if (realTarget instanceof _tupleType.TupleType) {\n        constraint = Array.from({\n          length: realTarget.items.length\n        }).map((_, i) => _type.Type.term(i + 1, {\n          isSubtypeOf: _type.Type.Number\n        }));\n      } else if (realTarget instanceof _objectType.ObjectType) {\n        constraint = _unionType.UnionType.term(null, {}, [...realTarget.properties].map(([key]) => _type.Type.term(`'${key}'`, {\n          isSubtypeOf: _type.Type.String\n        })));\n      } else if (isTargetVariable) {\n        constraint = new _bottomType.$BottomType({}, new _keysType.$Keys(), [realTarget]);\n      }\n\n      realProperty.constraint = constraint;\n    }\n\n    if (isTargetVariable && !realTarget.isUserDefined && !isPropertyVariable) {\n      return realTarget.constraint.properties.get(propertyName).type;\n    }\n\n    if (isPropertyVariable) {\n      return this.bottomizeWith([realTarget, realProperty], realTarget.parent, loc);\n    }\n\n    if (realProperty instanceof _unionType.UnionType) {\n      try {\n        const variants = realProperty.variants.map(p => this.applyGeneric([realTarget, p], loc, shouldBeMemoize, isCalledAsBottom));\n        return _unionType.UnionType.term(null, {}, variants);\n      } catch {\n        throw new _errors2.default(`Property \"${propertyName}\" does not exist in \"${currentTarget.name}\"`, loc);\n      }\n    }\n\n    if (realTarget instanceof _unionType.UnionType) {\n      try {\n        const variants = realTarget.variants.map(v => this.applyGeneric([v, realProperty], loc, shouldBeMemoize, isCalledAsBottom));\n        return _unionType.UnionType.term(null, {}, variants);\n      } catch {\n        throw new _errors2.default(`Property \"${propertyName}\" does not exist in \"${currentTarget.name}\"`, loc);\n      }\n    }\n\n    const fieldType = realTarget.getPropertyType(propertyName, initializing, this.isForInit);\n\n    if (!realProperty.isSubtypeOf && !isCalledAsBottom) {\n      throw new _errors2.default(\"Second parameter should be an literal\", loc);\n    }\n\n    if (fieldType !== null) {\n      return fieldType;\n    }\n\n    throw new _errors2.default(`Property \"${propertyName}\" does not exist in \"${currentTarget.name}\"`, loc);\n  }\n\n}\n\nexports.$PropertyType = $PropertyType;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Refinemented = undefined;\n\nvar _type = require(\"./type\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass $Refinemented extends _type.Type {\n  static get name() {\n    return \"$Refinemented\";\n  }\n\n  constructor(refinemented, from) {\n    super(refinemented.name, {\n      parent: refinemented.parent\n    });\n\n    _defineProperty(this, \"refinemented\", void 0);\n\n    _defineProperty(this, \"from\", void 0);\n\n    this.refinemented = refinemented;\n    this.from = from;\n  }\n\n  equalsTo(type) {\n    if (type.referenceEqualsTo(this)) {\n      return true;\n    }\n\n    return type instanceof $Refinemented ? this.refinemented.equalsTo(type.refinemented) : this.refinemented.isPrincipalTypeFor(type);\n  }\n\n  isSuperTypeFor(type) {\n    if (type instanceof $Refinemented) {\n      return this.refinemented.isSuperTypeFor(type.refinemented);\n    }\n\n    return this.refinemented.isSuperTypeFor(type);\n  }\n\n  contains(type) {\n    return this.refinemented.contains(type);\n  }\n\n  weakContains(type) {\n    return this.refinemented.contains(type);\n  }\n\n  changeAll(...args) {\n    return this.refinemented.changeAll(...args);\n  }\n\n  getPropertyType(propertyName) {\n    return this.refinemented.getPropertyType(propertyName);\n  }\n\n}\n\nexports.$Refinemented = $Refinemented;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$ReturnType = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _functionType = require(\"./function-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $ReturnType extends _genericType.GenericType {\n  static get name() {\n    return \"$ReturnType\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$ReturnType\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    let [target, ...genericParameters] = parameters;\n    const oldGenericArguments = this.genericArguments;\n\n    if (target instanceof _genericType.GenericType) {\n      this.genericArguments = this.genericArguments.concat(target.genericArguments);\n      target = target.applyGeneric(genericParameters, loc);\n    }\n\n    try {\n      super.assertParameters(parameters, loc);\n      const realTarget = target.constraint || target;\n\n      if (!(realTarget instanceof _functionType.FunctionType)) {\n        throw new _errors2.default(\"First parameter should be an function type\", loc);\n      }\n\n      return realTarget.returnType;\n    } finally {\n      this.genericArguments = oldGenericArguments;\n    }\n  }\n\n}\n\nexports.$ReturnType = $ReturnType;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Soft = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Soft extends _genericType.GenericType {\n  static get name() {\n    return \"$Soft\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Soft\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType)) {\n      throw new _errors2.default(\"Parameter should be an object type\", loc);\n    }\n\n    const properties = [...realTarget.properties.entries()];\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(properties, undefined, true), {\n      isSoft: true\n    }, properties);\n  }\n\n}\n\nexports.$Soft = $Soft;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Strict = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Strict extends _genericType.GenericType {\n  static get name() {\n    return \"$Strict\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Strict\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType)) {\n      throw new _errors2.default(\"First parameter should be an object type\", loc);\n    }\n\n    const properties = [...realTarget.properties.entries()];\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(properties, undefined, false), {\n      isSoft: false\n    }, properties);\n  }\n\n}\n\nexports.$Strict = $Strict;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Throws = exports.$ThrowsResult = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _genericType = require(\"./generic-type\");\n\nclass $ThrowsResult extends _type.Type {\n  static get name() {\n    return \"$ThrowsResult\";\n  }\n\n  static term(name, meta = {}, errorType, ...args) {\n    name = name === null ? $ThrowsResult.getName(errorType) : name;\n    const scope = meta.parent || _type.Type.GlobalTypeScope;\n    const existed = scope.findTypeWithName(name);\n\n    if (this.shouldBeReplaced(existed, name, meta, errorType, ...args)) {\n      return this.new(name, meta, errorType, ...args);\n    }\n\n    return existed;\n  }\n\n  static getName(errorType) {\n    return `$Throws<${String(errorType.name)}>`;\n  }\n\n  constructor(name, meta = {}, errorType) {\n    name = name === null ? $ThrowsResult.getName(errorType) : name;\n    super(name, meta);\n    this.errorType = errorType;\n  }\n\n}\n\nexports.$ThrowsResult = $ThrowsResult;\n\nclass $Throws extends _genericType.GenericType {\n  static get name() {\n    return \"$Throws\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Throws\", meta, [_typeVar.TypeVar.term(\"errors\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [error] = parameters;\n    return $ThrowsResult.term(null, {\n      parent: error.parent\n    }, error);\n  }\n\n}\n\nexports.$Throws = $Throws;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TupleType = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _bottomType = require(\"./bottom-type\");\n\nvar _collectionType = require(\"./collection-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass TupleType extends _type.Type {\n  static get name() {\n    return \"TupleType\";\n  }\n\n  static term(name, meta = {}, items, ...args) {\n    let parent = meta.parent;\n    const length = items.length;\n\n    for (let i = 0; i < length; i++) {\n      const item = items[i];\n\n      if (item instanceof _type.Type && (parent === undefined || parent.priority < item.parent.priority)) {\n        // $FlowIssue\n        parent = item.parent;\n      }\n    }\n\n    name = name === null ? TupleType.getName(items) : name;\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, items, ...args);\n  }\n\n  static getName(params) {\n    if (params instanceof _type.Type) {\n      return String(params.name);\n    }\n\n    const isMultyLine = this.prettyMode && params.length >= 4;\n    return `[${isMultyLine ? \"\\n\\t\" : \"\"}${params.reduce((res, t) => `${res}${res ? `,${isMultyLine ? \"\\n\\t\" : \" \"}` : \"\"}${String(_type.Type.getTypeRoot(t).name).replace(/\\n/g, \"\\n\\t\")}`, \"\")}${isMultyLine ? \"\\n\" : \"\"}]`;\n  }\n\n  constructor(name, meta = {}, items) {\n    const arrayValue = [items.length !== 0 ? _unionType.UnionType.term(null, {}, items) : _type.Type.Unknown];\n    const isSubtypeOf = TupleType.ReadonlyArray.root === undefined ? new _bottomType.$BottomType({}, TupleType.ReadonlyArray, arrayValue) : // $FlowIssue ReadonlyArray is always GenericType\n    TupleType.ReadonlyArray.root.applyGeneric(arrayValue);\n    super(name, { ...meta,\n      isSubtypeOf\n    });\n\n    _defineProperty(this, \"items\", void 0);\n\n    _defineProperty(this, \"onlyLiteral\", true);\n\n    this.items = items;\n    this.priority = items.length * 10;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n\n    try {\n      let isItemsChanged = false;\n      const newItems = this.items.map(t => {\n        const newT = t.changeAll(sourceTypes, targetTypes, typeScope);\n\n        if (newT === t) {\n          return t;\n        }\n\n        isItemsChanged = true;\n        return newT;\n      });\n      const isSubtypeOf = this.isSubtypeOf && this.isSubtypeOf.changeAll(sourceTypes, targetTypes, typeScope);\n      return this.endChanges(!isItemsChanged && isSubtypeOf === this.isSubtypeOf ? this : TupleType.term(null, {\n        isSubtypeOf\n      }, newItems));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  isSuperTypeFor(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const result = anotherType instanceof TupleType && anotherType.items.length === this.items.length && //$FlowIssue - instanceof type refinement\n    this.items.every((t, i) => t.isPrincipalTypeFor(anotherType.items[i]));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  equalsTo(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this.referenceEqualsTo(anotherType)) {\n      return true;\n    }\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const anotherVariants = anotherType instanceof TupleType ? anotherType.items : [];\n    const result = anotherType instanceof TupleType && super.equalsTo(anotherType) && this.canContain(anotherType) && this.items.length === anotherVariants.length && this.items.every((type, index) => type.equalsTo(anotherVariants[index]));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getPropertyType(propertyIndex) {\n    if (typeof propertyIndex === \"number\") {\n      return propertyIndex < this.items.length ? this.items[propertyIndex] : null;\n    }\n\n    if (propertyIndex === \"length\") {\n      return _type.Type.term(this.items.length, {\n        isSubtypeOf: _type.Type.Number\n      });\n    }\n\n    if (this.isSubtypeOf instanceof _bottomType.$BottomType) {\n      const unpacked = this.isSubtypeOf.unpack();\n\n      if (TupleType.ReadonlyArray.root !== undefined) {\n        this.isSubtypeOf = unpacked;\n      }\n\n      return unpacked.getPropertyType(propertyIndex);\n    }\n\n    return super.getPropertyType(propertyIndex);\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (type instanceof TupleType && this.items.length === type.items.length) {\n      let differences = [];\n      const {\n        items\n      } = type;\n      this.items.forEach((type, index) => {\n        const other = items[index];\n\n        if (other === undefined) {\n          return;\n        }\n\n        differences = differences.concat(type.getDifference(other, withReverseUnion));\n      });\n      this._alreadyProcessedWith = null;\n      return differences;\n    }\n\n    if (type instanceof _collectionType.CollectionType) {\n      // $FlowIssue\n      const result = this.isSubtypeOf.getDifference(type, withReverseUnion);\n      this._alreadyProcessedWith = null;\n      return result;\n    }\n\n    const result = super.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.items.some(i => i.contains(type));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.items.some(i => i.weakContains(type));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = [...this.items].map(a => a.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.TupleType = TupleType;\n\n_defineProperty(TupleType, \"ReadonlyArray\", new _typeVar.TypeVar(\"ReadonlyArray\"));","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$TypeOf = undefined;\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _genericType = require(\"./generic-type\");\n\nclass $TypeOf extends _genericType.GenericType {\n  static get name() {\n    return \"$TypeOf\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$TypeOf\", {}, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null, meta);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    return target.type;\n  }\n\n}\n\nexports.$TypeOf = $TypeOf;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeVar = undefined;\n\nvar _type = require(\"./type\");\n\nvar _constants = require(\"../constants\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass TypeVar extends _type.Type {\n  static get name() {\n    return \"TypeVar\";\n  }\n\n  static isSelf(type) {\n    return type.isSubtypeOf === this.Self;\n  }\n\n  static createSelf(name, parent) {\n    // $FlowIssue\n    return new this(name, {\n      parent,\n      isSubtypeOf: TypeVar.Self\n    });\n  }\n\n  get isUserDefined() {\n    return this._isUserDefined;\n  }\n\n  set isUserDefined(isUserDefined) {\n    this._isUserDefined = this._isUserDefined || isUserDefined;\n  }\n\n  constructor(name, meta = {}, constraint, defaultType, isUserDefined = false) {\n    super(name, meta);\n\n    _defineProperty(this, \"constraint\", void 0);\n\n    _defineProperty(this, \"root\", void 0);\n\n    _defineProperty(this, \"defaultType\", void 0);\n\n    _defineProperty(this, \"_isUserDefined\", void 0);\n\n    _defineProperty(this, \"priority\", 0);\n\n    this.name = name;\n    this.constraint = constraint;\n    this.defaultType = defaultType;\n    this._isUserDefined = isUserDefined;\n  }\n\n  equalsTo(anotherType, strict = false, withoutRoot = false) {\n    const isDifferenceInDefinition = this.isUserDefined && anotherType instanceof TypeVar && !anotherType.isUserDefined && !strict;\n\n    if (isDifferenceInDefinition || this.referenceEqualsTo(anotherType)) {\n      return true;\n    }\n\n    if (this.root != undefined) {\n      // $FlowIssue\n      return this.root.equalsTo(anotherType, strict, withoutRoot);\n    }\n\n    if (anotherType instanceof TypeVar && anotherType.constraint !== undefined && this.constraint !== undefined) {\n      return super.equalsTo(anotherType) && this.constraint.equalsTo(anotherType.constraint) || this.constraint.equalsTo(anotherType);\n    }\n\n    return anotherType instanceof TypeVar && this.constraint === anotherType.constraint && super.equalsTo(anotherType);\n  }\n\n  isPrincipalTypeFor(type) {\n    if (type === this) {\n      return true;\n    }\n\n    if (this.root !== undefined) {\n      return this.root.isPrincipalTypeFor(type);\n    }\n\n    if (TypeVar.strictEquality && (!(type instanceof TypeVar) || this.parent.findTypeWithName(type.name) === type)) {\n      return false;\n    }\n\n    return super.isPrincipalTypeFor(type);\n  }\n\n  isSuperTypeFor(type) {\n    if (this.root !== undefined) {\n      return this.root.isSuperTypeFor(type);\n    }\n\n    if (this.constraint === undefined) {\n      return true;\n    }\n\n    if (type instanceof TypeVar) {\n      return type.constraint !== undefined ? this.constraint.isPrincipalTypeFor(type.constraint) : !type._isUserDefined;\n    }\n\n    return this.constraint.isPrincipalTypeFor(type);\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    const indexOfNewRootType = sourceTypes.findIndex( // $FlowIssue\n    a => a.equalsTo(this, true, true));\n\n    if (indexOfNewRootType !== -1) {\n      return targetTypes[indexOfNewRootType];\n    }\n\n    if (this.root !== undefined) {\n      return this.root.changeAll(sourceTypes, targetTypes, typeScope);\n    }\n\n    let defaultType = this.defaultType;\n    let constraint = this.constraint;\n\n    if (defaultType !== undefined) {\n      defaultType = defaultType.changeAll(sourceTypes, targetTypes, typeScope);\n    }\n\n    if (constraint !== undefined) {\n      constraint = constraint.changeAll(sourceTypes, targetTypes, typeScope);\n    }\n\n    if (this.constraint !== constraint || this.defaultType !== defaultType) {\n      return new TypeVar(String(this.name), {\n        parent: this.parent\n      }, constraint, defaultType, this.isUserDefined);\n    }\n\n    return this;\n  }\n\n  applyGeneric() {\n    return this;\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n    let result = [];\n\n    if (this.root !== undefined) {\n      result = this.root.getDifference(type, withReverseUnion);\n    } else if (type instanceof TypeVar && this !== type) {\n      result = [{\n        root: this,\n        variable: type\n      }];\n    } else if (\"variants\" in type) {\n      result = super.getDifference(type, withReverseUnion);\n    }\n\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    return this.constraint != undefined && this.constraint.contains(type) || this.equalsTo(type, true, true);\n  }\n\n  getPropertyType(propertyName) {\n    const target = this.root || this.constraint;\n\n    if (target !== undefined) {\n      return target.getPropertyType(propertyName);\n    }\n\n    return super.getPropertyType(propertyName);\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n\n    if (this.root !== undefined || this.constraint !== undefined) {\n      const target = this.root || this.constraint; // $FlowIssue\n\n      const result = target.getNextParent(typeScope);\n      this._alreadyProcessedWith = null;\n      return result;\n    }\n\n    this._alreadyProcessedWith = null;\n\n    if (this.parent.priority <= typeScope.priority && this.parent !== typeScope) {\n      return this.parent;\n    }\n\n    return _type.Type.GlobalTypeScope;\n  }\n\n  applyGeneric(...args) {\n    return this.root !== undefined && typeof \"applyGeneric\" in this.root ? // $FlowIssue GenericType by duck typing, can't import GenericType because of cycled dependecy\n    this.root.applyGeneric(...args) : this;\n  }\n\n}\n\nexports.TypeVar = TypeVar;\n\n_defineProperty(TypeVar, \"Self\", new TypeVar(_constants.THIS_TYPE));\n\n_defineProperty(TypeVar, \"strictEquality\", false);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Type = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _constants = require(\"../constants\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass Type {\n  static get name() {\n    return \"Type\";\n  }\n\n  static find(name, meta = {}, ...args) {\n    const scope = meta.parent || Type.GlobalTypeScope; // $FlowIssue\n\n    const existed = scope.findTypeWithName(name, ...args);\n\n    if (existed === undefined) {\n      throw new _errors2.default(`Type \"${String(name)}\" does not exist`, meta.loc);\n    }\n\n    return existed;\n  }\n\n  static new(name, meta = {}, ...args) {\n    let scope = meta.parent || Type.GlobalTypeScope;\n    const suptypeParent = meta.isSubtypeOf && meta.isSubtypeOf.parent;\n\n    if (suptypeParent && // $FlowIssue\n    meta.isSubtypeOf.name !== _constants.THIS_TYPE && suptypeParent.priority > scope.priority) {\n      scope = suptypeParent;\n    }\n\n    const newType = new this(name, { ...meta,\n      parent: scope\n    }, ...args);\n    scope.body.set(name, newType);\n    return newType;\n  }\n\n  static term(name, meta = {}, ...args) {\n    const scope = meta.parent || Type.GlobalTypeScope;\n    const existed = scope.findTypeWithName(name);\n\n    if (this.shouldBeReplaced(existed, name, meta, ...args)) {\n      return this.new(name, meta, ...args);\n    }\n\n    return existed;\n  }\n\n  static shouldBeReplaced(type, name, meta, ...args) {\n    return type === undefined || !(type instanceof this || this.name === \"TypeVar\");\n  }\n\n  static getTypeRoot(type, stepBeforeNonVariableRoot = false) {\n    let potentialRoot = type;\n\n    while (\"root\" in potentialRoot && // $FlowIssue\n    potentialRoot.root != undefined && ( // $FlowIssue\n    !stepBeforeNonVariableRoot || \"root\" in potentialRoot.root)) {\n      // $FlowIssue\n      potentialRoot = potentialRoot.root;\n    }\n\n    return potentialRoot;\n  }\n\n  constructor(name, meta = {}) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"shouldBeUsedAsGeneric\", void 0);\n\n    _defineProperty(this, \"isSubtypeOf\", void 0);\n\n    _defineProperty(this, \"_alreadyProcessedWith\", null);\n\n    _defineProperty(this, \"_processingType\", null);\n\n    _defineProperty(this, \"_changeStack\", null);\n\n    _defineProperty(this, \"onlyLiteral\", false);\n\n    _defineProperty(this, \"priority\", 1);\n\n    const {\n      parent = Type.GlobalTypeScope,\n      isSubtypeOf = null,\n      shouldBeUsedAsGeneric = false\n    } = meta;\n    this.name = name;\n    this.isSubtypeOf = isSubtypeOf;\n    this.parent = parent;\n    this.shouldBeUsedAsGeneric = shouldBeUsedAsGeneric;\n  }\n\n  getChangedName(sourceTypes, targetTypes) {\n    let pattern = \"\";\n    const map = sourceTypes.reduce((map, type, index) => {\n      const name = String(type.name).replace(/[()]/g, bracket => `\\\\${bracket}`);\n      map.set(name, String(targetTypes[index].name));\n      pattern += (pattern && \"|\") + name.replace(/\\|/g, \"\\\\|\");\n      return map;\n    }, new Map());\n    const template = new RegExp(`\\\\b(${pattern})\\\\b`, \"gm\");\n    return String(this.name).replace(template, typeName => map.get(typeName) || \"\");\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    const indexOfNewType = sourceTypes.indexOf(this);\n    return indexOfNewType === -1 ? this : targetTypes[indexOfNewType];\n  }\n\n  save() {\n    const existed = this.parent.body.get(this.name);\n\n    if (existed === undefined || !(existed instanceof this.constructor)) {\n      this.parent.body.set(this.name, this);\n    }\n\n    return this;\n  }\n\n  referenceEqualsTo(anotherType) {\n    return this === anotherType;\n  }\n\n  equalsTo(anotherType) {\n    return this.referenceEqualsTo(anotherType) || this.name === anotherType.name;\n  }\n\n  isSuperTypeFor(type) {\n    if (this._alreadyProcessedWith === type) {\n      return true;\n    }\n\n    if (type.isSubtypeOf === null || !this.canContain(type.isSubtypeOf)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = this.isPrincipalTypeFor(type.isSubtypeOf);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getPropertyType(propertyName) {\n    if (this.isSubtypeOf != null) {\n      return this.isSubtypeOf.getPropertyType(propertyName);\n    }\n\n    return null;\n  }\n\n  isPrincipalTypeFor(type) {\n    if (\"variants\" in type) {\n      // $FlowIssue\n      return type.variants.every(variant => this.isPrincipalTypeFor(variant));\n    }\n\n    if (this._processingType === type) {\n      return false;\n    }\n\n    this._processingType = type;\n    const isPrincipal = this.equalsTo(Type.Unknown) || this.equalsTo(type) || this.isSuperTypeFor(type);\n    this._processingType = null;\n\n    if (isPrincipal || type.constructor !== Type) {\n      return isPrincipal;\n    }\n\n    const typeWrapper = type.getWrapperType();\n    return typeWrapper !== undefined && typeWrapper !== this && this.isSuperTypeFor(typeWrapper);\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    if (\"readonly\" in type) {\n      // $FlowIssue\n      type = type.readonly;\n    }\n\n    if (\"variants\" in type) {\n      // $FlowIssue\n      const variants = [...type.variants].sort((t1, t2) => t2.priority - t1.priority);\n\n      for (const variant of variants) {\n        const diff = this.getDifference(variant, withReverseUnion);\n\n        if (diff.length !== 0 || variant.isPrincipalTypeFor(this)) {\n          return diff;\n        }\n      }\n    }\n\n    if (\"constraint\" in type && type.isSubtypeOf === null) {\n      const constraint = // $FlowIssue\n      type.constraint instanceof Type ? type.constraint : undefined;\n\n      if (constraint !== undefined && !(\"subordinateMagicType\" in constraint) && constraint.isPrincipalTypeFor(this)) {\n        return [{\n          root: this,\n          variable: type\n        }, ...this.getDifference(constraint)];\n      }\n\n      return [{\n        root: this,\n        variable: type\n      }];\n    }\n\n    if (\"subordinateMagicType\" in type) {\n      // $FlowIssue\n      const unpacked = type.unpack();\n\n      if (!(\"subordinateMagicType\" in unpacked)) {\n        return this.getDifference(unpacked, withReverseUnion);\n      }\n    }\n\n    const wrapper = this.isSubtypeOf || this.getWrapperType();\n\n    if (type.constructor !== this.constructor && type.parent !== undefined && type.parent.priority > 1 && wrapper !== undefined) {\n      return wrapper.getDifference(type).map(d => d.root === wrapper && d.variable === type ? {\n        variable: type,\n        root: this\n      } : d);\n    }\n\n    return [];\n  }\n\n  contains(type) {\n    return this === type;\n  }\n\n  weakContains(type) {\n    return this.contains(type);\n  }\n\n  getOponentType(type, withUnpack = true, withReadonly = true) {\n    if (\"root\" in type) {\n      type = Type.getTypeRoot(type);\n    }\n\n    if (withReadonly && \"readonly\" in type) {\n      // $FlowIssue\n      type = type.readonly;\n    }\n\n    if (\"unpack\" in type) {\n      // $FlowIssue\n      type = withUnpack ? type.unpack() : type.subordinateMagicType;\n    }\n\n    if (\"root\" in type) {\n      type = Type.getTypeRoot(type);\n    } // $FlowIssue\n\n\n    if (\"subordinateType\" in type && type.subordinateType !== null) {\n      // $FlowIssue\n      type = type.subordinateType;\n    }\n\n    if (\"root\" in type) {\n      type = Type.getTypeRoot(type);\n    }\n\n    if (withReadonly && \"readonly\" in type) {\n      // $FlowIssue\n      type = type.readonly;\n    }\n\n    return type;\n  }\n\n  makeNominal() {}\n\n  setInitialized(propertyName) {}\n\n  generalize(types, typeScope) {\n    return this;\n  }\n\n  containsAsGeneric(type) {\n    return false;\n  }\n\n  promisify() {\n    const Promise = Type.find(\"Promise\");\n    return Promise.applyGeneric([this]);\n  }\n\n  isPromise() {\n    const name = String(this.name);\n    return /^Promise/.test(name);\n  }\n\n  canContain(type) {\n    return this.parent.priority >= type.parent.priority;\n  }\n\n  endChanges(result) {\n    if (this._changeStack === null) {\n      return result;\n    }\n\n    const last = this._changeStack.pop();\n\n    if (last === undefined) {\n      this._changeStack = null;\n      return result;\n    } // $FlowIssue\n\n\n    last.root = result;\n    last.name = result.name;\n\n    if (this._changeStack !== null && this._changeStack.length === 0) {\n      this._changeStack = null;\n    }\n\n    return result;\n  }\n\n  getNextParent(typeScope) {\n    return Type.GlobalTypeScope;\n  }\n\n  findPrincipal(type) {\n    let principal = {\n      isSubtypeOf: this\n    };\n    let isPrincipalFound = false;\n\n    while ((principal.isSubtypeOf != undefined || principal === Type.True || principal === Type.False) && !isPrincipalFound) {\n      // $FlowIssue We mutate static field Boolean in src/type-graph/types/union-type.js so Boolean should exists in Type\n      principal = principal.isSubtypeOf || Type.Boolean;\n      isPrincipalFound = principal.isPrincipalTypeFor(type);\n    }\n\n    return isPrincipalFound ? principal : undefined;\n  }\n\n  asUserDefined() {\n    return this;\n  }\n\n  asNotUserDefined() {\n    return this;\n  }\n\n  getWrapperType() {\n    if (Type.GlobalTypeScope === undefined) {\n      return;\n    }\n\n    if (this === Type.String || this.isSubtypeOf === Type.String) {\n      return Type.GlobalTypeScope.body.get(\"String\");\n    }\n\n    if (this === Type.Number || this.isSubtypeOf === Type.Number) {\n      return Type.GlobalTypeScope.body.get(\"Number\");\n    } // $FlowIssue We mutate static field Boolean in src/type-graph/types/union-type.js so Boolean should exists in Type\n\n\n    if (this === Type.Boolean || this === Type.True || this === Type.False) {\n      return Type.GlobalTypeScope.body.get(\"Boolean\");\n    }\n\n    if (this === Type.Symbol || this.isSubtypeOf === Type.Symbol) {\n      return Type.GlobalTypeScope.body.get(\"Symbol\");\n    }\n\n    if (this === Type.BigInt || this.isSubtypeOf === Type.BigInt) {\n      return Type.GlobalTypeScope.body.get(\"BigInt\");\n    }\n  }\n\n  isSimpleType() {\n    return this === Type.String || this.isSubtypeOf === Type.String || this === Type.Number || this.isSubtypeOf === Type.Number || this === Type.BigInt || this.isSubtypeOf === Type.BigInt || // $FlowIssue We mutate static field Boolean in src/type-graph/types/union-type.js so Boolean should exists in Type\n    this === Type.Boolean || this === Type.True || this === Type.False || this === Type.Symbol || this.isSubtypeOf === Type.Symbol || this === Type.Null || this === Type.Undefined;\n  }\n\n}\n\nexports.Type = Type;\n\n_defineProperty(Type, \"GlobalTypeScope\", void 0);\n\n_defineProperty(Type, \"Undefined\", new Type(\"undefined\"));\n\n_defineProperty(Type, \"Null\", new Type(null));\n\n_defineProperty(Type, \"String\", new Type(\"string\"));\n\n_defineProperty(Type, \"Symbol\", new Type(\"symbol\"));\n\n_defineProperty(Type, \"True\", new Type(true));\n\n_defineProperty(Type, \"False\", new Type(false));\n\n_defineProperty(Type, \"Number\", new Type(\"number\"));\n\n_defineProperty(Type, \"BigInt\", new Type(\"bigint\"));\n\n_defineProperty(Type, \"Unknown\", new Type(\"unknown\"));\n\n_defineProperty(Type, \"Never\", new Type(\"never\"));\n\n_defineProperty(Type, \"prettyMode\", false);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnionType = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// $FlowIssue\nclass UnionType extends _type.Type {\n  static get name() {\n    return \"UnionType\";\n  }\n\n  static term(name, meta = {}, variants, ...args) {\n    variants = UnionType.flatten(variants);\n    variants = UnionType.rollup(variants);\n\n    if (variants.length === 1) {\n      return variants[0];\n    }\n\n    name = name == null ? UnionType.getName(variants) : name;\n    let parent = meta.parent;\n    const length = variants.length;\n\n    for (let i = 0; i < length; i++) {\n      const variant = variants[i];\n\n      if (variant instanceof _type.Type && (parent === undefined || parent.priority < variant.parent.priority)) {\n        parent = variant.parent;\n      }\n    }\n\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, variants, ...args);\n  }\n\n  static getName(params) {\n    const isMultyLine = this.prettyMode && params.length >= 4;\n    const isBooleanExist = params.some(p => p === _type.Type.True) && params.some(p => p === _type.Type.False);\n\n    if (isBooleanExist) {\n      params = params.filter(p => p !== _type.Type.True && p !== _type.Type.False).concat(UnionType.Boolean);\n    }\n\n    return `${params.sort((t1, t2) => String(t1.name).localeCompare(String(t2.name))).reduce((res, t) => {\n      const isFunction = \"argumentsTypes\" in t || // $FlowIssue\n      \"subordinateType\" in t && \"argumentsTypes\" in t.subordinateType;\n      let typeName = String(t.name);\n\n      if (isFunction) {\n        typeName = `(${typeName})`;\n      }\n\n      return isMultyLine ? this.multyLine(res, typeName) : this.oneLine(res, typeName);\n    }, \"\")}`;\n  }\n\n  static oneLine(res, typeName) {\n    return `${res}${res ? \" | \" : \"\"}${typeName}`;\n  }\n\n  static multyLine(res, typeName) {\n    return `${res}${res ? \"\\n| \" : \"  \"}${typeName}`;\n  }\n\n  static flatten(variants) {\n    // $FlowIssue\n    return variants.flatMap(variant => variant instanceof UnionType ? this.flatten(variant.variants) : [_type.Type.getTypeRoot(variant)]);\n  }\n\n  static shouldBeSkipped(variant) {\n    return \"subordinateMagicType\" in variant || variant instanceof _typeVar.TypeVar || variant === _type.Type.Unknown;\n  }\n\n  static uniqueVariants(set) {\n    let unique = [];\n\n    for (let i = 0; i < set.length; i++) {\n      const currentType = set[i];\n\n      if (unique.includes(currentType)) {\n        continue;\n      }\n\n      if (this.shouldBeSkipped(currentType)) {\n        unique.push(currentType);\n        continue;\n      }\n\n      if (!unique.some(existed => !this.shouldBeSkipped(existed) && existed.isPrincipalTypeFor(currentType))) {\n        unique = [...unique.filter(t => this.shouldBeSkipped(t) || !currentType.isPrincipalTypeFor(t)), currentType];\n      }\n    }\n\n    return unique;\n  }\n\n  static rollup(variants) {\n    return variants.length === 1 ? [variants[0]] : this.uniqueVariants(variants);\n  }\n\n  constructor(name, meta = {}, variants) {\n    variants = UnionType.flatten(variants);\n    variants = UnionType.rollup(variants);\n\n    if (variants.length === 1) {\n      return variants[0];\n    }\n\n    name = name == null ? UnionType.getName(variants) : name;\n    super(name, meta);\n\n    _defineProperty(this, \"variants\", void 0);\n\n    this.variants = variants.sort((t1, t2) => String(t1.name).localeCompare(String(t2.name)));\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n\n    try {\n      let isVariantsChanged = false;\n      const newVariants = this.variants.map(t => {\n        const newT = t.changeAll(sourceTypes, targetTypes, typeScope);\n\n        if (newT === t) {\n          return t;\n        }\n\n        isVariantsChanged = true;\n        return newT;\n      });\n      return this.endChanges(!isVariantsChanged ? this : UnionType.term(null, {}, newVariants));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  equalsTo(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this.referenceEqualsTo(anotherType) || this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const anotherVariants = anotherType instanceof UnionType ? anotherType.variants : [];\n    const result = anotherType instanceof UnionType && super.equalsTo(anotherType) && this.canContain(anotherType) && this.variants.length === anotherVariants.length && this.variants.every((type, index) => type.equalsTo(anotherVariants[index]));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  isSuperTypeFor(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n\n    if (anotherType instanceof UnionType) {\n      for (const variantType of anotherType.variants) {\n        if (!this.variants.some(type => type.isPrincipalTypeFor(variantType))) {\n          this._alreadyProcessedWith = null;\n          return false;\n        }\n      }\n\n      this._alreadyProcessedWith = null;\n      return true;\n    }\n\n    const result = this.variants.some(type => type.isPrincipalTypeFor(anotherType));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getPropertyType(propertyName) {\n    return null;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.variants.some(v => v.contains(type));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (type instanceof UnionType || withReverseUnion) {\n      // $FlowIssue\n      const diff = this.variants.flatMap(variant => variant.getDifference(type, withReverseUnion));\n      const reducer = new Map();\n\n      for (const {\n        root,\n        variable\n      } of diff) {\n        const existed = reducer.get(variable) || [];\n        existed.push(root);\n        reducer.set(variable, existed);\n      }\n\n      const aggregatedDiff = [];\n\n      for (const [variable, variants] of reducer) {\n        aggregatedDiff.push({\n          variable,\n          root: variants.length === 1 ? variants[0] : UnionType.term(null, {}, variants)\n        });\n      }\n\n      this._alreadyProcessedWith = null;\n      return aggregatedDiff;\n    }\n\n    const result = super.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.variants.some(v => v.weakContains(type));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  generalize(types, typeScope) {\n    const variants = this.variants.map(v => v.generalize(types, typeScope));\n\n    if (this.variants.every((v, i) => v === variants[i])) {\n      return this;\n    }\n\n    return UnionType.term(null, {}, variants);\n  }\n\n  containsAsGeneric(type) {\n    return this.variants.some(v => v.containsAsGeneric(type));\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = [...this.variants].map(a => a.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.UnionType = UnionType; // $FlowIssue We need it to have access to Boolean type inside src/type-graph/types/type.js otherwise - circular dependency\n\n_defineProperty(UnionType, \"Boolean\", new UnionType(\"boolean\", {}, [_type.Type.True, _type.Type.False]));\n\n_type.Type.Boolean = UnionType.Boolean;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Values = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _collectionType = require(\"./collection-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Values extends _genericType.GenericType {\n  static get name() {\n    return \"$Values\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Values\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc) {\n    super.assertParameters(parameters, loc);\n    const [currentTarget] = parameters;\n    const realTarget = this.getOponentType(currentTarget);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType) && !(realTarget instanceof _tupleType.TupleType) && !(realTarget instanceof _collectionType.CollectionType)) {\n      throw new _errors2.default(\"First parameter should be an object or collection type\", loc);\n    }\n\n    if (realTarget instanceof _tupleType.TupleType) {\n      return realTarget.isSubtypeOf.valueType;\n    }\n\n    if (realTarget instanceof _collectionType.CollectionType) {\n      return realTarget.valueType;\n    }\n\n    const values = [...realTarget.properties.values()];\n    const variants = values.map(value => value.type);\n\n    if (!realTarget.isStrict) {\n      variants.push(_type.Type.Unknown);\n    }\n\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n}\n\nexports.$Values = $Values;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableInfo = undefined;\n\nvar _meta = require(\"./meta/meta\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass VariableInfo {\n  constructor(type, parent, meta = new _meta.Meta(), isConstant = false, isInferenced = false, isPrivate = false) {\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"isConstant\", false);\n\n    _defineProperty(this, \"hasInitializer\", false);\n\n    _defineProperty(this, \"isInferenced\", false);\n\n    _defineProperty(this, \"isPrivate\", false);\n\n    _defineProperty(this, \"meta\", void 0);\n\n    this.type = type;\n    this.parent = parent;\n    this.meta = meta;\n    this.isConstant = isConstant;\n    this.isInferenced = isInferenced;\n    this.isPrivate = isPrivate;\n  }\n\n}\n\nexports.VariableInfo = VariableInfo;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableScope = undefined;\n\nvar _scope = require(\"./scope\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// $FlowIssue\nclass VariableScope extends _scope.Scope {\n  constructor(type, parent, declaration, creator, skipCalls = false) {\n    super(parent);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"calls\", []);\n\n    _defineProperty(this, \"throwable\", void 0);\n\n    _defineProperty(this, \"declaration\", void 0);\n\n    _defineProperty(this, \"skipCalls\", void 0);\n\n    _defineProperty(this, \"isProcessed\", false);\n\n    _defineProperty(this, \"body\", void 0);\n\n    _defineProperty(this, \"creator\", void 0);\n\n    this.parent = parent;\n    this.type = type;\n    this.declaration = declaration;\n    this.skipCalls = skipCalls;\n    this.creator = creator;\n    this.body = new Map();\n  }\n\n}\n\nexports.VariableScope = VariableScope;\n\n_defineProperty(VariableScope, \"BLOCK_TYPE\", \"block\");\n\n_defineProperty(VariableScope, \"FUNCTION_TYPE\", \"function\");\n\n_defineProperty(VariableScope, \"OBJECT_TYPE\", \"object\");\n\n_defineProperty(VariableScope, \"CLASS_TYPE\", \"class\");","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addThisToClassScope = addThisToClassScope;\nexports.addClassScopeToTypeGraph = addClassScopeToTypeGraph;\nexports.addPropertyNodeToThis = addPropertyNodeToThis;\nexports.addObjectToTypeGraph = addObjectToTypeGraph;\nexports.addClassToTypeGraph = addClassToTypeGraph;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"./errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _callMeta = require(\"../type-graph/meta/call-meta\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _bottomType = require(\"../type-graph/types/bottom-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _variableUtils = require(\"./variable-utils\");\n\nvar _call = require(\"../type-graph/call\");\n\nvar _functionUtils = require(\"./function-utils\");\n\nvar _typeUtils = require(\"./type-utils\");\n\nvar _constants = require(\"../type-graph/constants\");\n\nvar _common = require(\"./common\");\n\nvar _scopeUtils = require(\"../utils/scope-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addThisToClassScope(currentNode, parentNode, typeScope, typeGraph, precompute, middlecompute, postcompute) {\n  parentNode = currentNode.parentNode;\n  currentNode = currentNode.definition;\n  const classScope = typeGraph.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n  if (classScope === undefined) {\n    throw new Error(\"Never!!!\");\n  }\n\n  if (classScope.declaration !== undefined) {\n    return;\n  }\n\n  const parentTypeScope = (0, _scopeUtils.findNearestTypeScope)(classScope, typeGraph);\n  const localTypeScope = new _typeScope.TypeScope(parentTypeScope);\n  const genericArguments = currentNode.typeParameters && currentNode.typeParameters.params.map(typeAnnotation => (0, _typeUtils.getTypeFromTypeAnnotation)({\n    typeAnnotation\n  }, localTypeScope, classScope.parent, true, null, parentNode, typeGraph, precompute, middlecompute, postcompute));\n  const name = currentNode.id != undefined ? (0, _common.getDeclarationName)(currentNode) : \"{ }\";\n  const isGenericType = genericArguments != undefined;\n  const typeName = isGenericType ? _genericType.GenericType.getName(name, genericArguments) : name;\n\n  const selfObject = _objectType.ObjectType.term(typeName, {\n    parent: isGenericType ? localTypeScope : typeScope,\n    isNominal: currentNode.type === _nodes2.default.CLASS_EXPRESSION || currentNode.type === _nodes2.default.CLASS_DECLARATION\n  }, []);\n\n  const self = currentNode.typeParameters === undefined ? selfObject : new _bottomType.$BottomType({}, _genericType.GenericType.new(typeName, {\n    parent: typeScope\n  }, genericArguments, localTypeScope, selfObject), genericArguments);\n  let superClass;\n\n  if (currentNode.superClass != null) {\n    superClass = (0, _call.addCallToTypeGraph)(currentNode.superClass, typeGraph, classScope.parent, parentNode, precompute, middlecompute, postcompute).result;\n    superClass = superClass instanceof _variableInfo.VariableInfo ? superClass.type : superClass;\n\n    if (!(superClass instanceof _objectType.ObjectType && superClass.instanceType !== null)) {\n      throw new _errors2.default(\"Cannot extend class from non-class type\", currentNode.superClass.loc);\n    }\n\n    const superType = superClass.instanceType;\n\n    if (superType instanceof _genericType.GenericType && currentNode.superTypeParameters == null) {\n      throw new _errors2.default(`Generic type \"${String(superType.name)}\" should be used with type paramteres!`, currentNode.superClass.loc);\n    }\n\n    const superFunctionType = (0, _functionUtils.functionWithReturnType)( // $FlowIssue\n    superClass.properties.get(_constants.CONSTRUCTABLE).type, self);\n    const $super = new _objectType.ObjectType(String(superClass.name), {\n      isSubtypeOf: superType\n    }, [[_constants.CALLABLE, new _variableInfo.VariableInfo(superFunctionType, classScope)]]);\n    const genericParams = (currentNode.superTypeParameters || []).map(arg => (0, _typeUtils.getTypeFromTypeAnnotation)({\n      typeAnnotation: arg\n    }, typeScope, classScope.parent, true, null, parentNode, typeGraph, precompute, middlecompute, postcompute));\n    selfObject.isSubtypeOf = superType instanceof _genericType.GenericType ? superType.applyGeneric(genericParams, currentNode.superClass.loc) : superClass.instanceType;\n    classScope.body.set(\"super\", new _variableInfo.VariableInfo($super, classScope));\n  }\n\n  const selfVar = new _variableInfo.VariableInfo(self, classScope);\n  classScope.body.set(_constants.THIS_TYPE, selfVar);\n\n  if (currentNode.type === _nodes2.default.CLASS_EXPRESSION || currentNode.type === _nodes2.default.CLASS_DECLARATION) {\n    const typeInTypeScope = selfVar.type instanceof _bottomType.$BottomType ? selfVar.type.subordinateMagicType : selfVar.type;\n    parentTypeScope.body.set(name, typeInTypeScope);\n\n    if (typeInTypeScope instanceof _genericType.GenericType) {\n      typeInTypeScope.shouldBeUsedAsGeneric = true;\n    }\n\n    const staticName = getClassName(currentNode);\n    const options = {\n      isNominal: true,\n      parent: typeScope\n    };\n\n    if (superClass !== undefined) {\n      // $FlowIssue\n      options.isSubtypeOf = superClass;\n    }\n\n    const staticSelfObject = _objectType.ObjectType.term(staticName, options, []);\n\n    const staticSelfVar = new _variableInfo.VariableInfo(staticSelfObject, classScope.parent); // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n\n    classScope.parent.body.set(name, staticSelfVar);\n    classScope.declaration = staticSelfVar;\n    staticSelfObject.instanceType = self;\n    selfObject.classType = staticSelfObject;\n    const isConstructorPresented = currentNode.body.body.some(m => m.kind === \"constructor\");\n\n    if (!isConstructorPresented) {\n      const $super = classScope.body.get(\"super\");\n      const parentConstructor = $super !== undefined && $super.type instanceof _objectType.ObjectType ? $super.type.properties.get(_constants.CALLABLE) : undefined;\n      const constructor = parentConstructor && (parentConstructor.type instanceof _functionType.FunctionType || parentConstructor.type instanceof _genericType.GenericType && parentConstructor.type.subordinateType instanceof _functionType.FunctionType) ? parentConstructor : new _variableInfo.VariableInfo(_functionType.FunctionType.new(`() => ${name}`, {\n        parent: self.parent\n      }, [], self), classScope, new _meta.Meta(currentNode.loc));\n\n      if (!constructor.hasInitializer) {\n        constructor.hasInitializer = true;\n      }\n\n      let type = constructor.type instanceof _genericType.GenericType ? constructor.type.subordinateType : constructor.type;\n      type.returnType = (type.returnType instanceof _objectType.ObjectType || type.returnType instanceof _collectionType.CollectionType) && _objectType.ObjectType.Object.isPrincipalTypeFor(type.returnType) ? type.returnType : self;\n\n      if (self instanceof _bottomType.$BottomType) {\n        const localTypeScope = constructor.type instanceof _genericType.GenericType ? constructor.type.localTypeScope : self.subordinateMagicType.localTypeScope;\n        const addition = constructor.type instanceof _genericType.GenericType ? constructor.type.genericArguments : [];\n        const genericArguments = Array.from(new Set([...self.genericArguments, addition]));\n        type = _genericType.GenericType.new(`constructor ${String(self.name)}`, {}, genericArguments, localTypeScope, type);\n      }\n\n      constructor.type = type;\n      staticSelfObject.properties.set(_constants.CONSTRUCTABLE, constructor);\n    }\n  }\n\n  if (currentNode.implements) {\n    const localTypeScope = self instanceof _bottomType.$BottomType ? self.subordinateMagicType.localTypeScope : typeScope;\n    currentNode.implements = currentNode.implements.map(typeAnnotation => {\n      const typeForImplementation = (0, _typeUtils.getTypeFromTypeAnnotation)({\n        typeAnnotation\n      }, localTypeScope, classScope.parent, true, null, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n      if (!(typeForImplementation instanceof _objectType.ObjectType) || typeForImplementation.isStrict) {\n        throw new _errors2.default(\"Type which should be implemented should be an soft objecty type\", typeAnnotation.loc);\n      }\n\n      currentNode.body.body.forEach(node => {\n        if (node.type !== _nodes2.default.CLASS_PROPERTY && node.type !== _nodes2.default.CLASS_PRIVATE_PROPERTY && node.type !== _nodes2.default.CLASS_METHOD && node.type !== _nodes2.default.CLASS_PRIVATE_METHOD) {\n          return;\n        }\n\n        const propertyName = (0, _variableUtils.getPropertyName)(node);\n        const existedProperty = typeForImplementation.properties.get(propertyName);\n\n        if (existedProperty === undefined) {\n          return;\n        }\n\n        node.expected = existedProperty.type;\n      });\n      return {\n        loc: typeAnnotation.loc,\n        id: typeAnnotation.id,\n        typeForImplementation\n      };\n    });\n  }\n}\n\nfunction addThisToObjectScope(objectScope, currentNode) {\n  const properties = currentNode.expected instanceof _objectType.ObjectType ? [...currentNode.expected.properties] : [];\n  const self = new _objectType.ObjectType(\"{  }\", {}, properties);\n  const selfVar = new _variableInfo.VariableInfo(self, objectScope);\n  objectScope.body.set(_constants.THIS_TYPE, selfVar);\n}\n\nfunction addClassScopeToTypeGraph(currentNode, parentNode, typeGraph) {\n  const scopeName = _variableScope.VariableScope.getName(currentNode);\n\n  const existed = typeGraph.scopes.get(scopeName);\n\n  if (existed !== undefined) {\n    return existed;\n  }\n\n  const name = currentNode.id != undefined ? (0, _common.getDeclarationName)(currentNode) : (0, _common.getAnonymousKey)(currentNode);\n  const scope = (0, _scopeUtils.getScopeFromNode)(currentNode, parentNode, typeGraph);\n  const parentTypeScope = (0, _scopeUtils.findNearestTypeScope)(scope, typeGraph);\n  parentTypeScope.body.set(name, currentNode);\n  typeGraph.scopes.set(scopeName, scope);\n\n  if (scope.type === _variableScope.VariableScope.OBJECT_TYPE) {\n    addThisToObjectScope(scope, currentNode);\n  } else {\n    currentNode.body.body.unshift({\n      type: _nodes2.default.THIS_TYPE_DEFINITION,\n      parentNode,\n      definition: currentNode,\n      loc: currentNode.loc\n    });\n  }\n\n  return scope;\n}\n\nfunction addPropertyNodeToThis(currentNode, parentNode, typeGraph, pre, middle, post) {\n  const propertyName = (0, _variableUtils.getPropertyName)(currentNode); // $FlowIssue\n\n  const currentClassScope = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, typeGraph);\n\n  if (currentClassScope.isProcessed) {\n    return;\n  } // $FlowIssue\n\n\n  const self = currentNode.static || propertyName === _constants.CONSTRUCTABLE ? currentClassScope.declaration : currentClassScope.findVariable({\n    name: _constants.THIS_TYPE\n  }, parentNode, typeGraph, pre, middle, post);\n  const selfType = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.subordinateType : self.type;\n\n  if (!(selfType instanceof _objectType.ObjectType)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const existedProperty = selfType.properties.get(propertyName);\n\n  if (existedProperty !== undefined && (currentClassScope.type === _variableScope.VariableScope.CLASS_TYPE || existedProperty instanceof _variableInfo.VariableInfo && existedProperty.hasInitializer)) {\n    throw new _errors2.default(\"Duplicated property definition!\", currentNode.loc);\n  }\n\n  if (!(existedProperty instanceof _variableInfo.VariableInfo)) {\n    selfType.properties.set(propertyName, currentNode);\n  }\n}\n\nfunction addObjectToTypeGraph(currentNode, typeGraph) {\n  const objectScope = typeGraph.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n  if (objectScope === undefined) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const self = objectScope.body.get(_constants.THIS_TYPE);\n\n  if (!(self instanceof _variableInfo.VariableInfo)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  let selfType = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.subordinateType : self.type;\n\n  if (!(selfType instanceof _objectType.ObjectType)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const properties = [];\n\n  for (const [key, property] of selfType.properties.entries()) {\n    if (property.hasInitializer) {\n      properties.push([key, property]);\n    }\n  }\n\n  const name = _objectType.ObjectType.getName(properties, selfType);\n\n  selfType = _objectType.ObjectType.term(name, {}, properties);\n  self.type = selfType;\n  objectScope.isProcessed = true;\n  return self;\n}\n\nfunction addClassToTypeGraph(classNode, typeScope, typeGraph, parentNode, pre, middle, post, isTypeDefinitions) {\n  const classScope = typeGraph.scopes.get(_variableScope.VariableScope.getName(classNode));\n  const name = classNode.id != undefined ? (0, _common.getDeclarationName)(classNode) : (0, _common.getAnonymousKey)(classNode);\n\n  if (!(classScope instanceof _variableScope.VariableScope)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const self = classScope.findVariable({\n    name: _constants.THIS_TYPE\n  }, parentNode, typeGraph, pre, middle, post); // $FlowIssue\n\n  const {\n    properties\n  } = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.subordinateType : self.type;\n\n  if (self.type.name === \"{  }\") {\n    self.type.name = _objectType.ObjectType.getName([...properties]);\n  }\n\n  const superType = classScope.body.get(\"super\");\n  typeScope.body.set(name, self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType : self.type);\n  const selfObject = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.subordinateType : self.type;\n\n  if (!(selfObject instanceof _objectType.ObjectType)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  selfObject.parent = [...selfObject.properties].reduce((parent, [_, {\n    type\n  }]) => type !== undefined && parent.priority < type.parent.priority ? type.parent : parent, selfObject.parent);\n  const existedConstructor = classNode.body.body.find(m => m.kind === \"constructor\");\n\n  if (existedConstructor && !isTypeDefinitions) {\n    const constructorScope = typeGraph.scopes.get(_variableScope.VariableScope.getName(existedConstructor));\n\n    if (!(constructorScope instanceof _variableScope.VariableScope)) {\n      throw new Error(\"Never!!!\");\n    }\n\n    if (constructorScope.calls.find(call => call.targetName === \"return\") === undefined) {\n      const callMeta = new _callMeta.CallMeta(new _functionType.FunctionType(\"\", {}, [self.type], self.type), [self], // $FlowIssue\n      constructorScope.declaration.meta.loc, \"return\", self.type.parent, false, true);\n      constructorScope.calls.push(callMeta);\n    }\n\n    if (superType !== undefined) {\n      const superCallIndex = constructorScope.calls.findIndex(call => call.targetName === \"super\");\n      const thisCallIndex = constructorScope.calls.findIndex(call => call.targetName === \"this\");\n\n      if (superCallIndex === -1) {\n        throw new _errors2.default('Constructor must contain \"super\" call super inside', // $FlowIssue\n        constructorScope.declaration.meta.loc);\n      }\n\n      if (thisCallIndex !== -1 && superCallIndex > thisCallIndex) {\n        throw new _errors2.default('\"super\" must be called before accessing \"this\"', constructorScope.calls[thisCallIndex].loc);\n      }\n    }\n  }\n\n  if (classNode.implements) {\n    const localTypeScope = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.localTypeScope : typeScope;\n    classNode.implements.forEach(({\n      typeForImplementation,\n      id,\n      loc\n    }) => {\n      if (!typeForImplementation.isPrincipalTypeFor(self.type)) {\n        throw new _errors2.default(`Wrong implementation for type \"${id.name}\"`, loc);\n      }\n    });\n  }\n\n  const {\n    declaration\n  } = classScope;\n\n  if (!isTypeDefinitions && declaration !== undefined && declaration.type instanceof _objectType.ObjectType) {\n    const errors = [];\n    [...properties, ...declaration.type.properties].forEach(([key, property]) => {\n      if (!property.hasInitializer && !property.type.contains(_type.Type.Undefined)) {\n        errors.push(new _errors2.default(`Property \"${key}\" has a type, but doesn't have an initializer!`, property.meta.loc));\n      }\n    });\n\n    if (errors.length !== 0) {\n      throw errors;\n    }\n  }\n\n  classScope.isProcessed = true; // $FlowIssue\n\n  return classScope.declaration;\n}\n\nfunction getClassName(classNode) {\n  if (classNode.id !== null) {\n    return `class ${classNode.id.name}`;\n  }\n\n  return `Anonymous Class [${classNode.loc.start.line}:${classNode.loc.end.line}]`;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDeclarationName = exports.getAnonymousKey = undefined;\nexports.unique = unique;\nexports.intersection = intersection;\nexports.union = union;\nexports.getMemberExressionTarget = getMemberExressionTarget;\nexports.ensureArray = ensureArray;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst getAnonymousKey = exports.getAnonymousKey = node => `[[Anonymuos${node.loc.start.line}-${node.loc.start.column}]]`;\n\nconst getDeclarationName = exports.getDeclarationName = node => node.id.name;\n\nfunction unique(arr, getKey = x => x) {\n  const filterObject = {};\n\n  for (let i = 0; i < arr.length; i++) {\n    const key = getKey(arr[i]);\n    filterObject[key] = arr[i];\n  }\n\n  return Object.values(filterObject);\n}\n\nfunction intersection(arr1, arr2, isEquals = (a, b) => a === b) {\n  const intersectionResult = [];\n  const exclusiveOr = [];\n\n  for (let i = 0; i < arr1.length; i++) {\n    for (let j = 0; j < arr2.length; j++) {\n      if (!isEquals(arr1[i], arr2[j])) {\n        exclusiveOr.push(arr1[i], arr2[j]);\n        continue;\n      }\n\n      intersectionResult.push(arr2[j]);\n    }\n  }\n\n  return [intersectionResult, exclusiveOr];\n}\n\nfunction union(arr1, arr2, isEquals = (a, b) => a === b) {\n  const unionResult = [];\n\n  for (let i = 0; i < arr1.length; i++) {\n    for (let j = 0; j < arr2.length; j++) {\n      if (isEquals(arr1[i], arr2[j])) {\n        unionResult.push(arr2[j]);\n        continue;\n      }\n\n      unionResult.push(arr2[j]);\n    }\n  }\n\n  return unionResult;\n}\n\nfunction getMemberExressionTarget(node) {\n  let target = node;\n\n  do {\n    target = target.object;\n  } while (target.type === _nodes2.default.MEMBER_EXPRESSION);\n\n  return target;\n}\n\nfunction ensureArray(value) {\n  if (value === undefined || value === null) {\n    return [];\n  } // $FlowIssue\n\n\n  return Array.isArray(value) ? value : [value];\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass HegelError extends Error {\n  constructor(message, loc, source = \"\") {\n    super(message);\n\n    _defineProperty(this, \"loc\", void 0);\n\n    _defineProperty(this, \"source\", void 0);\n\n    this.source = source;\n    this.loc = loc && {\n      end: loc.end,\n      start: loc.start\n    };\n  }\n\n}\n\nexports.default = HegelError;\n\nclass UnreachableError extends Error {\n  constructor(loc) {\n    super(\"\");\n\n    _defineProperty(this, \"loc\", void 0);\n\n    this.loc = {\n      end: loc.end,\n      start: loc.start\n    };\n  }\n\n}\n\nexports.UnreachableError = UnreachableError;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addFunctionScopeToTypeGraph = addFunctionScopeToTypeGraph;\nexports.addFunctionNodeToTypeGraph = addFunctionNodeToTypeGraph;\nexports.addFunctionToTypeGraph = addFunctionToTypeGraph;\nexports.isCallableType = isCallableType;\nexports.isSideEffectCall = isSideEffectCall;\nexports.functionWithReturnType = functionWithReturnType;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _variableUtils = require(\"./variable-utils\");\n\nvar _inference = require(\"../inference\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _common = require(\"./common\");\n\nvar _scopeUtils = require(\"../utils/scope-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addFunctionScopeToTypeGraph(currentNode, parentNode, moduleScope, variableInfo) {\n  const scope = (0, _scopeUtils.getScopeFromNode)(currentNode, parentNode, moduleScope, variableInfo);\n  scope.throwable = [];\n  moduleScope.scopes.set(_variableScope.VariableScope.getName(currentNode), scope);\n\n  if (currentNode.type === _nodes2.default.FUNCTION_EXPRESSION && currentNode.id) {\n    // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n    scope.body.set((0, _common.getDeclarationName)(currentNode), variableInfo);\n  }\n\n  return scope;\n}\n\nfunction addFunctionNodeToTypeGraph(currentNode, parentNode, moduleScope) {\n  const name = (0, _common.getDeclarationName)(currentNode);\n  const currentScope = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, moduleScope);\n  currentScope.body.set(name, currentNode);\n}\n\nfunction addFunctionToTypeGraph(currentNode, parentNode, moduleScope, pre, middle, post, isTypeDefinitions) {\n  const name = currentNode.type === _nodes2.default.FUNCTION_DECLARATION || currentNode.type === _nodes2.default.TS_FUNCTION_DECLARATION ? (0, _common.getDeclarationName)(currentNode) : (0, _common.getAnonymousKey)(currentNode);\n  const variableInfo = (0, _variableUtils.addVariableToGraph)(currentNode, parentNode, moduleScope, pre, middle, post, name);\n  variableInfo.isInferenced = currentNode.returnType === undefined;\n  const currentTypeScope = (0, _scopeUtils.findNearestTypeScope)(variableInfo.parent, moduleScope);\n  const scope = isTypeDefinitions ? new _variableScope.VariableScope(_variableScope.VariableScope.FUNCTION_TYPE, variableInfo.parent) : addFunctionScopeToTypeGraph(currentNode, parentNode, moduleScope, variableInfo);\n  variableInfo.type = (0, _inference.inferenceTypeForNode)(currentNode, currentTypeScope, variableInfo.parent, moduleScope, parentNode, pre, middle, post, isTypeDefinitions);\n  const expected = currentNode.expected;\n  let expectedType = expected instanceof _genericType.GenericType ? expected.subordinateType : expected;\n\n  if (expectedType instanceof _unionType.UnionType) {\n    expectedType = expectedType.variants.find(a => {\n      a = a instanceof _genericType.GenericType ? a.subordinateType : a;\n      return a instanceof _functionType.FunctionType;\n    });\n    expectedType = expectedType instanceof _genericType.GenericType ? expectedType.subordinateType : expectedType;\n  }\n\n  let functionType = variableInfo.type instanceof _genericType.GenericType ? variableInfo.type.subordinateType : variableInfo.type;\n  let genericArgumentsTypes = variableInfo.type instanceof _genericType.GenericType ? variableInfo.type.genericArguments : [];\n\n  if (expected instanceof _genericType.GenericType) {\n    genericArgumentsTypes = [...genericArgumentsTypes, ...expected.genericArguments];\n  }\n\n  if (expectedType instanceof _functionType.FunctionType) {\n    const inferencedArgumentsTypes = functionType.argumentsTypes;\n    const expectedArgumentsTypes = expectedType.argumentsTypes;\n    const argumentsTypes = Array.from({\n      length: Math.max(inferencedArgumentsTypes.length, expectedArgumentsTypes.length)\n    });\n    let wereArgumentsChanged = false;\n    const newArgumentsTypes = argumentsTypes.reduce((res, _, i) => {\n      const expectedArgumentType = expectedArgumentsTypes[i];\n      const inferencedArgumentType = inferencedArgumentsTypes[i];\n\n      if (inferencedArgumentType instanceof _typeVar.TypeVar && !inferencedArgumentType.isUserDefined && expectedArgumentType !== undefined) {\n        wereArgumentsChanged = true;\n        return [...res, expectedArgumentType];\n      }\n\n      if (inferencedArgumentType !== undefined) {\n        return [...res, inferencedArgumentType];\n      }\n\n      return res;\n    }, []);\n    const newReturnType = functionType.returnType instanceof _typeVar.TypeVar && !functionType.returnType.isUserDefined && expectedType.returnType.parent.priority <= 1 ? expectedType.returnType : functionType.returnType;\n\n    if (wereArgumentsChanged || newReturnType !== functionType.returnType) {\n      const functionTypeName = _functionType.FunctionType.getName(newArgumentsTypes, newReturnType, genericArgumentsTypes, currentNode.async, functionType.throwable);\n\n      functionType = _functionType.FunctionType.term(functionTypeName, {}, newArgumentsTypes, newReturnType);\n      variableInfo.isInferenced = false;\n      variableInfo.type = genericArgumentsTypes.length > 0 ? _genericType.GenericType.new(functionTypeName, {}, genericArgumentsTypes, // $FlowIssue\n      variableInfo.type.localTypeScope, functionType) : functionType;\n    }\n  }\n\n  const withPositions = moduleScope instanceof _moduleScope.PositionedModuleScope;\n  const argumentsTypes = functionType.argumentsTypes;\n  currentNode.params.forEach((param, index) => {\n    let type = argumentsTypes[index];\n\n    if (type === undefined) {\n      type = argumentsTypes[argumentsTypes.length - 1];\n\n      if (!(type instanceof _functionType.RestArgument)) {\n        type = _type.Type.Undefined;\n      }\n    }\n\n    const id = param.left || param.argument || param;\n\n    if (param.left != undefined && type instanceof _unionType.UnionType) {\n      const types = type.variants.filter(a => a !== _type.Type.Undefined);\n      type = _unionType.UnionType.term(null, {\n        parent: currentTypeScope\n      }, types);\n    }\n\n    if (type instanceof _functionType.RestArgument) {\n      if (param.argument != undefined) {\n        type = type.type;\n      } else {\n        type = type.type.getPropertyType(index);\n      }\n    }\n\n    let varInfo = scope.body.get(id.name);\n    /*::if (type == undefined) return*/\n\n    if (varInfo !== undefined) {\n      varInfo.type = type;\n      varInfo.parent = scope;\n    } else {\n      varInfo = new _variableInfo.VariableInfo(type, scope, new _meta.Meta(id.loc));\n      scope.body.set(id.name, varInfo);\n    }\n\n    if (withPositions) {\n      // $FlowIssue\n      moduleScope.addPosition(id, varInfo);\n    }\n  });\n\n  if (withPositions && currentNode.id != null) {\n    // $FlowIssue\n    moduleScope.addPosition(currentNode.id, variableInfo);\n  }\n\n  return variableInfo;\n}\n\nfunction isCallableType(a) {\n  if (a instanceof _genericType.GenericType) {\n    a = a.subordinateType;\n  }\n\n  return a instanceof _functionType.FunctionType;\n}\n\nfunction isSideEffectCall(node, invocationResult) {\n  return node.type === _nodes2.default.EXPRESSION_STATEMENT && // i.e we don't assign a return value of it to any variable\n  node.expression != null && ( //\n  node.expression.type === _nodes2.default.CALL_EXPRESSION || // if we call a function like a side effect.\n  node.expression.type === _nodes2.default.TAGGED_TEMPLATE_EXPRESSION) && // if we call a function as tag like a side effect.\n  !invocationResult.equalsTo(_type.Type.Undefined) && // but call of this function actually return something.\n  !invocationResult.equalsTo(_type.Type.Undefined.promisify()) // but call of this function actually return something.\n  ;\n}\n\nfunction functionWithReturnType(functionType, newReturnType) {\n  const oldFunctionType = functionType instanceof _genericType.GenericType ? functionType.subordinateType : functionType;\n  const newFunctionArguments = [...oldFunctionType.argumentsTypes];\n  const newFunctionGenericArguments = functionType instanceof _genericType.GenericType ? [...functionType.genericArguments] : [];\n\n  const newFunctionType = _functionType.FunctionType.term(_functionType.FunctionType.getName(newFunctionArguments, newReturnType, newFunctionGenericArguments, oldFunctionType.isAsync), {}, newFunctionArguments, newReturnType);\n\n  if (!(functionType instanceof _genericType.GenericType) || newFunctionType instanceof _genericType.GenericType) {\n    return newFunctionType;\n  }\n\n  return _genericType.GenericType.new(newFunctionType.name, {}, newFunctionGenericArguments, functionType.localTypeScope, newFunctionType);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nconst mixBaseGlobals = moduleScope => {\n  const typeScope = moduleScope.typeScope;\n  const globalTypes = [[\"unknown\", _type.Type.Unknown], [\"never\", _type.Type.Never], [\"undefined\", _type.Type.Undefined], [null, _type.Type.Null], [\"number\", _type.Type.Number], [\"bigint\", _type.Type.BigInt], [\"string\", _type.Type.String], [true, _type.Type.True], [false, _type.Type.False], [\"boolean\", _unionType.UnionType.Boolean], [\"symbol\", _type.Type.Symbol]];\n  const globals = [[\"undefined\", new _variableInfo.VariableInfo(_type.Type.Undefined)]];\n\n  for (const [name, type] of globalTypes) {\n    typeScope.body.set(name, type);\n    type.parent = typeScope;\n  }\n\n  for (const [name, variable] of globals) {\n    moduleScope.body.set(name, variable);\n    variable.parent = moduleScope;\n  }\n};\n\nexports.default = mixBaseGlobals;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupBaseHierarchy = setupBaseHierarchy;\nexports.setupFullHierarchy = setupFullHierarchy;\nexports.dropAllGlobals = dropAllGlobals;\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nfunction setupBaseHierarchy(globalTypeScope) {\n  _type.Type.GlobalTypeScope = globalTypeScope;\n  _type.Type.Undefined.parent = globalTypeScope;\n  _type.Type.Null.parent = globalTypeScope;\n  _type.Type.String.parent = globalTypeScope;\n  _type.Type.Symbol.parent = globalTypeScope;\n  _type.Type.True.parent = globalTypeScope;\n  _type.Type.False.parent = globalTypeScope;\n  _unionType.UnionType.Boolean.parent = globalTypeScope;\n  _type.Type.Number.parent = globalTypeScope;\n  _type.Type.BigInt.parent = globalTypeScope;\n  _type.Type.Unknown.parent = globalTypeScope;\n  _type.Type.Never.parent = globalTypeScope;\n  _objectType.ObjectType.Object.parent = globalTypeScope;\n  _functionType.FunctionType.Function.parent = globalTypeScope;\n  _tupleType.TupleType.ReadonlyArray.parent = globalTypeScope;\n  _collectionType.CollectionType.Array.parent = globalTypeScope;\n  _typeVar.TypeVar.Self.parent = globalTypeScope;\n}\n\nfunction setupFullHierarchy(globalTypeScope) {\n  _objectType.ObjectType.Object.root = _objectType.ObjectType.term(\"Object\", {}, []);\n  globalTypeScope.body.set(\"Object\", _objectType.ObjectType.Object);\n  _functionType.FunctionType.Function.root = _objectType.ObjectType.term(\"Function\", {}, []);\n  globalTypeScope.body.set(\"Function\", _functionType.FunctionType.Function);\n  const readonlyArrayLocal = new _typeScope.TypeScope(globalTypeScope);\n  _tupleType.TupleType.ReadonlyArray.root = _genericType.GenericType.term(\"ReadonlyArray\", {}, [_typeVar.TypeVar.new(\"T\", {\n    parent: readonlyArrayLocal\n  })], readonlyArrayLocal, _objectType.ObjectType.new(\"ReadonlyArray<T>\", {\n    parent: readonlyArrayLocal\n  }, []));\n  _tupleType.TupleType.ReadonlyArray.name = \"$Immutable<Array<T>>\";\n  _tupleType.TupleType.ReadonlyArray.root.name = \"$Immutable<Array<T>>\";\n  _tupleType.TupleType.ReadonlyArray.root.subordinateType.name = \"$Immutable<Array<T>>\";\n  const arrayLocal = new _typeScope.TypeScope(globalTypeScope);\n  _collectionType.CollectionType.Array.root = _genericType.GenericType.term(\"Array\", {}, [_typeVar.TypeVar.new(\"T\", {\n    parent: arrayLocal\n  })], arrayLocal, _objectType.ObjectType.new(\"Array<T>\", {\n    parent: arrayLocal\n  }, []));\n}\n\nfunction dropAllGlobals() {\n  _objectType.ObjectType.Object.root = undefined;\n  _functionType.FunctionType.Function.root = undefined;\n  _tupleType.TupleType.ReadonlyArray.root = undefined;\n  _collectionType.CollectionType.Array.root = undefined;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst IGNORE_COMMENT = \"@hegel-issue\";\n\nclass IgnorableArray extends Array {\n  static withIgnoring(comments, path) {\n    const ignored = new Set(comments.filter(comment => comment.value.trim() === IGNORE_COMMENT).map(comment => comment.loc.end.line + 1));\n    return new IgnorableArray(ignored, path);\n  }\n\n  constructor(ignored, path) {\n    super();\n\n    _defineProperty(this, \"_ignored\", void 0);\n\n    _defineProperty(this, \"_path\", void 0);\n\n    this._ignored = ignored;\n    this._path = path;\n  }\n\n  push(...elements) {\n    elements.forEach(element => {\n      if (element.loc === undefined || !this._ignored.has(element.loc.start.line)) {\n        element.source = this._path;\n        super.push(element);\n      }\n    }); // It's needed for backward compatibility with Array\n\n    return 0;\n  }\n\n}\n\nexports.IgnorableArray = IgnorableArray;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importDependencies = importDependencies;\nexports.default = mixImportedDependencies;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"./errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getImportName(specifier) {\n  if (specifier.type === _nodes2.default.IMPORT_SPECIFIER) {\n    return specifier.imported.name;\n  }\n\n  if (specifier.type === _nodes2.default.IMPORT_DEFAULT_SPECIFIER) {\n    return \"default\";\n  }\n\n  return null;\n}\n\nfunction importDependencies(modulePath, importNode, sourceModuleTypeGraph, currentModuleTypeGraph, currentModuleTypeScope, isTypeDefinitions) {\n  const {\n    exports,\n    exportsTypes\n  } = sourceModuleTypeGraph;\n  const importSource = importNode.importKind === \"type\" || isTypeDefinitions ? exportsTypes : exports;\n  const importTarget = importNode.importKind === \"type\" || isTypeDefinitions ? currentModuleTypeScope : currentModuleTypeGraph;\n  const importEntries = [...importSource.entries()].map(([key, a]) => [key, a instanceof _variableInfo.VariableInfo ? a : new _variableInfo.VariableInfo(a, sourceModuleTypeGraph)]);\n  const withPositions = currentModuleTypeGraph instanceof _moduleScope.PositionedModuleScope;\n  const shouldBeVariable = importTarget instanceof _moduleScope.ModuleScope;\n  importNode.specifiers.forEach(specifier => {\n    const importName = getImportName(specifier);\n    let importElement = importName ? importSource.get(importName) || exports.get(importName) : _objectType.ObjectType.term(_objectType.ObjectType.getName(importEntries), {\n      typeScope: currentModuleTypeScope\n    }, importEntries);\n\n    if (importElement === undefined) {\n      throw new _errors2.default(`Module \"${importNode.source.value}\" hasn't \"${importName || \"*\"}\" export`, specifier.loc, modulePath);\n    }\n\n    if (importElement instanceof _objectType.ObjectType && importElement.instanceType !== null) {\n      currentModuleTypeScope.body.set(importName, importElement.instanceType);\n    }\n\n    if (shouldBeVariable && !(importElement instanceof _variableInfo.VariableInfo)) {\n      importElement = new _variableInfo.VariableInfo(importElement, // $FlowIssue\n      importTarget, new _meta.Meta(specifier.loc));\n    }\n\n    let finalImportVariable = importElement;\n\n    if (importNode.importKind !== \"type\" && !isTypeDefinitions && importElement instanceof _type.Type) {\n      finalImportVariable = new _variableInfo.VariableInfo(importElement, currentModuleTypeGraph);\n    }\n\n    if ((importNode.importKind === \"type\" || isTypeDefinitions) && importElement instanceof _variableInfo.VariableInfo) {\n      finalImportVariable = importElement.type;\n    } // $FlowIssue\n\n\n    importTarget.body.set(specifier.local.name, finalImportVariable);\n\n    if (withPositions) {\n      // $FlowIssue\n      currentModuleTypeGraph.addPosition(specifier, finalImportVariable);\n    }\n  });\n}\n\nasync function mixImportedDependencies(ast, path, errors, currentModuleScope, currentTypeScope, getModuleTypeGraph, isTypeDefinitions) {\n  const importRequests = [];\n  let importCount = 0;\n\n  for (importCount = 0; importCount < ast.body.length; importCount++) {\n    const node = ast.body[importCount];\n\n    if (node.type === _nodes2.default.INTERPRETER_DIRECTIVE) {\n      continue;\n    }\n\n    if (!_nodes2.default.isImport(node)) {\n      break;\n    }\n\n    importRequests.push(Promise.all([node, getModuleTypeGraph(node.source.value, path, node.loc).then(module => {\n      if (errors.some(error => error.source === module.path) && currentModuleScope instanceof _moduleScope.PositionedModuleScope) {\n        errors.push(new _errors2.default(`There are problems inside \"${node.source.value}\"`, node.loc, currentModuleScope.path));\n      }\n\n      return module;\n    })]));\n  }\n\n  if (importCount !== 0) {\n    ast.body.splice(0, importCount);\n  }\n\n  const importedTypeGraphs = await Promise.all(importRequests);\n\n  for (let i = 0; i < importedTypeGraphs.length; i++) {\n    try {\n      const [importNode, moduleTypeGraph] = importedTypeGraphs[i];\n      importDependencies(path, importNode, moduleTypeGraph, currentModuleScope, currentTypeScope, isTypeDefinitions);\n    } catch (e) {\n      if (!(e instanceof _errors2.default)) {\n        throw e;\n      }\n\n      errors.push(e);\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypesFromVariants = getTypesFromVariants;\nexports.getPropertyChaining = getPropertyChaining;\nexports.mergeRefinementsVariants = mergeRefinementsVariants;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _typeUtils = require(\"./type-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getTypesFromVariants(_refinementedVariants, _alternateVariants, typeScope) {\n  // $FlowIssue\n  const refinementedVariants = _refinementedVariants.filter(a => a != undefined); // $FlowIssue\n\n\n  const alternateVariants = _alternateVariants.filter(a => a != undefined);\n\n  return [refinementedVariants.length ? _unionType.UnionType.term(null, {}, refinementedVariants) : undefined, alternateVariants.length ? _unionType.UnionType.term(null, {}, alternateVariants) : undefined];\n}\n\nfunction getPropertyChaining(node) {\n  let memberPointer = node;\n  const chaining = [];\n\n  do {\n    if (memberPointer.property.type !== _nodes2.default.IDENTIFIER || memberPointer.computed) {\n      return;\n    }\n\n    chaining.unshift(memberPointer.property.name || memberPointer.property.value);\n    memberPointer = memberPointer.object;\n  } while (memberPointer.type === _nodes2.default.MEMBER_EXPRESSION);\n\n  return chaining;\n}\n\nfunction mergeRefinementsVariants(refinementedType, alternateType, originalProperty, propertyName, typeScope) {\n  const nestedRefinementedType = refinementedType && (0, _typeUtils.createObjectWith)(propertyName, refinementedType, typeScope, originalProperty.meta);\n  const nestedAlternateType = alternateType && (0, _typeUtils.createObjectWith)(propertyName, alternateType, typeScope, originalProperty.meta);\n  return [nestedRefinementedType && (0, _typeUtils.mergeObjectsTypes)( // $FlowIssue\n  originalProperty.type, nestedRefinementedType, typeScope), nestedAlternateType && // $FlowIssue\n  (0, _typeUtils.mergeObjectsTypes)(originalProperty.type, nestedAlternateType, typeScope)];\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst DECLARATION_TYPES = exports.DECLARATION_TYPES = {\n  VARIABLE_DECLARATOR: \"VariableDeclarator\",\n  VARIABLE_DECLARATION: \"VariableDeclaration\",\n  FUNCTION_DECLARATION: \"FunctionDeclaration\",\n  TS_FUNCTION_DECLARATION: \"TSDeclareFunction\",\n  TS_CALL_SIGNATURE_DECLARATION: \"TSCallSignatureDeclaration\",\n  TS_TYPE_QUERY: \"TSTypeQuery\",\n  CLASS_DECLARATION: \"ClassDeclaration\",\n  VARIABLE_DECLARATOR: \"VariableDeclarator\",\n  VARIABLE_DECLARATOR: \"VariableDeclarator\",\n  TYPE_ALIAS: \"TypeAlias\",\n  TS_TYPE_ALIAS: \"TSTypeAliasDeclaration\",\n  TS_DECLARE_METHOD: \"TSDeclareMethod\",\n  TS_INTERFACE_DECLARATION: \"TSInterfaceDeclaration\",\n  INTERFACE_DECLARATION: \"InterfaceDeclaration\",\n  TYPE_PARAMETER: \"TypeParameter\",\n  TYPE_PARAMETER_DECLARATION: \"TypeParameterDeclaration\",\n  TS_TYPE_PARAMETER_DECLARATION: \"TSTypeParameterDeclaration\",\n  TS_TYPE_PARAMETER: \"TSTypeParameter\",\n  EXPORT_LIST: \"ExportList\",\n  EXPORT_SPECIFIER: \"ExportSpecifier\",\n  EXPORT_NAMED_DECLARATION: \"ExportNamedDeclaration\",\n  EXPORT_DEFAULT_DECLARATION: \"ExportDefaultDeclaration\",\n  IMPORT_DECLARATION: \"ImportDeclaration\"\n};\nconst STATEMENTS_TYPES = exports.STATEMENTS_TYPES = {\n  PURE_KEY: \"PureKeyStatement\",\n  PURE_VALUE: \"PureValueStatement\",\n  VALUE: \"WeakValueStatement\",\n  BLOCK_STATEMENT: \"BlockStatement\",\n  IF_STATEMENT: \"IfStatement\",\n  WHILE_STATEMENT: \"WhileStatement\",\n  DO_WHILE_STATEMENT: \"DoWhileStatement\",\n  FOR_STATEMENT: \"ForStatement\",\n  FOR_IN_STATEMENT: \"ForInStatement\",\n  FOR_OF_STATEMENT: \"ForOfStatement\",\n  EXPRESSION_STATEMENT: \"ExpressionStatement\",\n  RETURN_STATEMENT: \"ReturnStatement\",\n  EMPTY_STATEMENT: \"EmptyStatement\",\n  TRY_STATEMENT: \"TryStatement\",\n  THROW_STATEMENT: \"ThrowStatement\",\n  BREAK_STATEMENT: \"BreakStatement\",\n  CONTINUE_STATEMENT: \"ContinueStatement\",\n  CATCH_CLAUSE: \"CatchClause\",\n  SWITCH_STATEMENT: \"SwitchStatement\",\n  SWITCH_CASE: \"SwitchCase\",\n  INTERPRETER_DIRECTIVE: \"InterpreterDirective\"\n};\nconst EXPRESSIONS_TYPES = exports.EXPRESSIONS_TYPES = {\n  SUPER: \"Super\",\n  ARRAY_EXPRESSION: \"ArrayExpression\",\n  TAGGED_TEMPLATE_EXPRESSION: \"TaggedTemplateExpression\",\n  SEQUENCE_EXPRESSION: \"SequenceExpression\",\n  FUNCTION_EXPRESSION: \"FunctionExpression\",\n  ARROW_FUNCTION_EXPRESSION: \"ArrowFunctionExpression\",\n  OBJECT_EXPRESSION: \"ObjectExpression\",\n  CLASS_EXPRESSION: \"ClassExpression\",\n  ASSIGNMENT_EXPRESSION: \"AssignmentExpression\",\n  TS_EXPORT_ASSIGNMENT: \"TSExportAssignment\",\n  ASSIGNMENT_PATTERN: \"AssignmentPattern\",\n  BINARY_EXPRESSION: \"BinaryExpression\",\n  UNARY_EXPRESSION: \"UnaryExpression\",\n  CONDITIONAL_EXPRESSION: \"ConditionalExpression\",\n  AWAIT_EXPRESSION: \"AwaitExpression\",\n  LOGICAL_EXPRESSION: \"LogicalExpression\",\n  CALL_EXPRESSION: \"CallExpression\",\n  MEMBER_EXPRESSION: \"MemberExpression\",\n  UPDATE_EXPRESSION: \"UpdateExpression\",\n  NEW_EXPRESSION: \"NewExpression\",\n  THIS_EXPRESSION: \"ThisExpression\",\n  TS_EXPRESSION_WITH_TYPE_ARGUMENTS: \"TSExpressionWithTypeArguments\",\n  REST_ELEMENT: \"RestElement\"\n};\nconst OBJECT_PROPERTIES = exports.OBJECT_PROPERTIES = {\n  OBJECT_EXPRESSION: \"ObjectExpression\",\n  OBJECT_METHOD: \"ObjectMethod\",\n  TS_OBJECT_METHOD: \"TSMethodSignature\",\n  OBJECT_PROPERTY: \"ObjectProperty\",\n  TS_OBJECT_PROPERTY: \"TSPropertySignature\",\n  TS_INDEX_PROPERTY: \"TSIndexSignature\",\n  TS_CONSTRUCT_SIGNATURE_DECLARATION: \"TSConstructSignatureDeclaration\"\n};\nconst CLASS_PROPERTIES = exports.CLASS_PROPERTIES = {\n  CLASS_METHOD: \"ClassMethod\",\n  CLASS_PRIVATE_METHOD: \"ClassPrivateMethod\",\n  CLASS_PROPERTY: \"ClassProperty\",\n  CLASS_PRIVATE_PROPERTY: \"ClassPrivateProperty\",\n  PRIVATE_NAME: \"PrivateName\"\n};\nconst LITERAL_TYPES = exports.LITERAL_TYPES = {\n  NUMERIC_LITERAL: \"NumericLiteral\",\n  BIGINT_LITERAL: \"BigIntLiteral\",\n  STRING_LITERAL: \"StringLiteral\",\n  BOOLEAN_LITERAL: \"BooleanLiteral\",\n  NULL_LITERAL: \"NullLiteral\",\n  REG_EXP_LITERAL: \"RegExpLiteral\",\n  TS_LITERAL_TYPE: \"TSLiteralType\",\n  TEMPLATE_LITERAL: \"TemplateLiteral\"\n};\nconst ANNOTATION_TYPES = exports.ANNOTATION_TYPES = {\n  FUNCTION_TYPE_ANNOTATION: \"FunctionTypeAnnotation\",\n  CLASS_IMPLEMENTS: \"ClassImplements\",\n  ANY_TYPE_ANNOTATION: \"AnyTypeAnnotation\",\n  VOID_TYPE_ANNOTATION: \"VoidTypeAnnotation\",\n  BOOLEAN_TYPE_ANNOTATION: \"BooleanTypeAnnotation\",\n  MIXED_TYPE_ANNOTATION: \"MixedTypeAnnotation\",\n  EMPTY_TYPE_ANNOTATION: \"EmptyTypeAnnotation\",\n  NUMBER_TYPE_ANNOTATION: \"NumberTypeAnnotation\",\n  STRING_TYPE_ANNOTATION: \"StringTypeAnnotation\",\n  NULL_LITERAL_TYPE_ANNOTATION: \"NullLiteralTypeAnnotation\",\n  GENERIC_TYPE_ANNOTATION: \"GenericTypeAnnotation\",\n  NUMBER_LITERAL_TYPE_ANNOTATION: \"NumberLiteralTypeAnnotation\",\n  BOOLEAN_LITERAL_TYPE_ANNOTATION: \"BooleanLiteralTypeAnnotation\",\n  STRING_LITERAL_TYPE_ANNOTATION: \"StringLiteralTypeAnnotation\",\n  OBJECT_TYPE_ANNOTATION: \"ObjectTypeAnnotation\",\n  OBJECT_TYPE_PROPERTY: \"ObjectTypeProperty\",\n  OBJECT_TYPE_SPREAD_PROPERTY: \"ObjectTypeSpreadProperty\",\n  UNION_TYPE_ANNOTATION: \"UnionTypeAnnotation\",\n  NULLABLE_TYPE_ANNOTATION: \"NullableTypeAnnotation\",\n  TUPLE_TYPE_ANNOTATION: \"TupleTypeAnnotation\",\n  BIGINT_LITERAL_TYPE_ANNOTATION: \"BigIntLiteralTypeAnnotation\",\n  TS_PARENTHESIZED_TYPE: \"TSParenthesizedType\",\n  TS_FUNCTION_TYPE_ANNOTATION: \"TSFunctionType\",\n  TS_ANY_TYPE_ANNOTATION: \"TSAnyKeyword\",\n  SYMBOL_TYPE_ANNOTATION: \"SymbolTypeAnnotation\",\n  TS_SYMBOL_TYPE_ANNOTATION: \"TSSymbolKeyword\",\n  TS_VOID_TYPE_ANNOTATION: \"TSVoidKeyword\",\n  TS_BOOLEAN_TYPE_ANNOTATION: \"TSBooleanKeyword\",\n  TS_UNKNOWN_TYPE_ANNOTATION: \"TSUnknownKeyword\",\n  TS_NEVER_TYPE_ANNOTATION: \"TSNeverKeyword\",\n  TS_NUMBER_TYPE_ANNOTATION: \"TSNumberKeyword\",\n  TS_BIGINT_TYPE_ANNOTATION: \"TSBigIntKeyword\",\n  TS_STRING_TYPE_ANNOTATION: \"TSStringKeyword\",\n  TS_NULL_LITERAL_TYPE_ANNOTATION: \"TSNullKeyword\",\n  TS_OBJECT_KEYWORD: \"TSObjectKeyword\",\n  TS_TYPE_OPERATOR: \"TSTypeOperator\",\n  TS_GENERIC_TYPE_ANNOTATION: \"TSTypeReference\",\n  TS_OBJECT_TYPE_ANNOTATION: \"TSTypeLiteral\",\n  TS_UNION_TYPE_ANNOTATION: \"TSUnionType\",\n  TS_TUPLE_TYPE_ANNOTATION: \"TSTupleType\",\n  TS_TYPE_ANNOTATION: \"TSTypeAnnotation\",\n  TS_TYPE_REFERENCE_ANNOTATION: \"TSTypeReference\",\n  THIS_TYPE_ANNOTATION: \"ThisTypeAnnotation\",\n  TS_THIS_TYPE_ANNOTATION: \"TSThisType\",\n  TS_UNDEFINED_TYPE_ANNOTATION: \"TSUndefinedKeyword\",\n  TS_ARRAY_TYPE_ANNOTATION: \"TSArrayType\",\n  ARRAY_TYPE_ANNOTATION: \"ArrayTypeAnnotation\",\n  TS_INTERSECTION_TYPE: \"TSIntersectionType\",\n  TYPEOF_TYPE_ANNOTATION: \"TypeofTypeAnnotation\",\n  TYPE_CAST: \"TypeCastExpression\",\n  TYPE_GUARD: \"TSTypePredicate\"\n};\nconst INITIALIZATION_TYPES = exports.INITIALIZATION_TYPES = {\n  IDENTIFIER: \"Identifier\",\n  PROGRAM: \"Program\"\n};\nconst DECLARATION_KINDS = exports.DECLARATION_KINDS = {\n  VAR: \"var\",\n  CONST: \"const\",\n  LET: \"let\"\n};\nconst SPECIFIERS_TYPES = exports.SPECIFIERS_TYPES = {\n  IMPORT_DEFAULT_SPECIFIER: \"ImportDefaultSpecifier\",\n  IMPORT_NAMESPACE_SPECIFIER: \"ImportNamespaceSpecifier\",\n  IMPORT_SPECIFIER: \"ImportSpecifier\"\n};\nconst SPECIAL_TYPES = exports.SPECIAL_TYPES = {\n  THIS_TYPE_DEFINITION: \"ThisTypeDefinition\"\n};\n\nconst isUnscopableDeclaration = exports.isUnscopableDeclaration = ({\n  kind\n}) => kind === DECLARATION_KINDS.VAR;\n\nconst isObject = exports.isObject = node => node.type === OBJECT_PROPERTIES.OBJECT_EXPRESSION;\n\nconst isScopeCreator = exports.isScopeCreator = node => [INITIALIZATION_TYPES.PROGRAM, OBJECT_PROPERTIES.OBJECT_METHOD, CLASS_PROPERTIES.CLASS_METHOD, DECLARATION_TYPES.CLASS_DECLARATION, EXPRESSIONS_TYPES.CLASS_EXPRESSION, EXPRESSIONS_TYPES.OBJECT_EXPRESSION, STATEMENTS_TYPES.BLOCK_STATEMENT, EXPRESSIONS_TYPES.FUNCTION_EXPRESSION, DECLARATION_TYPES.FUNCTION_DECLARATION, ANNOTATION_TYPES.FUNCTION_TYPE_ANNOTATION, EXPRESSIONS_TYPES.ARROW_FUNCTION_EXPRESSION].includes(node.type);\n\nconst isFunction = exports.isFunction = node => [DECLARATION_TYPES.FUNCTION_DECLARATION, EXPRESSIONS_TYPES.FUNCTION_EXPRESSION, EXPRESSIONS_TYPES.ARROW_FUNCTION_EXPRESSION, ANNOTATION_TYPES.FUNCTION_TYPE_ANNOTATION, OBJECT_PROPERTIES.OBJECT_METHOD, CLASS_PROPERTIES.CLASS_METHOD].includes(node.type);\n\nconst isImport = exports.isImport = node => node.type === DECLARATION_TYPES.IMPORT_DECLARATION;\n\nexports.default = {\n  isImport,\n  isObject,\n  isFunction,\n  isScopeCreator,\n  isUnscopableDeclaration,\n  ...DECLARATION_TYPES,\n  ...STATEMENTS_TYPES,\n  ...ANNOTATION_TYPES,\n  ...EXPRESSIONS_TYPES,\n  ...INITIALIZATION_TYPES,\n  ...OBJECT_PROPERTIES,\n  ...CLASS_PROPERTIES,\n  ...LITERAL_TYPES,\n  ...SPECIFIERS_TYPES,\n  ...SPECIAL_TYPES\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.genericFunction = undefined;\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _bottomType = require(\"../type-graph/types/bottom-type\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nconst zeroMetaLocation = new _meta.Meta();\n\nconst genericFunction = exports.genericFunction = (typeScope, getGenericArguments, getTypeParameters, getReturnType) => {\n  const localTypeScope = new _typeScope.TypeScope(typeScope, _typeScope.TypeScope.MODULE_SCOPE_PRIORITY + 1);\n  let genericArguments = getGenericArguments(localTypeScope);\n  genericArguments.forEach(([key, type]) => localTypeScope.body.set(key, type));\n  genericArguments = genericArguments.map(([, t]) => Object.assign(t, {\n    isUserDefined: true\n  }));\n  const parametersTypes = getTypeParameters(localTypeScope);\n  const returnType = getReturnType(localTypeScope);\n  return _genericType.GenericType.term(_functionType.FunctionType.getName(parametersTypes, returnType, genericArguments), {\n    parent: typeScope\n  }, genericArguments, localTypeScope, _functionType.FunctionType.term(_functionType.FunctionType.getName(parametersTypes, returnType), {\n    parent: localTypeScope\n  }, parametersTypes, returnType));\n};\n\nconst mixBaseOperators = moduleScope => {\n  const typeScope = moduleScope.typeScope;\n  const operators = [[\"+\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {\n    parent: typeScope\n  }, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"-\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {\n    parent: typeScope\n  }, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"!\", _functionType.FunctionType.term(\"(boolean) => boolean\", {\n    parent: typeScope\n  }, [_type.Type.Boolean], _type.Type.Boolean)], [\"~\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {\n    parent: typeScope\n  }, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"typeof\", _functionType.FunctionType.term('(unknown) => \"string\" | \"boolean\" | \"number\" | \"function\" | \"object\" | \"undefined\" | \"symbol\" | \"bigint\"', {\n    parent: typeScope\n  }, [_type.Type.Unknown], _unionType.UnionType.term(\"'string' | 'boolean' | 'number' | 'function' | 'object' | 'undefined' | 'symbol' | 'bigint'\", {\n    parent: typeScope\n  }, [_type.Type.term(\"'string'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'number'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'boolean'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'undefined'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'object'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'bigint'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'symbol'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'function'\", {\n    isSubtypeOf: _type.Type.String\n  })]))], [\"void\", _functionType.FunctionType.term(\"(unknown) => undefined\", {\n    parent: typeScope\n  }, [_type.Type.Unknown], _type.Type.Undefined)], [\"delete\", _functionType.FunctionType.term(\"(unknown) => undefined\", {\n    parent: typeScope\n  }, [_type.Type.Unknown], _type.Type.Undefined)], typeScope.body.has(\"Promise\") ? [\"await\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [_unionType.UnionType.term(null, {}, [_type.Type.find(\"Promise\").applyGeneric([l.body.get(\"T\")]), l.body.get(\"T\")])], l => l.body.get(\"T\"))] : [\"await\", _functionType.FunctionType.term(\"(unknown) => unknown\", {\n    parent: typeScope\n  }, [_type.Type.Unknown], _type.Type.Unknown)], [\"==\", _functionType.FunctionType.term(\"(unknown, unknown) => boolean\", {\n    parent: typeScope\n  }, [_type.Type.Unknown, _type.Type.Unknown], _type.Type.Boolean)], [\"===\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => _type.Type.Boolean)], [\"!==\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => _type.Type.Boolean)], [\"!=\", _functionType.FunctionType.term(\"(unknown, unknown) => boolean\", {\n    parent: typeScope\n  }, [_type.Type.Unknown, _type.Type.Unknown], _type.Type.Boolean)], [\">=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], _ => _type.Type.Boolean)], [\"<=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], _ => _type.Type.Boolean)], [\">\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], _ => _type.Type.Boolean)], [\"<\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], _ => _type.Type.Boolean)], [\"b+\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number | string\", {}, [_type.Type.BigInt, _type.Type.Number, _type.Type.String]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"b-\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"/\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"%\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"|\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"&\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"*\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"^\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"**\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"<<\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\">>\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\">>>\", _functionType.FunctionType.term(\"(number, number) => number\", {\n    parent: typeScope\n  }, [_type.Type.Number, _type.Type.Number], _type.Type.Number)], [\"in\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _objectType.ObjectType.Object)]], l => [_type.Type.String, l.body.get(\"T\")], l => _type.Type.Boolean)], [\"instanceof\", _functionType.FunctionType.term(\"(unknown, unknown) => boolean\", {\n    parent: typeScope\n  }, [_type.Type.Unknown, _type.Type.Unknown], _type.Type.Boolean)], [\"=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"+=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number | string\", {}, [_type.Type.BigInt, _type.Type.Number, _type.Type.String]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"-=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"*=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"/=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"%=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"**=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\">>=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\">>>=\", _functionType.FunctionType.term(\"(number, number) => number\", {\n    parent: typeScope\n  }, [_type.Type.Number, _type.Type.Number], _type.Type.Number)], [\"<<=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"|=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"&=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], // Updates\n  [\"++\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"--\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [// Logical\n  \"&&\", genericFunction(typeScope, parent => [[\"A\", _typeVar.TypeVar.term(\"A\", {\n    parent\n  })], [\"B\", _typeVar.TypeVar.term(\"B\", {\n    parent\n  })]], l => [l.body.get(\"A\"), l.body.get(\"B\")], l => _unionType.UnionType.term(\"A | B\", {\n    parent: l\n  }, [l.body.get(\"A\"), l.body.get(\"B\")]))], [\"||\", genericFunction(typeScope, parent => [[\"A\", _typeVar.TypeVar.term(\"A\", {\n    parent\n  })], [\"B\", _typeVar.TypeVar.term(\"B\", {\n    parent\n  })]], l => [l.body.get(\"A\"), l.body.get(\"B\")], l => _unionType.UnionType.term(\"A | B\", {\n    parent: l\n  }, [l.body.get(\"A\"), l.body.get(\"B\")]))], [\"?:\", genericFunction(typeScope, parent => [[\"A\", _typeVar.TypeVar.term(\"A\", {\n    parent\n  })], [\"B\", _typeVar.TypeVar.term(\"B\", {\n    parent\n  })]], l => [_type.Type.Boolean, l.body.get(\"A\"), l.body.get(\"B\")], l => _unionType.UnionType.term(\"A | B\", {\n    parent: l\n  }, [l.body.get(\"A\"), l.body.get(\"B\")]))], [\"if\", _functionType.FunctionType.term(\"(boolean) => void\", {\n    parent: typeScope\n  }, [_type.Type.Boolean], _type.Type.Undefined)], [\"while\", _functionType.FunctionType.term(\"(boolean) => void\", {\n    parent: typeScope\n  }, [_type.Type.Boolean], _type.Type.Undefined)], [\"do-while\", _functionType.FunctionType.term(\"(boolean) => void\", {\n    parent: typeScope\n  }, [_type.Type.Boolean], _type.Type.Undefined)], [\"for\", _functionType.FunctionType.term(\"(?unknown, ?boolean, ?unknown) => void\", {\n    parent: typeScope\n  }, [_unionType.UnionType.term(\"undefined | unknown\", {}, [_type.Type.Undefined, _type.Type.Unknown]), _unionType.UnionType.term(\"boolean | undefined\", {}, [_type.Type.Boolean, _type.Type.Undefined]), _unionType.UnionType.term(\"undefined | unknown\", {}, [_type.Type.Undefined, _type.Type.Unknown])], _type.Type.Undefined)], [\"return\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"new\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"throw\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))]].forEach(([name, type]) => moduleScope.body.set(name, new _variableInfo.VariableInfo(type, moduleScope, zeroMetaLocation)));\n};\n\nexports.default = mixBaseOperators;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getScopeType = getScopeType;\nexports.findNearestScopeByType = findNearestScopeByType;\nexports.findNearestTypeScope = findNearestTypeScope;\nexports.getParentForNode = getParentForNode;\nexports.getScopeFromNode = getScopeFromNode;\nexports.addScopeToTypeGraph = addScopeToTypeGraph;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getScopeType(node) {\n  switch (node.type) {\n    case _nodes2.default.BLOCK_STATEMENT:\n      return _variableScope.VariableScope.BLOCK_TYPE;\n\n    case _nodes2.default.FUNCTION_DECLARATION:\n    case _nodes2.default.FUNCTION_EXPRESSION:\n    case _nodes2.default.ARROW_FUNCTION_EXPRESSION:\n    case _nodes2.default.OBJECT_METHOD:\n    case _nodes2.default.CLASS_METHOD:\n    case _nodes2.default.FUNCTION_TYPE_ANNOTATION:\n      return _variableScope.VariableScope.FUNCTION_TYPE;\n\n    case _nodes2.default.OBJECT_EXPRESSION:\n      return _variableScope.VariableScope.OBJECT_TYPE;\n\n    case _nodes2.default.CLASS_DECLARATION:\n    case _nodes2.default.CLASS_EXPRESSION:\n      return _variableScope.VariableScope.CLASS_TYPE;\n  }\n\n  throw new Error(\"Never for getScopeType\");\n}\n\nfunction findNearestScopeByType(type, parentContext) {\n  type = Array.isArray(type) ? type : [type];\n  let parent = parentContext;\n\n  while (parent instanceof _variableScope.VariableScope) {\n    if (type.includes(parent.type)) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  }\n\n  return parent;\n}\n\nfunction findNearestTypeScope(currentScope, typeGraph) {\n  let scope = findNearestScopeByType([_variableScope.VariableScope.FUNCTION_TYPE, _variableScope.VariableScope.CLASS_TYPE], currentScope);\n\n  do {\n    if (scope.declaration instanceof _variableInfo.VariableInfo) {\n      if (\"localTypeScope\" in scope.declaration.type) {\n        // $FlowIssue\n        return scope.declaration.type.localTypeScope;\n      }\n\n      if (scope.declaration.type.instanceType != undefined && scope.declaration.type.instanceType.subordinateMagicType != undefined && \"localTypeScope\" in // $FlowIssue\n      scope.declaration.type.instanceType.subordinateMagicType) {\n        return (// $FlowIssue\n          scope.declaration.type.instanceType.subordinateMagicType.localTypeScope\n        );\n      }\n    }\n\n    const parent = scope.parent;\n\n    if (parent === null) {\n      break;\n    }\n\n    scope = findNearestScopeByType([_variableScope.VariableScope.FUNCTION_TYPE, _variableScope.VariableScope.CLASS_TYPE], parent);\n  } while (scope.parent instanceof _variableScope.VariableScope);\n\n  return typeGraph.typeScope;\n}\n\nfunction getParentForNode(currentNode, parentNode, typeGraph) {\n  if (!parentNode || parentNode.type === _nodes2.default.PROGRAM) {\n    return typeGraph;\n  }\n\n  const name = _variableScope.VariableScope.getName(parentNode);\n\n  const scope = typeGraph.scopes.get(name);\n\n  if (scope === undefined) {\n    return typeGraph;\n  }\n\n  if (_nodes2.default.isUnscopableDeclaration(currentNode)) {\n    return findNearestScopeByType(_variableScope.VariableScope.FUNCTION_TYPE, scope || typeGraph);\n  }\n\n  return scope;\n}\n\nfunction getScopeFromNode(currentNode, parentNode, typeGraph, declaration, scopeCreator) {\n  return new _variableScope.VariableScope(getScopeType(currentNode), parentNode instanceof _variableScope.VariableScope || parentNode instanceof _moduleScope.ModuleScope ? parentNode : getParentForNode(currentNode, parentNode, typeGraph), declaration, scopeCreator, currentNode.skipCalls !== undefined);\n}\n\nfunction addScopeToTypeGraph(currentNode, parentNode, typeGraph, creator) {\n  const scopeName = _variableScope.VariableScope.getName(currentNode);\n\n  if (typeGraph.scopes.has(scopeName)) {\n    return;\n  }\n\n  typeGraph.scopes.set(scopeName, getScopeFromNode(currentNode, parentNode, typeGraph, undefined, getScopeCreator(creator)));\n}\n\nfunction getScopeCreator(creator) {\n  switch (creator.type) {\n    case _nodes2.default.IF_STATEMENT:\n      return \"if\";\n\n    case _nodes2.default.WHILE_STATEMENT:\n      return \"while\";\n\n    case _nodes2.default.DO_WHILE_STATEMENT:\n      return \"do-while\";\n\n    case _nodes2.default.FOR_STATEMENT:\n      return \"for\";\n\n    case _nodes2.default.FOR_OF_STATEMENT:\n      return \"for-of\";\n\n    case _nodes2.default.FOR_IN_STATEMENT:\n      return \"for-in\";\n\n    case _nodes2.default.BLOCK_STATEMENT:\n      return \"block\";\n\n    case _nodes2.default.SWITCH_CASE:\n      return creator.test === null ? \"default-case\" : \"case\";\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findThrowableBlock = findThrowableBlock;\nexports.addToThrowable = addToThrowable;\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nfunction findThrowableBlock(parentScope) {\n  if (!parentScope || !(parentScope instanceof _variableScope.VariableScope)) {\n    return null;\n  }\n\n  let parent = parentScope;\n\n  do {\n    if (parent.throwable) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  } while (parent !== null);\n\n  return null;\n}\n\nfunction addToThrowable(throwType, currentScope) {\n  const throwableScope = findThrowableBlock(currentScope);\n\n  if (!throwableScope || !(currentScope instanceof _variableScope.VariableScope) || !throwableScope.throwable) {\n    return;\n  }\n\n  throwableScope.throwable.push(throwType);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compose = undefined;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _common = require(\"../utils/common\");\n\nvar _errors = require(\"./errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst compose = exports.compose = (...fns) => (...args) => {\n  const additionalArgs = args.slice(1);\n  return fns.reduce((res, fn) => fn(res, ...additionalArgs), args[0]);\n};\n\nfunction mixBodyToArrowFunctionExpression(currentNode) {\n  if (currentNode.type !== _nodes2.default.ARROW_FUNCTION_EXPRESSION || currentNode.body.type === _nodes2.default.BLOCK_STATEMENT) {\n    return currentNode;\n  }\n\n  currentNode.body = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: [{\n      type: _nodes2.default.RETURN_STATEMENT,\n      argument: currentNode.body,\n      loc: currentNode.body.loc\n    }],\n    loc: currentNode.body.loc\n  };\n  return currentNode;\n}\n\nfunction sortClassMembers(currentNode) {\n  if (currentNode.type !== _nodes2.default.CLASS_DECLARATION && currentNode.type !== _nodes2.default.CLASS_EXPRESSION) {\n    return currentNode;\n  }\n\n  currentNode.body.body.sort((a, b) => a.kind === \"constructor\" ? -1 : 1);\n  return currentNode;\n}\n\nfunction mixBlockToLogicalOperator(currentNode) {\n  if (currentNode.type !== _nodes2.default.LOGICAL_EXPRESSION || currentNode.operator !== \"&&\" && currentNode.operator !== \"||\" || currentNode.left.type === _nodes2.default.BLOCK_STATEMENT) {\n    return currentNode;\n  }\n\n  currentNode.left = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: currentNode.left,\n    loc: {\n      start: currentNode.loc.start,\n      end: currentNode.loc.start\n    }\n  };\n  currentNode.right = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: currentNode.right,\n    loc: {\n      start: currentNode.loc.end,\n      end: currentNode.loc.end\n    }\n  };\n  return currentNode;\n}\n\nfunction mixBlockToConditionalExpression(currentNode) {\n  if (currentNode.type !== _nodes2.default.CONDITIONAL_EXPRESSION || currentNode.consequent.type === _nodes2.default.BLOCK_STATEMENT) {\n    return currentNode;\n  }\n\n  currentNode.consequent = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: currentNode.consequent,\n    loc: {\n      start: currentNode.loc.start,\n      end: currentNode.loc.start\n    }\n  };\n  currentNode.alternate = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: currentNode.alternate,\n    loc: {\n      start: currentNode.loc.end,\n      end: currentNode.loc.end\n    }\n  };\n  return currentNode;\n}\n\nfunction mixBlockForStatements(currentNode) {\n  if (currentNode.type !== _nodes2.default.IF_STATEMENT && currentNode.type !== _nodes2.default.WHILE_STATEMENT && currentNode.type !== _nodes2.default.FOR_STATEMENT && currentNode.type !== _nodes2.default.FOR_IN_STATEMENT && currentNode.type !== _nodes2.default.FOR_OF_STATEMENT) {\n    return currentNode;\n  }\n\n  if (currentNode.type === _nodes2.default.IF_STATEMENT && currentNode.alternate && currentNode.alternate.type !== _nodes2.default.BLOCK_STATEMENT) {\n    currentNode.alternate = {\n      type: _nodes2.default.BLOCK_STATEMENT,\n      body: [currentNode.alternate],\n      loc: currentNode.alternate.loc\n    };\n  }\n\n  const propertyName = currentNode.type === _nodes2.default.IF_STATEMENT ? \"consequent\" : \"body\";\n\n  if (currentNode[propertyName].type === _nodes2.default.BLOCK_STATEMENT) {\n    return currentNode;\n  }\n\n  currentNode[propertyName] = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: [currentNode[propertyName]],\n    loc: currentNode[propertyName].loc\n  };\n  return currentNode;\n}\n\nfunction getInitFor(node) {\n  switch (node.type) {\n    case _nodes2.default.FOR_IN_STATEMENT:\n      return {\n        type: _nodes2.default.PURE_KEY,\n        of: node.right\n      };\n\n    case _nodes2.default.FOR_OF_STATEMENT:\n      return {\n        type: _nodes2.default.VALUE,\n        of: node.right\n      };\n\n    default:\n      return;\n  }\n}\n\nfunction mixBlockToCaseStatement(currentNode) {\n  if (currentNode.type !== _nodes2.default.SWITCH_STATEMENT) {\n    return currentNode;\n  }\n\n  for (let i = 0; i < currentNode.cases.length; i++) {\n    const $case = currentNode.cases[i];\n    const body = $case.consequent.body || $case.consequent;\n    $case.parent = currentNode;\n    $case.consequent = {\n      type: _nodes2.default.BLOCK_STATEMENT,\n      loc: $case.loc,\n      body\n    };\n  }\n\n  return currentNode;\n}\n\nfunction mixDeclarationsInideForBlock(currentNode, parentNode) {\n  if (currentNode.type !== _nodes2.default.FOR_IN_STATEMENT && currentNode.type !== _nodes2.default.FOR_OF_STATEMENT && (currentNode.type !== _nodes2.default.FOR_STATEMENT || currentNode.init === null) || parentNode.isCustom) {\n    return currentNode;\n  }\n\n  const init = currentNode.init || { ...currentNode.left,\n    init: getInitFor(currentNode)\n  };\n  return {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: [init, currentNode],\n    isCustom: true,\n    loc: init.loc\n  };\n}\n\nfunction mixExportInfo(currentNode) {\n  if (currentNode.type !== _nodes2.default.EXPORT_NAMED_DECLARATION && currentNode.type !== _nodes2.default.EXPORT_DEFAULT_DECLARATION) {\n    return currentNode;\n  }\n\n  if (currentNode.declaration == null) {\n    return {\n      type: _nodes2.default.EXPORT_LIST,\n      exportKind: currentNode.exportKind,\n      specifiers: currentNode.specifiers\n    };\n  }\n\n  return currentNode.declaration.type !== _nodes2.default.VARIABLE_DECLARATION ? { ...currentNode.declaration,\n    exportAs: currentNode.type === _nodes2.default.EXPORT_DEFAULT_DECLARATION ? \"default\" : currentNode.declaration.id.name\n  } : { ...currentNode.declaration,\n    declarations: currentNode.declaration.declarations.map(declaration => ({ ...declaration,\n      exportAs: declaration.id.name\n    }))\n  };\n}\n\nfunction mixTryCatchInfo(currentNode) {\n  if (currentNode.type !== _nodes2.default.TRY_STATEMENT) {\n    return currentNode;\n  }\n\n  return { ...currentNode,\n    block: { ...currentNode.block,\n      catchBlock: currentNode.handler\n    }\n  };\n}\n\nfunction mixParentToClassObjectAndFunction(currentNode, parentNode) {\n  if (typeof currentNode === \"object\" && currentNode !== null && (currentNode.type === _nodes2.default.CLASS_DECLARATION || currentNode.type === _nodes2.default.FUNCTION_DECLARATION)) {\n    currentNode.parentNode = parentNode;\n  }\n\n  return currentNode;\n}\n\nfunction removeNodesWhichConteindInElse(alternateBody, inferencedBody) {\n  for (let i = 0; i < inferencedBody.length; i++) {\n    if (alternateBody.includes(inferencedBody[i])) {\n      inferencedBody[i] = undefined;\n    }\n  }\n}\n\nfunction mixElseIfReturnOrThrowExisted(currentNode, parentNode, {\n  previousBodyState = []\n}) {\n  if (parentNode === undefined || currentNode.type !== _nodes2.default.IF_STATEMENT || currentNode.consequent.body.findIndex(node => node.type === _nodes2.default.RETURN_STATEMENT || node.type === _nodes2.default.BREAK_STATEMENT || node.type === _nodes2.default.CONTINUE_STATEMENT || node.type === _nodes2.default.THROW_STATEMENT) === -1) {\n    return currentNode;\n  }\n\n  const body = parentNode.body.body || parentNode.body;\n\n  if (!Array.isArray(body)) {\n    return currentNode;\n  }\n\n  const indexOfSlice = body.indexOf(currentNode);\n\n  if (indexOfSlice === -1) {\n    return currentNode;\n  }\n\n  const alternate = currentNode.alternate || {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    skipCalls: true,\n    body: [],\n    loc: {\n      start: currentNode.loc.end,\n      end: currentNode.loc.end\n    }\n  };\n  const inferencedAlternate = body.splice(indexOfSlice + 1);\n  alternate.body = alternate.body.concat(inferencedAlternate);\n  removeNodesWhichConteindInElse(inferencedAlternate, previousBodyState);\n  return { ...currentNode,\n    alternate\n  };\n}\n\nconst getBody = currentNode => [...(0, _common.ensureArray)(currentNode.body), ...(0, _common.ensureArray)(currentNode.declarations), ...(0, _common.ensureArray)(currentNode.properties), currentNode.block, currentNode.handler, currentNode.test, currentNode.finalizer, currentNode.alternate, currentNode.value, currentNode.init && currentNode.init.callee, currentNode.init, currentNode.object, currentNode.property, currentNode.left, currentNode.right, currentNode.argument, currentNode.expression && currentNode.expression.callee, currentNode.expression, currentNode.callee, ...(0, _common.ensureArray)(currentNode.elements), ...(0, _common.ensureArray)(currentNode.cases), ...(0, _common.ensureArray)(currentNode.expressions), ...(0, _common.ensureArray)(currentNode.arguments).filter(a => !_nodes2.default.isFunction(a)), ...(0, _common.ensureArray)(currentNode.consequent)].filter(Boolean);\n\nconst getNextParent = (currentNode, parentNode) => parentNode && (_nodes2.default.isFunction(parentNode) && currentNode === parentNode.body || _nodes2.default.isScopeCreator(parentNode) && !_nodes2.default.isScopeCreator(currentNode)) ? parentNode : currentNode;\n\nconst getCurrentNode = compose(mixDeclarationsInideForBlock, mixBodyToArrowFunctionExpression, mixTryCatchInfo, mixBlockForStatements, mixExportInfo, mixBlockToLogicalOperator, mixElseIfReturnOrThrowExisted, mixBlockToConditionalExpression, mixBlockToCaseStatement, mixParentToClassObjectAndFunction, sortClassMembers);\n\nfunction traverseTree(node, pre, middle, post, parentNode = null, meta) {\n  try {\n    const currentNode = getCurrentNode(node, parentNode, meta);\n    const shouldContinueTraversing = pre(currentNode, parentNode, pre, middle, post, meta);\n\n    if (!shouldContinueTraversing) {\n      return;\n    }\n\n    const body = getBody(currentNode);\n    const nextParent = getNextParent(currentNode, parentNode);\n    let i = 0;\n    const newMeta = { ...meta,\n      previousBodyState: body,\n      kind: currentNode.kind\n    };\n\n    try {\n      for (i = 0; i < body.length; i++) {\n        const node = body[i];\n\n        if (node !== undefined) {\n          middle(node, nextParent, pre, middle, post, newMeta);\n        }\n      }\n\n      for (i = 0; i < body.length; i++) {\n        const node = body[i];\n\n        if (node !== undefined) {\n          traverseTree(node, pre, middle, post, nextParent, newMeta);\n        }\n      }\n    } catch (e) {\n      if (!(e instanceof _errors.UnreachableError)) {\n        throw e;\n      }\n\n      if (i < body.length - 1) {\n        meta.errors.push(new _errors2.default(\"Unreachable code after this line\", e.loc));\n        return;\n      }\n    }\n\n    post(currentNode, parentNode, pre, middle, post, newMeta);\n  } catch (e) {\n    if (e instanceof Error && !(e instanceof _errors2.default)) {\n      throw e;\n    }\n\n    if (Array.isArray(e)) {\n      meta.errors.push(...e);\n    } else {\n      meta.errors.push(e);\n    }\n  }\n}\n\nexports.default = traverseTree;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addTypeNodeToTypeGraph = addTypeNodeToTypeGraph;\nexports.isReachableType = isReachableType;\nexports.addTypeVar = addTypeVar;\nexports.getTypeFromTypeAnnotation = getTypeFromTypeAnnotation;\nexports.mergeObjectsTypes = mergeObjectsTypes;\nexports.createObjectWith = createObjectWith;\nexports.get = get;\nexports.createSelf = createSelf;\nexports.getWrapperType = getWrapperType;\nexports.getFalsy = getFalsy;\nexports.pickFalsy = pickFalsy;\nexports.pickTruthy = pickTruthy;\nexports.isFalsy = isFalsy;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"./errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _bottomType = require(\"../type-graph/types/bottom-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _throwsType = require(\"../type-graph/types/throws-type\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _intersectionType = require(\"../type-graph/types/intersection-type\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _common = require(\"./common\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _constants = require(\"../type-graph/constants\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addTypeNodeToTypeGraph(currentNode, typeGraph) {\n  const name = (0, _common.getDeclarationName)(currentNode);\n  typeGraph.typeScope.body.set(name, currentNode);\n}\n\nfunction isReachableType(type, typeScope) {\n  if (typeScope === null) {\n    return false;\n  }\n\n  let reachableType = null;\n\n  try {\n    reachableType = _type.Type.find(type.name, {\n      parent: typeScope\n    });\n  } catch {}\n\n  return reachableType !== null && type.equalsTo(reachableType);\n}\n\nfunction addTypeVar(name, localTypeScope, constraint, defaultType, isUserDefined = false) {\n  return _typeVar.TypeVar.new(name, {\n    parent: localTypeScope\n  }, constraint, defaultType, isUserDefined);\n}\n\nfunction nullable(annotation) {\n  return annotation.optional ? {\n    typeAnnotation: { ...annotation.typeAnnotation,\n      type: _nodes2.default.NULLABLE_TYPE_ANNOTATION\n    }\n  } : annotation.typeAnnotation;\n}\n\nfunction getTypeFromTypeAnnotation(typeNode, typeScope, currentScope, rewritable = true, self = null, parentNode, typeGraph, precompute, middlecompute, postcompute, customName) {\n  if (!typeNode || !typeNode.typeAnnotation) {\n    return _type.Type.Unknown;\n  }\n\n  if (typeNode.typeAnnotation.type === _nodes2.default.TS_PARENTHESIZED_TYPE) {\n    typeNode.typeAnnotation = typeNode.typeAnnotation.typeAnnotation;\n  }\n\n  switch (typeNode.typeAnnotation.type) {\n    case _nodes2.default.ARRAY_TYPE_ANNOTATION:\n      const elementType = getTypeFromTypeAnnotation({\n        typeAnnotation: typeNode.typeAnnotation.elementType\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      throw new _errors2.default(`Array type annotation does not exist in Hegel. Use Array<${String(elementType.name)}> instead.`, typeNode.typeAnnotation.loc);\n\n    case _nodes2.default.THIS_TYPE_ANNOTATION:\n    case _nodes2.default.TS_THIS_TYPE_ANNOTATION:\n      if (self === null || self === undefined) {\n        throw new _errors2.default(\"Can not use `this` type without context\", typeNode.loc);\n      }\n\n      return self;\n\n    case _nodes2.default.TS_TYPE_OPERATOR:\n      const res = getTypeFromTypeAnnotation({\n        typeAnnotation: typeNode.typeAnnotation.typeAnnotation\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      return typeNode.typeAnnotation.operator === \"readonly\" ? _type.Type.find(_immutableType.$Immutable.name).applyGeneric([res], typeNode.typeAnnotation.loc) : res;\n\n    case _nodes2.default.TS_LITERAL_TYPE:\n      return getTypeFromTypeAnnotation({\n        typeAnnotation: typeNode.typeAnnotation.literal\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n    case _nodes2.default.ANY_TYPE_ANNOTATION:\n      throw new _errors2.default('There is no \"any\" type in Hegel. Use \"unknown\" instead.', typeNode.typeAnnotation.loc);\n\n    case _nodes2.default.VOID_TYPE_ANNOTATION:\n      throw new _errors2.default('There is no \"void\" type in Hegel. Use \"undefined\" instead.', typeNode.typeAnnotation.loc);\n\n    case _nodes2.default.TYPEOF_TYPE_ANNOTATION:\n      throw new _errors2.default(\"typeof for types does not exist in Hegel. Use magic type $TypeOf instead.\", typeNode.typeAnnotation.loc);\n\n    case _nodes2.default.SYMBOL_TYPE_ANNOTATION:\n    case _nodes2.default.TS_SYMBOL_TYPE_ANNOTATION:\n      return _type.Type.Symbol;\n\n    case _nodes2.default.TS_BIGINT_TYPE_ANNOTATION:\n      return _type.Type.BigInt;\n\n    case _nodes2.default.TS_UNDEFINED_TYPE_ANNOTATION:\n      return _type.Type.Undefined;\n\n    case _nodes2.default.TS_OBJECT_KEYWORD:\n      return _objectType.ObjectType.Object;\n\n    case _nodes2.default.VOID_TYPE_ANNOTATION:\n    case _nodes2.default.TS_VOID_TYPE_ANNOTATION:\n      return _type.Type.Undefined;\n\n    case _nodes2.default.TYPE_GUARD:\n    case _nodes2.default.BOOLEAN_TYPE_ANNOTATION:\n    case _nodes2.default.TS_BOOLEAN_TYPE_ANNOTATION:\n      return _unionType.UnionType.Boolean;\n\n    case _nodes2.default.TS_ANY_TYPE_ANNOTATION:\n    case _nodes2.default.MIXED_TYPE_ANNOTATION:\n    case _nodes2.default.TS_UNKNOWN_TYPE_ANNOTATION:\n    case _nodes2.default.TS_ANY_TYPE_ANNOTATION:\n      return _type.Type.Unknown;\n\n    case _nodes2.default.EMPTY_TYPE_ANNOTATION:\n    case _nodes2.default.TS_NEVER_TYPE_ANNOTATION:\n      return _type.Type.Never;\n\n    case _nodes2.default.NUMBER_TYPE_ANNOTATION:\n    case _nodes2.default.TS_NUMBER_TYPE_ANNOTATION:\n      return _type.Type.Number;\n\n    case _nodes2.default.STRING_TYPE_ANNOTATION:\n    case _nodes2.default.TS_STRING_TYPE_ANNOTATION:\n      return _type.Type.String;\n\n    case _nodes2.default.NULL_LITERAL_TYPE_ANNOTATION:\n    case _nodes2.default.TS_NULL_LITERAL_TYPE_ANNOTATION:\n      return _type.Type.Null;\n\n    case _nodes2.default.NUMBER_LITERAL_TYPE_ANNOTATION:\n    case _nodes2.default.NUMERIC_LITERAL:\n      return _type.Type.term(typeNode.typeAnnotation.value, {\n        isSubtypeOf: _type.Type.Number\n      });\n\n    case _nodes2.default.BIGINT_LITERAL_TYPE_ANNOTATION:\n    case _nodes2.default.BIGINT_LITERAL:\n      return _type.Type.term(typeNode.typeAnnotation.value, {\n        isSubtypeOf: _type.Type.BigInt\n      });\n\n    case _nodes2.default.BOOLEAN_LITERAL_TYPE_ANNOTATION:\n    case _nodes2.default.BOOLEAN_LITERAL:\n      return _type.Type.term(typeNode.typeAnnotation.value);\n\n    case _nodes2.default.STRING_LITERAL_TYPE_ANNOTATION:\n    case _nodes2.default.STRING_LITERAL:\n      return _type.Type.term(`'${typeNode.typeAnnotation.value}'`, {\n        isSubtypeOf: _type.Type.String\n      });\n\n    case _nodes2.default.TS_SYMBOL_TYPE_ANNOTATION:\n      return _type.Type.Symbol;\n\n    case _nodes2.default.TS_INTERSECTION_TYPE:\n      const objects = typeNode.typeAnnotation.types.map(typeAnnotation => getTypeFromTypeAnnotation({\n        typeAnnotation\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n      return _type.Type.find(_intersectionType.$Intersection.name).applyGeneric(objects, typeNode.loc);\n\n    case _nodes2.default.NULLABLE_TYPE_ANNOTATION:\n      const resultType = getTypeFromTypeAnnotation(typeNode.typeAnnotation, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      return _unionType.UnionType.term(null, {}, [resultType, _type.Type.Undefined]);\n\n    case _nodes2.default.TS_OBJECT_PROPERTY:\n      const result = getTypeFromTypeAnnotation( // Ohhh, TS is beautiful ❤️\n      nullable(typeNode.typeAnnotation), typeScope, currentScope, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      return typeNode.typeAnnotation.readonly ? _type.Type.find(_immutableType.$Immutable.name).applyGeneric([result], typeNode.typeAnnotation.loc) : result;\n\n    case _nodes2.default.UNION_TYPE_ANNOTATION:\n    case _nodes2.default.TS_UNION_TYPE_ANNOTATION:\n      const unionVariants = typeNode.typeAnnotation.types.map(typeAnnotation => getTypeFromTypeAnnotation({\n        typeAnnotation\n      }, typeScope, currentScope, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n      return _unionType.UnionType.term(null, {}, unionVariants);\n\n    case _nodes2.default.TUPLE_TYPE_ANNOTATION:\n    case _nodes2.default.TS_TUPLE_TYPE_ANNOTATION:\n      const tupleVariants = (typeNode.typeAnnotation.types || typeNode.typeAnnotation.elementTypes).map(typeAnnotation => getTypeFromTypeAnnotation({\n        typeAnnotation\n      }, typeScope, currentScope, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n      return _tupleType.TupleType.term(_tupleType.TupleType.getName(tupleVariants), {}, tupleVariants);\n\n    case _nodes2.default.TYPE_PARAMETER:\n    case _nodes2.default.TS_TYPE_PARAMETER:\n      const constraint = typeNode.typeAnnotation.bound && getTypeFromTypeAnnotation(typeNode.typeAnnotation.bound, typeScope, currentScope, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      const defaultType = typeNode.typeAnnotation.default && getTypeFromTypeAnnotation({\n        typeAnnotation: typeNode.typeAnnotation.default\n      }, typeScope, currentScope, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n      if (constraint && defaultType && !constraint.isPrincipalTypeFor(defaultType)) {\n        throw new _errors2.default(`Type \"${String(defaultType.name)}\" is incompatible with type \"${String(constraint.name)}\"`, typeNode.typeAnnotation.default.loc);\n      }\n\n      return addTypeVar(typeNode.typeAnnotation.name, typeScope, constraint, defaultType, true);\n\n    case _nodes2.default.TS_INDEX_PROPERTY:\n      const key = getTypeFromTypeAnnotation(typeNode.typeAnnotation.parameters[0].typeAnnotation, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      const value = getTypeFromTypeAnnotation( // Ohhh, TS is beautiful ❤️\n      typeNode.typeAnnotation.typeAnnotation, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      return new _collectionType.CollectionType(\"\", {\n        parent: key.parent.priority > value.parent.priority ? key.parent : value.parent\n      }, key, value);\n\n    case _nodes2.default.OBJECT_TYPE_ANNOTATION:\n      if (typeNode.typeAnnotation.exact) {\n        throw new _errors2.default(\"Hegel has another syntax for strict (exact) object type. You should use pure object literal type for strict (exact)\\\n         object and object liter with three dots (...) for soft (inexact) object type\", typeNode.typeAnnotation.loc);\n      }\n\n    case _nodes2.default.TS_OBJECT_TYPE_ANNOTATION:\n    case _nodes2.default.TS_INTERFACE_DECLARATION:\n      const {\n        typeAnnotation: annotation\n      } = typeNode;\n      const objectBody = annotation.body || annotation;\n      const isSoft = annotation.type === _nodes2.default.TS_INTERFACE_DECLARATION || annotation.inexact;\n      const properties = objectBody.properties || objectBody.body || objectBody.members;\n      const superTypes = (annotation.extends || []).map(node => getTypeFromTypeAnnotation({\n        typeAnnotation: node\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n      const isNotTypeDefinition = annotation.type === _nodes2.default.OBJECT_TYPE_ANNOTATION;\n      const params = properties.flatMap(property => {\n        if (property.type === _nodes2.default.OBJECT_TYPE_SPREAD_PROPERTY) {\n          const spreadType = getTypeFromTypeAnnotation({\n            typeAnnotation: property.argument\n          }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n          if (!(spreadType instanceof _objectType.ObjectType)) {\n            throw new _errors2.default(\"Cannot spread non-object type\", property.loc);\n          }\n\n          return [...spreadType.properties];\n        }\n\n        if (isNotTypeDefinition && property.optional) {\n          throw new _errors2.default(\"Hegel has not optional property syntax. Use optional type instead.\", property.loc);\n        }\n\n        return [[getPropertyName(property), getTypeFromTypeAnnotation({\n          typeAnnotation: property.value || property\n        }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute)]];\n      });\n\n      if (customName === undefined) {\n        customName = annotation.id != undefined ? annotation.id.name : _objectType.ObjectType.getName(params, undefined, isSoft);\n      }\n\n      const resultObj = _objectType.ObjectType.term(customName, {\n        isSoft\n      }, params.map(([name, type]) => [name, type instanceof _variableInfo.VariableInfo ? type : new _variableInfo.VariableInfo(type, currentScope)]).concat(superTypes.reduce((res, type, index) => res.concat([...getPropertiesForType(type, annotation.extends[index])]), [])));\n\n      const constructor = resultObj.properties.get(_constants.CONSTRUCTABLE);\n\n      if (constructor !== undefined) {\n        const constructorType = constructor.type instanceof _genericType.GenericType ? constructor.type.subordinateType : constructor.type;\n        resultObj.instanceType = constructorType.returnType;\n      }\n\n      return getResultObjectType(resultObj);\n\n    case _nodes2.default.TS_ARRAY_TYPE_ANNOTATION:\n      return getTypeFromTypeAnnotation({\n        typeAnnotation: {\n          type: _nodes2.default.TS_TYPE_REFERENCE_ANNOTATION,\n          id: {\n            name: \"Array\"\n          },\n          typeParameters: {\n            params: [typeNode.typeAnnotation.elementType]\n          }\n        }\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n    case _nodes2.default.TS_TYPE_QUERY:\n      typeNode.typeAnnotation = {\n        loc: typeNode.typeAnnotation.loc,\n        type: _nodes2.default.GENERIC_TYPE_ANNOTATION,\n        id: {\n          name: \"$TypeOf\"\n        },\n        typeParameters: {\n          params: [{\n            id: typeNode.typeAnnotation.exprName\n          }]\n        }\n      };\n\n    case _nodes2.default.GENERIC_TYPE_ANNOTATION:\n    case _nodes2.default.CLASS_IMPLEMENTS:\n    case _nodes2.default.TS_TYPE_REFERENCE_ANNOTATION:\n    case _nodes2.default.TS_EXPRESSION_WITH_TYPE_ARGUMENTS:\n      const target = typeNode.typeAnnotation || typeNode;\n      const genericArguments = target.typeParameters && target.typeParameters.params;\n      const genericId = target.id || target.typeName || target.expression;\n      const genericName = genericId.name;\n\n      if (genericArguments != undefined) {\n        const typeInScope = _type.Type.find(genericName, {\n          parent: typeScope,\n          loc: target.loc\n        }, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n        const existedGenericType = typeInScope instanceof _typeVar.TypeVar && typeInScope.root != undefined ? typeInScope.root : typeInScope;\n\n        if (!existedGenericType || !(existedGenericType instanceof _genericType.GenericType) && !_typeVar.TypeVar.isSelf(existedGenericType)) {\n          throw new _errors2.default(`Apply undeclareted generic type '${genericName}'`, typeNode.typeAnnotation.loc);\n        }\n\n        if (existedGenericType.name === \"$TypeOf\") {\n          if (genericArguments.length !== 1 || genericArguments[0].id == undefined || genericArguments[0].id.type !== _nodes2.default.IDENTIFIER) {\n            throw new _errors2.default(`\"${existedGenericType.name}\" work only with identifier`, typeNode.typeAnnotation.loc);\n          }\n\n          return existedGenericType.applyGeneric( // $FlowIssue\n          [currentScope.findVariable(genericArguments[0].id)], typeNode.typeAnnotation.loc, false);\n        }\n\n        const genericParams = genericArguments.map(arg => getTypeFromTypeAnnotation({\n          typeAnnotation: arg\n        }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n        return genericParams.some(t => t instanceof _typeVar.TypeVar && t !== self) || _typeVar.TypeVar.isSelf(existedGenericType) ? new _bottomType.$BottomType({\n          parent: existedGenericType.parent\n        }, existedGenericType, genericParams, typeNode.typeAnnotation.loc) : // $FlowIssue\n        existedGenericType.applyGeneric(genericParams, typeNode.typeAnnotation.loc);\n      }\n\n      if (!rewritable) {\n        const typeInScope = _type.Type.find(genericName, {\n          parent: typeScope,\n          loc: target.loc\n        }, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n        if (typeInScope.shouldBeUsedAsGeneric) {\n          throw new _errors2.default(`Generic type \"${String(typeInScope.name)}\" should be used with type paramteres!`, target.loc);\n        }\n\n        return typeInScope instanceof _typeVar.TypeVar && typeInScope.root != undefined ? typeInScope.root : typeInScope;\n      }\n\n      const typeInScope = _type.Type.find(genericName, {\n        parent: typeScope,\n        loc: target.loc\n      });\n\n      if (typeInScope.shouldBeUsedAsGeneric) {\n        throw new _errors2.default(`Generic type \"${String(typeInScope.name)}\" should be used with type paramteres!`, target.loc);\n      }\n\n      const applicationResultType = _type.Type.getTypeRoot(typeInScope);\n\n      if (typeGraph instanceof _moduleScope.PositionedModuleScope) {\n        typeGraph.addPosition(genericId, applicationResultType);\n      }\n\n      return applicationResultType;\n\n    case _nodes2.default.TS_OBJECT_METHOD:\n    case _nodes2.default.FUNCTION_TYPE_ANNOTATION:\n    case _nodes2.default.TS_CALL_SIGNATURE_DECLARATION:\n    case _nodes2.default.TS_CONSTRUCT_SIGNATURE_DECLARATION:\n    case _nodes2.default.TS_FUNCTION_TYPE_ANNOTATION:\n      const localTypeScope = new _typeScope.TypeScope(typeScope);\n      const genericParams = typeNode.typeAnnotation.typeParameters ? typeNode.typeAnnotation.typeParameters.params.map(param => getTypeFromTypeAnnotation({\n        typeAnnotation: param\n      }, localTypeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute)) : [];\n      const {\n        params: paramsNode,\n        parameters,\n        rest\n      } = typeNode.typeAnnotation;\n      const argNodes = [...(paramsNode || parameters), rest && { ...rest,\n        type: _nodes2.default.REST_ELEMENT\n      }];\n      const args = argNodes.reduce((res, annotation) => {\n        if (annotation == undefined) {\n          return res;\n        }\n\n        const result = getTypeFromTypeAnnotation( // Ohhh, TS is beautiful ❤️\n        annotation.typeAnnotation.type === _nodes2.default.TS_TYPE_ANNOTATION ? nullable(annotation) : annotation, localTypeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n        return [...res, annotation.type === _nodes2.default.REST_ELEMENT ? _functionType.RestArgument.term(null, {}, result) : result];\n      }, []);\n      const {\n        returnType: returnTypeNode\n      } = typeNode.typeAnnotation;\n      let throwableType;\n      let returnType = getTypeFromTypeAnnotation(returnTypeNode ? {\n        typeAnnotation: returnTypeNode\n      } : // Ohhh, TS is beautiful ❤️\n      typeNode.typeAnnotation.typeAnnotation, localTypeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n      if (returnType instanceof _throwsType.$ThrowsResult || returnType instanceof _unionType.UnionType) {\n        if (returnType instanceof _unionType.UnionType) {\n          const [returnTypes, errors] = returnType.variants.reduce(([result, errors], type) => type instanceof _throwsType.$ThrowsResult ? [result, [...errors, type.errorType]] : [[...result, type], errors], [[], []]);\n\n          if (errors.length !== 0) {\n            returnType = _unionType.UnionType.term(null, {}, returnTypes);\n            throwableType = new _throwsType.$ThrowsResult(null, {}, _unionType.UnionType.term(null, {}, errors));\n          }\n        } else {\n          throwableType = returnType;\n          returnType = _type.Type.Undefined;\n        }\n      }\n\n      const typeName = _functionType.FunctionType.getName(args, returnType, genericParams, false, throwableType && throwableType.errorType);\n\n      const type = _functionType.FunctionType.term(typeName, {}, args, returnType);\n\n      type.throwable = throwableType && throwableType.errorType;\n\n      if (genericParams.length === 0 || !(type instanceof _functionType.FunctionType)) {\n        return type;\n      }\n\n      return _genericType.GenericType.new(typeName, {}, genericParams, localTypeScope, type);\n  }\n\n  return _type.Type.Unknown;\n}\n\nfunction mergeObjectsTypes(obj1 = _objectType.ObjectType.term(\"{ }\", {}, []), obj2 = _objectType.ObjectType.term(\"{ }\", {}, []), typeScope) {\n  if (obj1 instanceof _typeVar.TypeVar) {\n    return obj1;\n  }\n\n  if (obj2 instanceof _typeVar.TypeVar) {\n    return obj2;\n  }\n\n  return _objectType.ObjectType.term(null, {\n    isSoft: !obj1.isStrict\n  }, [...obj1.properties.entries(), ...obj2.properties.entries()]);\n}\n\nfunction createObjectWith(key, type, typeScope, meta) {\n  const properties = [[key, new _variableInfo.VariableInfo(type, new _variableScope.VariableScope(_variableScope.VariableScope.OBJECT_TYPE, new _moduleScope.ModuleScope(\"Hegel works wrong if you see this path. Please send us an issue.\")), meta)]];\n  return _objectType.ObjectType.term(_objectType.ObjectType.getName(properties), {}, properties);\n}\n\nfunction get(variable, propertyChaining, memberExpressionLoc) {\n  if (!propertyChaining) {\n    return;\n  }\n\n  return propertyChaining.reduce((type, propertyName) => {\n    if (!(type instanceof _objectType.ObjectType)) {\n      return;\n    }\n\n    const property = type.properties.get(propertyName);\n\n    if (property === undefined) {\n      return;\n    }\n\n    return property.type;\n  }, variable.type);\n}\n\nfunction createSelf(node, parent) {\n  return _typeVar.TypeVar.new(node.id.name, {\n    isSubtypeOf: _typeVar.TypeVar.Self,\n    parent\n  }, undefined, undefined, true);\n}\n\nfunction getPropertyName(property) {\n  if (property.key !== undefined) {\n    return property.key.name;\n  }\n\n  switch (property.type) {\n    case _nodes2.default.TS_CALL_SIGNATURE_DECLARATION:\n      return _constants.CALLABLE;\n\n    case _nodes2.default.TS_CONSTRUCT_SIGNATURE_DECLARATION:\n      return _constants.CONSTRUCTABLE;\n\n    case _nodes2.default.TS_INDEX_PROPERTY:\n      return _constants.INDEXABLE;\n  }\n\n  throw new Error(\"Never\");\n}\n\nfunction getResultObjectType(object) {\n  const indexable = object.properties.get(_constants.INDEXABLE);\n\n  if (indexable !== undefined) {\n    object.properties.delete(_constants.INDEXABLE);\n    indexable.type.isSubtypeOf = object;\n    indexable.type.name = object.name;\n    object.parent.body.set(object.name, indexable.type);\n    object.name = `${String(object.name)}.prototype`;\n    object.parent.body.set(object.name, object);\n    return indexable.type;\n  }\n\n  return object;\n}\n\nfunction getPropertiesForType(type, node) {\n  switch (type && type.constructor) {\n    case _objectType.ObjectType:\n      // $FlowIssue\n      return type.properties;\n\n    case _bottomType.$BottomType:\n      // $FlowIssue\n      return getPropertiesForType(type.unpack(), node);\n\n    case _functionType.FunctionType:\n    case _collectionType.CollectionType:\n      // $FlowIssue\n      return getPropertiesForType(type.isSubtypeOf, node);\n\n    case _genericType.GenericType:\n      throw new _errors2.default(\"Generic type should be applied before usage\", node.loc);\n\n    case _type.Type:\n      throw new _errors2.default(\"Type can not be extended by simple type\", node.loc);\n\n    default:\n      throw new _errors2.default(`Can not be extended by ${String(type && type.name)}`, node.loc);\n  }\n}\n\nfunction getWrapperType(argument, typeGraph) {\n  let type = argument instanceof _variableInfo.VariableInfo ? argument.type : argument;\n  type = type instanceof _immutableType.$AppliedImmutable ? type.readonly : type;\n\n  if (type instanceof _unionType.UnionType) {\n    const variants = type.variants.map(t => getWrapperType(t, typeGraph));\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n  return type.getWrapperType() || argument;\n}\n\nfunction getFalsy() {\n  return [_type.Type.False, _type.Type.term(0, {\n    isSubtypeOf: _type.Type.Number\n  }), _type.Type.term(\"0n\", {\n    isSubtypeOf: _type.Type.BigInt\n  }), _type.Type.term(\"''\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.Null, _type.Type.Undefined];\n}\n\nfunction pickFalsy(type) {\n  if (type instanceof _unionType.UnionType) {\n    const variants = type.variants.map(pickFalsy).filter(Boolean);\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n  if (type === _unionType.UnionType.Boolean) {\n    return _type.Type.False;\n  }\n\n  if (type === _type.Type.String) {\n    return _type.Type.term(\"''\", {\n      isSubtypeOf: _type.Type.String\n    });\n  }\n\n  if (type === _type.Type.Number) {\n    return _type.Type.term(0, {\n      isSubtypeOf: _type.Type.Number\n    });\n  }\n\n  if (type === _type.Type.BigInt) {\n    return _type.Type.term(\"0n\", {\n      isSubtypeOf: _type.Type.BigInt\n    });\n  }\n\n  if (type === _type.Type.Undefined || type === _type.Type.Null) {\n    return type;\n  }\n\n  if (isFalsy(type)) {\n    return type;\n  }\n}\n\nfunction pickTruthy(type) {\n  if (type instanceof _unionType.UnionType) {\n    const variants = type.variants.map(pickTruthy).filter(Boolean);\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n  if (type === _unionType.UnionType.Boolean) {\n    return _type.Type.True;\n  }\n\n  if (!isFalsy(type)) {\n    return type;\n  }\n}\n\nfunction isFalsy(type) {\n  return getFalsy().includes(type);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _keysType = require(\"../type-graph/types/keys-type\");\n\nvar _pickType = require(\"../type-graph/types/pick-type\");\n\nvar _omitType = require(\"../type-graph/types/omit-type\");\n\nvar _softType = require(\"../type-graph/types/soft-type\");\n\nvar _classType = require(\"../type-graph/types/class-type\");\n\nvar _strictType = require(\"../type-graph/types/strict-type\");\n\nvar _typeOfType = require(\"../type-graph/types/type-of-type\");\n\nvar _throwsType = require(\"../type-graph/types/throws-type\");\n\nvar _valuesType = require(\"../type-graph/types/values-type\");\n\nvar _entriesType = require(\"../type-graph/types/entries-type\");\n\nvar _excludeType = require(\"../type-graph/types/exclude-type\");\n\nvar _partialType = require(\"../type-graph/types/partial-type\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _returnType = require(\"../type-graph/types/return-type\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _instanceOfType = require(\"../type-graph/types/instance-of-type\");\n\nvar _propertyType = require(\"../type-graph/types/property-type\");\n\nvar _intersectionType = require(\"../type-graph/types/intersection-type\");\n\nconst mixUtilityTypes = moduleScope => {\n  const typeScope = moduleScope.typeScope;\n  const utilityTypes = new Map([[\"$PropertyType\", new _propertyType.$PropertyType(_propertyType.$PropertyType.name, {\n    parent: typeScope\n  })], [\"$InstanceOf\", new _instanceOfType.$InstanceOf(_instanceOfType.$InstanceOf.name, {\n    parent: typeScope\n  })], [\"$Keys\", new _keysType.$Keys(_keysType.$Keys.name, {\n    parent: typeScope\n  })], [\"$Entries\", new _entriesType.$Entries(_entriesType.$Entries.name, {\n    parent: typeScope\n  })], [\"$Values\", new _valuesType.$Values(_valuesType.$Values.name, {\n    parent: typeScope\n  })], [\"$Partial\", new _partialType.$Partial(_partialType.$Partial.name, {\n    parent: typeScope\n  })], [\"$Pick\", new _pickType.$Pick(_pickType.$Pick.name, {\n    parent: typeScope\n  })], [\"$Omit\", new _omitType.$Omit(_omitType.$Omit.name, {\n    parent: typeScope\n  })], [\"$ReturnType\", new _returnType.$ReturnType(_returnType.$ReturnType.name, {\n    parent: typeScope\n  })], [\"$TypeOf\", new _typeOfType.$TypeOf(_typeOfType.$TypeOf.name, {\n    parent: typeScope\n  })], [\"$Intersection\", new _intersectionType.$Intersection(_intersectionType.$Intersection.name, {\n    parent: typeScope\n  })], [\"$Throws\", new _throwsType.$Throws(_throwsType.$Throws.name, {\n    parent: typeScope\n  })], [\"$Immutable\", new _immutableType.$Immutable(_immutableType.$Immutable.name, {\n    parent: typeScope\n  })], [\"$Collection\", new _collectionType.$Collection(_collectionType.$Collection.name, {\n    parent: typeScope\n  })], [\"$Soft\", new _softType.$Soft(_softType.$Soft.name, {\n    parent: typeScope\n  })], [\"$Strict\", new _strictType.$Strict(_strictType.$Strict.name, {\n    parent: typeScope\n  })], [\"$Class\", new _classType.$Class(_classType.$Class.name, {\n    parent: typeScope\n  })], [\"$Exclude\", new _excludeType.$Exclude(_excludeType.$Exclude.name, {\n    parent: typeScope\n  })]]);\n\n  for (const [name, type] of utilityTypes) {\n    typeScope.body.set(name, type);\n    type.parent = typeScope;\n  }\n};\n\nexports.default = mixUtilityTypes;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPropertyName = getPropertyName;\nexports.getVariableInfoFromDelcaration = getVariableInfoFromDelcaration;\nexports.getSuperTypeOf = getSuperTypeOf;\nexports.getVariableType = getVariableType;\nexports.addVariableToGraph = addVariableToGraph;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _constants = require(\"../type-graph/constants\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _common = require(\"./common\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _typeUtils = require(\"./type-utils\");\n\nvar _scopeUtils = require(\"./scope-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getPropertyName(node) {\n  const isPrivate = node.type === _nodes2.default.CLASS_PRIVATE_METHOD || node.type === _nodes2.default.CLASS_PRIVATE_PROPERTY;\n\n  if (isPrivate) {\n    return `#${node.key.id.name}`;\n  }\n\n  if (node.kind === \"constructor\") {\n    return _constants.CONSTRUCTABLE;\n  }\n\n  return node.key.name || `${node.key.value}`;\n}\n\nfunction getVariableInfoFromDelcaration(currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute) {\n  const parentScope = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, typeGraph);\n  const currentTypeScope = (0, _scopeUtils.findNearestTypeScope)(parentScope, typeGraph);\n  const annotatedType = (0, _typeUtils.getTypeFromTypeAnnotation)(currentNode.id && currentNode.id.typeAnnotation, currentTypeScope, parentScope, false, null, parentNode, typeGraph, precompute, middlecompute, postcompute);\n  return new _variableInfo.VariableInfo(annotatedType, parentScope, new _meta.Meta(currentNode.loc), currentNode.kind === \"const\");\n}\n\nfunction getSuperTypeOf(type, typeScope, withUnion = false) {\n  if (type === _type.Type.True || type === _type.Type.False) {\n    return _unionType.UnionType.Boolean;\n  }\n\n  if (type instanceof _unionType.UnionType) {\n    return withUnion ? _unionType.UnionType.term(null, {}, type.variants.map(variant => getSuperTypeOf(variant, typeScope, withUnion))) : type;\n  }\n\n  if (type.isSubtypeOf == undefined || type.name === null || type instanceof _functionType.FunctionType || type instanceof _objectType.ObjectType && String(type.name)[0] !== \"{\") {\n    return type;\n  }\n\n  if (type instanceof _tupleType.TupleType) {\n    // $FlowIssue Array is always GenericType\n    return _collectionType.CollectionType.Array.root.applyGeneric([getSuperTypeOf(type.items.length === 0 ? _type.Type.Unknown : _unionType.UnionType.term(null, {}, type.items.map(a => getSuperTypeOf(a, typeScope, withUnion))), typeScope, true)]);\n  }\n\n  if (type instanceof _objectType.ObjectType) {\n    const propertyTypes = [...type.properties.entries()].map(([key, v]) => [key, v.type]);\n    const newProperties = propertyTypes.map(([key, p]) => [key, // $FlowIssue\n    Object.assign(new _variableInfo.VariableInfo(), type.properties.get(key), {\n      type: getSuperTypeOf(p, typeScope, withUnion)\n    })]);\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(newProperties), {}, newProperties);\n  }\n\n  return type.isSubtypeOf;\n}\n\nfunction getVariableType(variable, newType, typeScope, inferenced = false, freezed = false) {\n  if (variable && variable.type !== _type.Type.Unknown) {\n    return variable.type;\n  }\n\n  if (!inferenced || newType instanceof _immutableType.$AppliedImmutable || variable && variable.isConstant && (newType.constructor === _type.Type || newType.constructor === _tupleType.TupleType)) {\n    return newType;\n  }\n\n  return getSuperTypeOf(newType, typeScope);\n}\n\nfunction addVariableToGraph(currentNode, parentNode, moduleScope, precompute, middlecompute, postcompute, customName = (0, _common.getDeclarationName)(currentNode)) {\n  const variableInfo = getVariableInfoFromDelcaration(currentNode, parentNode, moduleScope, precompute, middlecompute, postcompute);\n  variableInfo.parent.body.set(customName, variableInfo);\n\n  if (moduleScope instanceof _moduleScope.PositionedModuleScope && currentNode.id != null) {\n    moduleScope.addPosition(currentNode.id, variableInfo);\n  }\n\n  return variableInfo;\n}"],"sourceRoot":""}